---
title: "数据库"
date: 2025-03-02
categories:
  - 面试
tags:
  - 面试
---

B+树和B树的区别

B树：数据可以在内部节点，插入删除可能破坏结构造成更多操作，适合随机访问要求高，如操作系统的文件系统索引

B+树：数据只在叶子节点，插入删除更简单，适合范围查询和顺序查询，如数据库索引，叶子节点形成双向链表方便查找

#### mysql隔离级别

* T1事务可能读取到T2事务未提交的数据，但是最后T2回滚了，导致T1读取到了一个未存在的数据，从而导致**脏读**现象
* T1在读取同一行数据的两次结果不一样，从而导致**不可重复读**的问题
* T1在执行范围查询或范围修改的时候,T2插入了一条属于T1范围内的数据，并且提交了，这个时候T1查询的时候发现多了一条数据，造成了**幻读**现象
* 

- 读未提交：直接读取数据版本链中的最新版本
- 读已提交：使用快照读，即按照MVCC读取符合ReadView要求的版本数据，生成多个ReadView，解决了脏读
- 可重复读：使用快照读，只会在首次查询时生成ReadView，解决了不可重复读
- 串行化：读取时加入共享表锁，更新时加入独占表锁，解决了幻读

Innodb默认是可重复读，因为他需要保证事务ACID特性中的隔离性，通过Next-key避免幻读

> MVCC就是在事务启动的时候对数据库拍了个快照，保留了那个时候的状态，这个事务后续的读取都从快照中获取，哪怕加了新的数据，也不会影响

#### 意向锁

意向锁是一种用于数据库管理系统，它试图在锁定资源之前表明事务希望锁定该资源。当一个事务想要获得锁时，数据库会检查是否存在资源的意向锁。

#### 回表

回表是指二级索引，你通过当前索引不能查询到想要的数据，需要再查找一个主键主键索引才能找到。避免回表的方法：在索引中包含查询所需的所有字段，这样，在查询时，不需要再回原表。

#### 索引覆盖

不用回表

#### mysql锁

全局锁：加锁后整个数据库实例都处于只读状态。

表锁：锁定整张表

行锁：并发度高，但是加锁资源开销比较大，Innodb支持

#### 慢查询优化

是否用了索引，该索引是否是最左索引
是否返回了过多字段，查出了多余数据
检查数据是否过多，是否应该进行分库分表
检查数据库实例所在的机器性能
修改配置文件：在my.ini文件中，慢查询的定义事件是超过2秒，我们可以修改慢查询的定义
优化数据库结构：合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。
少使用join语句：比如左连接必须先查左表全表扫描，然后一条条到外表去查询
利用explain的key，看看到底使用了哪个索引，把用不到的索引删除掉
如果是联合索引，考虑是否满足最左前缀原则，尽量少使用聚合函数
like模糊查询的%不可以放在最前面，不要使用or、union（去重）、not in这些条件查询

#### 聚簇索引和非聚簇索引

都是B+树

- 聚簇索引：将数据存储与索引放在一块，找到了索引也就找到了数据
- 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，需要回表，相当于字典查询中的按照偏旁查找

#### Redis和MySQL如何保证数据一致

先删除缓存再更新数据库

延迟双删：先删redis，再更新mysql，延迟一段时间再删redis，这样就算在更新mysql时，有其他线程读了mysql，把老数据读到了redis中，也会被删掉，从而保证数据一致

#### 一页多大

一页16kb，操作系统一页4kb