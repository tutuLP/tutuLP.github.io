---
title: "c++面试"
date: 2024-06-09
categories:
  - 面试
tags:
  - 面试
---

# STL

### 顺序容器

1. **`std::vector`**： 动态数组，可以随机访问元素，支持高效的尾部插入和删除操作。  **连续内存**

2. **`std::deque`**： 双端队列，支持高效的头部和尾部插入和删除操作。 **数组块+映射表**  deque没有capacity(),返回当前可容纳元素数目

3. **`std::list`**： 双向链表，支持高效的插入和删除操作，但不支持随机访问。

4. **`std::forward_list`**： 单向链表，仅支持单向遍历，节省空间。

### 关联容器

1. **`std::map`**： 有序关联容器，存储键值对，键是唯一的，按照键的顺序排序(底层红黑树，默认升序)。

2. **`std::multimap`**： 有序关联容器，允许键重复，按照键的顺序排序。

3. **`std::set`**： 有序集合，存储唯一的元素，按照元素的顺序排序。

4. **`std::multiset`**： 有序集合，允许元素重复，按照元素的顺序排序。

### 无序容器

1. **`std::unordered_map`**： 无序关联容器，存储键值对，键是唯一的，基于哈希表实现。

2. **`std::unordered_multimap`**： 无序关联容器，允许键重复，基于哈希表实现。

3. **`std::unordered_set`**： 无序集合，存储唯一的元素，基于哈希表实现。

4. **`std::unordered_multiset`**： 无序集合，允许元素重复，基于哈希表实现。

### 容器适配器

1. **`std::stack`**： 栈适配器，通常基于 `std::deque` 实现，也可以基于 `std::vector` 或 `std::list` 实现。

2. **`std::queue`**： 队列适配器，通常基于 `std::deque` 实现。

3. **`std::priority_queue`**： 优先队列适配器，通常基于 `std::vector` 实现，用于维护一个堆结构。

### 特殊容器

1. **`std::array`**： 定长数组，大小在编译时确定。

2. **`std::bitset`**： 定长二进制数组，用于高效存储和操作二进制位。

### 选择合适的容器

选择合适的容器取决于具体需求：

- 需要随机访问：`std::vector` 或 `std::deque`
- 需要高效的头尾部插入/删除：`std::deque`
- 需要高效的任意位置插入/删除：`std::list` 或 `std::forward_list`
- 需要键值对存储且按键排序：`std::map`
- 需要键值对存储且按哈希表存储：`std::unordered_map`
- 需要存储唯一元素且按顺序排序：`std::set`
- 需要存储唯一元素且按哈希表存储：`std::unordered_set`
- 需要LIFO结构：`std::stack`
- 需要FIFO结构：`std::queue`
- 需要优先级队列：`std::priority_queue`

# 其他

## 容器与数据结构

### vector中push_back和emplace_back的区别？

push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。但是，如果是传递对象，那么二者都是一样的

### map和set的区别和底层实现，map取值的find、[]、at方法的区别

map和set都是关联式容器，底层实现是红黑树，增删查改的时间复杂度都为O(logn)。map存储键值对，set只存键

取值方法区别

find：找键返回迭代器，若无，返回end()，安全
[]：找键返回值，若不存在，会自动插入
at：找键返回值，若不存在，会抛出std::out_of_range异常，安全。

###什么是布隆过滤器？***

他是一个数据结构（很长的二进制向量） ，可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点。他只能告诉我们一个元素绝对不在集合内或可能在集合内。布隆过滤器很难实现删除操作。

布隆过滤器主要是为了防止redis缓存击穿问题（前端要查询一个数据，但是redis没有这个数据，就会去数据库查询，数据库可能承受不了这么大的流量就挂掉了）。有了布隆过滤器，就能判断哪些数据不在数据库中，防止缓存击穿。

###红黑树讲一下，怎么翻转？
红黑树的特性：

节点是红色或黑色的
根节点都是黑色的
所有叶子节点（null、空节点）都是黑色的
如果一个节点是红色，那么他的两个子结点必然是黑色
从任意节点到叶子节点的黑色节点数相同
翻转

左旋：以某个节点(A)为轴，将其右节点（B）上移至A的位置，将A作为B的左子结点。原B的左子节点变为A的右子结点
右旋：以某个节点(A)为轴，将其左节点（B）上移至A的位置，将A作为B的右子节点。原B的右子节点变为A的左子节点

###unordered_map中哈希冲突的解决方法
* 链地址法：键值添加到相应索引处的链表（unordered_map实现的方法）

优点：对哈希函数要求低，删除操作简单

缺点：元素过多会导致查询效率降低；由于链表使得数据访问不连续，对CPU缓存不友好

优化方法

使用平衡树代替链表
自适应库容/缩容：随着元素增加，哈希表动态调整其大小，比如rehash

* 开放地址法：试图找到冲突索引后的数组位置的一个空位

优点：无需额外的空间存储链表，空间利用率高；可以有效利用CPU缓存
缺点：对哈希函数要求较高；删除操作相对复杂
unordered_map使用的哈希函数是使用的std::hash作为哈希函数。

* 再哈希

## 新特性

### c++11

####C++11的单例模式

线程安全：C++11的单例模式提供了线程安全的初始化和使用手段，确保在多线程环境下单例的正确性。主要是因为C++11引入了新的内存模型和原子操作。

c++11的特性使懒汉模式不用加锁

####智能指针的运用场景？***

1. 资源共享：当多个对象需要共享相同的资源时，可以采用shared_ptr，例如观察者模式
2. 管理独占资源：可以采用unique_ptr
3. 实现RAII：使得程序员不用担心内存泄漏的问题
4. 解决循环引用问题，：使用weak_ptr，引用不计数；主要是为了防止重复释放资源，weak_ptr不能直接访问指向的对象，std::shared_ptr<A> a_shared = b->a_ptr.lock();转换成shared_ptr后访问。

####智能指针的循环引用问题？

两个智能指针指向互相指向对方，导致双方不能正常析构，引起内存泄漏。可以使用weak_ptr，他不会增加引用计数。

shapre_ptr的创建、复制、销毁是线程安全的。但是，当存在共享对象的时候，还是需要加锁；总之，shared_ptr的部分操作是线程安全的。shapred_ptr的引用计数是通过原子操作来保证线程安全的。

### c++20 

协程 比线程更小的

## 多进程，多线程

####我在调用fork之前打开了一个文件，那我子进程和父进程对这个文件描述符进行写入是追加还是重写？

二者共享相同的文件偏移量，所以不会相互覆盖，而是追加到彼此写入的内容中。但是为了避免意外，还是加锁更加安全。

####讲讲协程，协程一定无锁吗？

协程是更轻量级的线程，主要是他可以在用户态调度，这样说明协程的创建、销毁、调度可以由程序员自己控制，而非操作系统。

协程不能保证代码完全无锁。协程降低了多线程编程中一些潜在的并发隐患，但访问共享资源时，仍然需要加锁。

###进程间通信IPC

管道pipe，半双工(单方向)，只能用于父子等具有亲缘关系的进程间使用

消息队列：全双工 msgget msgsnd msgrcv 

共享内存：shmget shmat shmdt

信号量：信号量主要用于进程间的同步和互斥，它是一个计数器，用于控制对共享资源的访问 semget semop semctl

套接字

###线程通信

共享变量：全局变量或类的成员变量，结合锁或信号量

消息队列

条件变量：满足条件通知

信号量：计数器，为0等待

线程安全：原子操作atomic，thread_local

### 如果有一个变量已经定义，然后再申请多进程和多线程，他们也会有这个变量吗

进程：会有自己的内存空间，进行数据复制互不影响

线程：共享全局变量，局部变量有各自副本(线程指定函数运行)

### 进程调度算法

先来先服务，最短作业优先，优先级调度算法，时间片轮转，多级反馈队列算法：设置多个不同优先级的就绪队列，每个队列采用不同的调度算法。新进程会首先进入最高优先级队列，按照时间片轮转算法执行。如果在一个时间片内没有执行完，会被降到下一级队列。各级队列之间采用优先级调度算法。

## 面向对象

####重载、重写（覆盖）、隐藏 ？

- 重载是函数名相同，但是参数或返回值不同，可以有不同地实现。
- 重写是多态的内容，是父类写了虚函数，子类有自己的实现。
- 隐藏是在子类中定义了父类完全相同的变量或函数，导致父类的同名元素被隐藏。

####虚函数的底层实现，多继承（一个派生类继承多个基类）的虚指针的虚表的形式

虚函数的底层依赖**虚指针**(vptr)和**虚函数表**(vtable)。多继承是一个派生类继承多个基类，多继承中的虚指针和虚函数为如下：

虚指针（4/8字节）：每个含有虚函数的类都会有一个虚指针，指向虚函数表
虚函数表：虚函数表是一个函数指针数组，存放着虚函数的地址。每个继承自基类的派生类都有自己的虚函数表，虚函数表中的函数指针顺序与基类的函数声明顺序一致。（有多少个虚函数，就有多少个函数指针）
虚析构函数：在删除指针的时候，会先调用派生类的析构函数，再调用基类的析构函数。如果基类的析构函数不是虚的，那么删除基类指针时只会调用基类的析构函数，从而导致资源未正确释放以及内存泄漏的问题。

如果一个类什么都没有，则sizeof()是1，如果有一个或多个虚函数，则sizeof()是8，因为虚指针8个字节。虚函数指针通常位于对象的开始位置。

另外，虚函数表存储在常量区的数据段（只读数据段）。它是一个静态数据结构，在编译式就确定了，后面不会修改。

####除了多态和继承还有什么面向对象方法***

- 封装：将对象属性和行为放到一个对象中，并限制对这些属性的访问，隐藏细节
- 抽象：通过创建外界接口，隐藏底层细节
- 组合：一个类包含另一个类，二者是同生死的关系
- 聚合：弱组合，可以单独存在（结构体）

#### 动态绑定

程序运行时才确定要调用的函数版本

每个包含虚函数的对象都会有一个指向虚函数表的指针

基类指针指向派生类对象，使用指针调用虚函数，会根据实际的派生类对象调用虚函数

####抽象类与纯虚函数，作用，有函数体是否编译

抽象类不能被实例化，只能被继承。纯虚函数是没有函数体的虚函数，目的就是让派生类重写。当一个类有纯虚函数的时候，就是抽象类。

纯虚函数：`virtual float getArea() = 0;`

####override和final的作用

- `override`用于指定派生类中一个函数是用来重写的，以确保子类函数和父类函数名才相同，**表明了函数重写的意图**
- `final`作用于类的时候，表明该类不能被其他类继承，这样可以防止类的继承层次过深。同时，有final的函数，不能在派生类中重写。

#### 细讲static，包括static成员变量与函数

static成员变量被类的所有对象共享。

static成员函数是属于类的，在没有创建类的实例时也可直接只用。它们不能访问类的非静态成员，因为非静态成员需要类的实例。

需要注意的是，static成员变量和函数的作用域仅限于定义它们的类。要在类外部访问，需要加::

####给定类，判断大小，包括空类，加入static，加入虚函数，考虑到内存对齐
空类的大小为1
static成员变量不影响类的大小，因为它们是类的所有实例共享的。静态成员变量在子类的实例之外单独分配内存
虚函数：有虚函数的类会比没有虚函数的类多一个8字节的虚函数表指针
内存对齐：根据不同平台和编译器，编译器可能会在类成员之间添加填充字节，以确保数据对齐。

#### 如何让类只能在堆上创建，不能在栈上创建？

~~~c++
class HeapOnly {
private:
    HeapOnly() {} // 私有构造函数
    ~HeapOnly() {} // 私有析构函数

public:
    // 使用静态成员函数在堆上创建对象的实例
    static HeapOnly* Create() {
        return new HeapOnly();
    }

    // 添加成员函数以释放对象占用的内存
    void Destroy() {
        delete this;
    }
};
~~~



## 其他

* RPC：是一种允许程序调用另一个地址空间（通常在另一台共享网络的计算机上）的程序的技术，就像调用本地子程序一样

* 数据序列化：数据序列化是将数据结构或对象状态转换成可以存储或传输的格式的过程。通过序列化，复杂的数据结构可以被转换为字节流，从而便于存储到文件、数据库，或者通过网络传输。如json xml

* 反序列化则是将字节流恢复成原始数据结构或对象状态的过程。

* 网络传输用的大端-高字节存低地址

###引用和指针

~~~c++
int x=10;
int *p=&x;
int &y=x;

int z=*p;使用需要解引用
int z=y; y是x的别名
~~~

###静态变量在哪里初始化

程序开始时初始化，内存分配在编译期间完成，占用内存大小固定。

在内存的静态/全局区，这部分用于存储全局变量和静态变量。

### 编译过程，那静态变量是在哪个阶段初始化的?

预处理：宏替换、头文件包含等
编译：转为汇编
汇编：转为机器语言
链接：将多个文件和需要的库文件链接成一个可执行程序
全局静态变量的初始化值存储在可执行文件中，而函数内的局部静态变量在函数第一次调用时进行初始化。

为什么需要链接这个过程？

整合源文件编译后的二进制文件成可执行文件，链接所需的动态库，方便动态库的替换。



### 左值和右值？

**左值**

1. 可以取地址
2. 具有持久性

**右值**

1. 将亡值
2. 不能取地址
3. 表示临时结果，字面值或不能被赋值的对象

###左值引用和右值引用的意义？

左值引用：

* 作为函数的参数传递避免拷贝
* 可以根据参数是左值引用还是常量左值引用进行函数重载
* 操作符重载 实现链式调用 Vector& operator+=(const Vector& other)

右值引用：右值引用声明符 &&

* 移动语义：移动构造函数和移动赋值运算符配合std::move使用
  * MyString(MyString&& other) noexcept : data(other.data), length(other.length)
  * MyString& operator=(MyString&& other) noexcept

* 完美转发：std::forward()：在函数模板中保持参数的类型和值类别（左值或右值）不变


声明出来的左值引用、右值引用都是左值
###涉及atoi函数要考虑哪些问题？
这是将字符串转换为整数（const char* -> int），需要考虑：

空字符串处理
空格处理
数值范围
符号，可能数字前面有正负号，以确定返回的整数应该是正数还是负数

> 找第一个非空字符，识别加减号或数字，返回int
> 11a返回11  无影响
> a11返回0

### new和malloc的区别？***

new是C++的一个操作符，malloc是库函数
new会调用构造函数，malloc只是分配内存
关于返回值，new会返回对应类型的指针，malloc返回void*   （void*需要显示转换才能解引用，可以用于通用函数参数）
在回收内存的时候，new采用delete或delete[]，malloc采用free
使用new的时候先调用malloc，再调用构造；delete时，先调用析构，再调用free

### define和const的区别？

\#define常常用于宏定义，在预编译阶段，但是没有类型检查导致难以发现的错误，并且没有作用域，能使用\#undef取消定义

cosnt是常量，在编译阶段。有作用域和类型检查，便于调试。

###内存泄漏的查找方法
检查代码，查看是否有分配内存但是没有释放的情况
内存分析工具，比如C++的Valgrind，Go内置的pprof功能
使用RAII，比如C++的只能指针
一般**堆**内存泄露就是申请了内存资源没有释放，**栈**内存泄漏比较少见，一般发生在栈溢出的情况，是由于递归过深导致的，或者用了过大的局部变量，需要检查代码。




Linux进程间通信

- 管道(pipe)、流管道(s_pipe)、有名管道(FIFO)
- 信号(signal)
- 消息队列
- 共享内存
- 信号量
- 套接字(socket)

###指针和引用的区别，引用初始化后是可变的吗

指针是一个变量的地址，引用是一个变量的别名，引用必须初始化，因为在之后无法改变引用所指的对象。

引用在本质上 是一个常量指针，即所指的对象不能发生改变，但可以改变指向对象的值。

###sizeof引用和sizeof指针的区别，指针和引用占用内存空间吗？理解引用是啥意思吗

sizeof指针返回的是指针的大小，4个字节，sizeof引用返回的是指向对象的大小，比如一个float就是8字节。

###内存什么时候回收？显式delete才会回收吗？什么时候对象生命周期到达？栈里面的对象会自动回收吗？常量会自动回收吗？
C++是这样的，显示delete回收。对于栈中的对象，无需显示删除，当函数返回时，会自动回收。

全局常量在整个程序运行周期都在，局部常量与作用域有关。也不需要显示回收。

### memcpy函数实现，memmove呢

~~~c++
//memcpy
void *my_memcpy(void *dest, const void *src, size_t n) {
    char *d = (char *)dest;
    const char *s = (const char *)src;

    for (size_t i = 0; i < n; i++) {
        d[i] = s[i];
    }

    return dest;
}
//memmove能处理内存重叠
void *my_memmove(void *dest, const void *src, size_t n) {
    char *d = (char *)dest;
    const char *s = (const char *)src;

    if (d < s) {
        // 从前往后复制
        for (size_t i = 0; i < n; i++) {
            d[i] = s[i];
        }
    } else {
        // 从后往前复制，处理内存重叠情况
        for (size_t i = n; i > 0; i--) {
            d[i - 1] = s[i - 1];
        }
    }
    return dest;
}
~~~

### 如果将一个模板类的.h文件和.cpp文件分开，别的文件调用该包，会出现什么错误？为什么普通的类就可以分开呢？

模板类是在编译的时候生成的，如果将定义放在.cpp文件中会导致编译器在处理其他源文件的时候找不到完整的模板定义。对于模板类，编译器在编译时并不知道可能的所有类型参数，因此需要在使用模板时生成具体实例。所以，我们只有保留模板类的声明，并在同一个文件中添加实现。

模板类是在编译期间确定的，不是动态绑定的。

为什么普通的类就可以分开呢？

生成程序的时候有编译到链接的机制，链接阶段会把这些文件连接起来，而模板类在编译时并不知道可能的所有类型参数，因此需要在使用模板时生成具体实例。在链接阶段，编译器会检查所有具体类型的模板实例是否生成了相应的代码，如果找不到实例，就会报链接错误。总结：链接的时候不知道具体类型，无法整合

### .hpp文件

声明和定义在一个文件 如：内联函数，模板类模板函数，小型库

