# 计算机系统概述

##计算机发展历程

什么是计算机系统？  **硬件+软件**(系统软件 应用软件)

硬件的发展

* 第一台计算机 ENIAC 1946 冯诺依曼顾问 逻辑元件 1.8w个**电子管** 机器语言编程-纸带 有孔为0 bug：小虫子
* 第二代 贝尔实验室发明**晶体管** 面向过程语言：FORTRAN 操作系统
* 第三代 **中小规模集成电路** 高级语言 分时操作系统
* 第四代 **大规模，超大规模集成电路**

摩尔定律：集成电路的晶体管隔18个月能增强一倍，性能增强一倍

###计算机硬件的基本组成

早期冯诺依曼结构

第一代ENIAC需要手动接线输入指令，他提出**存储程序**：将指令以二进制代码的形式事先输入到计算机的主存储器

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240826214553477.png" alt="image-20240826214553477" style="zoom: 25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240826214729711.png" alt="image-20240826214729711" style="zoom:25%;" />

以运算器为中心导致效率降低

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240826214903324.png" alt="image-20240826214903324" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240826215033513.png" alt="image-20240826215033513" style="zoom:25%;" />

主存是内存 辅存是硬盘

### 各个硬件的工作原理

* ==主存储器==的基本组成：存储体 **+** MAR(存储地址寄存器) **+** MDR(存储数据寄存器)

MAR给出所需数据的地址，拿到数据后放到MDR

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240827082233562.png" alt="image-20240827082233562" style="zoom:33%;" />

存储字长是8的整数倍 电子元件是电容

MAR的位数反应存储单元的个数  MAR 4位表示一共2^4个存储单元

MDR位数=存储字长  16位MDR 每个单元可放16bit 1个字=16bit  (这里的字不是字节(B)8bit)

100Mbps指的是下载速度100M bit/s 下载器100/8M B/s



* ==运算器== ACC **+** MQ **+** X **+** ALU

作用：算术，逻辑运算

* * ACC 寄存器/累加器  存操作数或运算结果
  * MQ 乘除时存操作数或运算结果
  * X 通用寄存器   存操作数
  * ALU （核心）算术逻辑单元 实现算术和逻辑运算

了解一下

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240919185636923.png" alt="image-20240919185636923" style="zoom:50%;" />

* ==控制器==
* * CU 控制单元 分析指令，给出控制信号
  * IR 指令寄存器 存当前执行的指定
  * PC 程序计数器 存下一条指令的地址 自+1

顺序 PC->IR->CU

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240919190027508.png" alt="image-20240919190027508" style="zoom:50%;" />

![image-20240919190208752](http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240919190208752.png)

PC取完指令后，指向下一条指令的地址2

![image-20240919190355665](http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240919190355665.png)

### 多级层次结构

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240919190651059.png" alt="image-20240919190651059" style="zoom:50%;" />

高级语言    汇编语言    机器语言

* 编译程序：高级语言全部译为汇编语言或机器语言
* 汇编程序：汇编到机器
* 解释程序：高级到机器 翻译一句执行一句

## 计算机的性能指标

###存储器性能指标

* 主存储器总容量：MAR32位 MDR8位 2^32*8bit=4GB

MAR位数反应存储单元的个数

MDR位数反应每个存储单元的大小

* CPU主频 CPU数字脉冲信号震荡的频率 xGHz 越高cpu处理越快
* CPI 每条指令的执行需要多少个时钟周期

1000Hz 100条指令 平均CPI=3 需要执行多久？

100*3\*1/1000=0.3s

* IPS 每秒多少条指令 主频/CPI
* FLOPS 每秒多少次浮点运算 

前面可以加K M G T 分别是10的 3 6 9 12次方

* 文件大小

2^10 K

2^20 M

2^30 G

2^40 T

### 系统整体性能指标

数据通路带宽：数据总线一次能并行传递信息的位数

吞吐量：系统单位时间内处理请求的数量

响应时间：向计算机发送请求到获得响应需要等待的时间



基准程序：跑分软件

# 数据的表示和运算

## 进位转换

==二进制转化为8进制==：三位一组，（分别是4 2 1*对应位值）每组表示0-7 ， 前面不足的补0，小数点后的最后不足的补0  

==二进制转化为16进制==：四位一组

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240922112019739.png" alt="image-20240922112019739" style="zoom:50%;" />

==十六进制，八进制转化为二进制==：每个数字或字母转化为四位或三位二进制，去掉头尾的0

==符号表示==

十六进制：(1652)16 1652**H** **0x**1652

二进制 B

十进制 D

==十进制转为其他进制==

整数部分

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240922112447363.png" alt="image-20240922112447363" style="zoom:50%;" />

小数部分

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240922112637455.png" alt="image-20240922112637455" style="zoom:50%;" />

无限循环

## BCD码

==8421码==：每位十进制数用四位二进制表示 权重分别为8 4 2 1

加法：(手算)：5+8=13 用8421表示13 0001 0011

​	 （电脑）：0101+1000=1101不在映射表里面 则再加上数字六的BCD码0110  1101+0110=1 0011

==余3码==：8421对应规则+3(0011)

==2421码==：5-9首位是1



##unsigned

> unsigned char 1B	ASCLL是0-127
>
> unsigned short  2B 
>
> unsigned int   4B

==减法==：减数全部取反，末位+1，减法变加法

==位运算==:适合对无符号类型快速计算 无符号-原码表示 内存中都是二进制但是解释的时候会根据定义的类型

<< 向左移动低位补0 左移一次*2

\>\> 右移,高位补0/1 除2

\>\>\> 无符号右移,高位补1

##带符号整数

> short 2B
>
> int 4B
>
> 原码，补码，反码 同一个数的不同表现形式，含义相同
>
> 机器字长 64位或者32位 表示通用寄存器能存多少位 能进行多少位的带符号整数的运算
>
> 以8位通用寄存器为例子 8位是最小存储单元

==原码==：1位符号位 7位数值位

* 机器字长n+1位 带符号整数表示 -(2^n-1) <= x <= 2^n-1

* +0 与 -0 含义相同

* 原码运算：符号位不能参与运算，需要设计复杂的电路才能处理

==补码==:正数的补码是本身,负数是其二进制取反+1

* 原码 -> 反码 -> 补码
* 正数 三种状态一样
* 负数 -符号位不变 数值位取反> 反码 -末位+1> 补码
* 快速转换：负数原码 -> 补码 从右往左找到第一个1，左边所有的数值位取反
* 加法：全部按位相加
* 减法：减法看作加法，A-B=A+(-B) 
* 求-B的补码：全部位取反，末尾+1   快速：从右往左找到第一个1，左边所有位取反
* 因此同一套电路可以实现无符号和有符号的运算

> 最终一个字节范围[-128,127) 
>
> **11111111 -1**        (规定)
>
> 11111110 表示-2     -1 + -2  11111101 = -3
>
> 10000001 表示-127 
>
> 10000000 -128
>
> 00000000 0
>
> 00000001 1 
>
> 01111111 127

==特性比较==：n位能表示的最大值为2^n - 1

* n+1位
* 原码 [-(2^n - 1) , 2^n - 1]
* 反码 [-(2^n - 1) , 2^n - 1]
* 补码 [-2^n , 2^n - 1]
* 无符号整数 [0 , 2^n+1 - 1]
* 是否发生溢出：-64+(-64) 用原码则溢出，补码则没有溢出

> 所以隐式转化就是非负数前面+0，负数前面+1,强制转换就是把前面多余的字节直接切掉,极大可能导致数据改变
>
> <img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017231702621.png" alt="image-20241017231702621" style="zoom:33%;" />

==移码==：补码基础上，符号位取反

* 只能表示整数

* 以8位为例，从-128到127 从00000000到11111111

* 通常用于浮点数的阶码当中

## 定点小数

> 定点：小数点位置固定
>
> 定点整数：有符号整数  原码，反码，补码，移码
>
> 定点小数： 		  原码，反码，补码

整数.小数 小数点默认在整数的最后，在小数的符号位后面

符号位.位权 0/1.2^-1 2^-2 ... 2^-7   -0.5 0.25 0.125

转换规则与整数一摸一样

加法减法，与整数的规则也一样

* 原码 [-(1 - 2^n) , 1 - 2^n]
* 反码 [-(1 - 2^n) , 1 - 2^n]
* 补码 [-1 , 1- 2^n]

##电路

> ALU 算术逻辑单元  输入信号 输出信号 控制信号(cu) -> 算术/逻辑运算 
>
> ALU多少位 寄存器就多少位 也就是机器字长

* 基本逻辑运算：与 && 或 || 非 !  对应三个门电路 * +

> 优先级:与 > 或
>
> 分配律 结合律 实现电路简化
>
> 异或 :相同为0

==1位全加器 FA==:<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017202812019.png" alt="image-20241017202812019" style="zoom:33%;" />

串行加法器:进位信息保存起来,计算两个n位相加,串行执行n次,每次输出一个结果

并行加法器:<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017203020308.png" alt="image-20241017203020308" style="zoom:33%;" />

==并行进位加法器 CLA==:每个进位并行同时产生

==补码加减运算器==:减数全部按位取反+1 变加法 

> 用Sub控制加法或者减法,加法为0,不做任何处理,进位为0   减法则进位为0 减数取反,进位为1
>
> 无符号也可以使用

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017214454361.png" alt="image-20241017214454361" style="zoom:33%;" />

==原码的加减==:<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017220129021.png" alt="image-20241017220129021" style="zoom:33%;" />

==补码的加减运算==:不用考虑符号位,直接参与运算

> 只有正数+正数 负数+负数 才会溢出
>
> 正数+正数  得到的结果看起来是负数 
>
> 负数+负数  得到的结果看起来是正数

==溢出判断==:

方法一:<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241017230651828.png" alt="image-20241017230651828" style="zoom: 33%;" />v的值为1 则有溢出 ABS分别表示AB的符号和结果的符号位

方法二:符号位往更高位进位为Cs 符号位C1 他们异或为1 则溢出

方法三:双符号位:00 11 都参与运算 与法二一样

> 双符号位 :模4补码 实际也是存一个符号位,另一个是运算时复制的
>
> 单符号位:模2补码

###标志位

* OF `有符号`运算的加减运算是否溢出 1表示溢出

最高位产生的进位与次高位产生的进位异或

* SF `有符号`加减运算结果的正负性 0表示正数

最高位的输出

* ZF 表示运算结果是否为0 ZF1为表示结果为0

全0

* CF 表示`无符号数`的加减法是否产生了进位或者借位 1发生

最高位的进位异或sub(sub=0表示加法)

## 移位运算

移位：改变数码位和小数点的相对位置，从而改变数码位的位权。

可以用算术移位来实现乘法和除法

### 算术移位

小数点前后移动，数*10^n

==原码==：符号位不变。数值位移位

右移：高位补0，低位舍弃，舍弃位为0，相当于÷2，舍弃为1，丢失精度

左移：低位补0，高位丢弃，舍弃位为0 *2 为1 严重误差

定点小数的原码同样

==反码==：

正数与原码一样

负数：补位补1

==补码==：

正数：与原码一致

负数：补位规则，最右边的1及其右侧同原码(右移 高位补1)，左边的同补码(左移 低位补0)

### 逻辑移位

逻辑右移：高位补0，低位舍弃

逻辑左移：低位补0，高位舍弃

>看作无符号数的移位
>
>应用例子：RGB，用24位来存储，先用24位大小的数组填充R，然后左移16位，然后依次得到三个数组，相加得到最后的表示

###循环移位

左移的时候移除的高位放到最低位

带进位的循环左移：进位信息CF也参与循环

> 应用：适合高字节与低字节的调换 如大端和小端的调换

## 乘除

### 原码的乘法

计算X*Y

> 运算器中ACC MQ X ALU
>
> X存 |x|的原码，也就是符号位为0其余不变
>
> MQ 存放|Y|的原码和乘积低位
>
> ACC 存乘积高位

机器字长位n+1

**原码的一位乘法**

符号位单独处理：异或

数值位绝对值相乘

乘法之前，ACC清0，第一次计算：MQ的最低位如果为1 ACC加上X，为0则加0(由ALU完成)，进行第二次的时候，ACC和MQ并起来逻辑右移，同样是MQ的最低位，一共进行n次，最后修改符号位

### 补码的乘法运算

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241022224731616.png" alt="image-20241022224731616" style="zoom:33%;" />

MQ中扩展一位，称为辅助位，初始化为0，参与右移，MQ增加一位，ACC，X都会增加一位，可以采用双符号位补码运算

会有一个辅助电路处理|-x|补码，再交给ALU

### 原码的除法

规律：忽略小数点，每确定一个商进行一次减法，得到四位余数，余数末尾补0，再确定下一位商，直到5位商(机器字长5)

==恢复余数法==：

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241023000001553.png" alt="image-20241023000001553" style="zoom:33%;" />

1. 符号位单独处理，异或
2. 数值位取绝对值进行除法运算 分别写出 |X|原 |-X|原 |Y|补 |-Y|补
3. 商MQ初始化为0 ACC存|X| X存|Y|
4. 从MQ低位开始确定一位商，默认为1，错了再改为0
5. ACC+|-Y|补 -> ACC 最高位为1，则为负数，所以商改为0，然后ACC+|Y|补 -> ACC
6. ACC和MQ逻辑左移
7. 循环n次
8. 修改符号位
9. 余数=得到的商MQ*2^-n

==加减交替法==：先不确定商位，ACC+|-Y|补 -> ACC再给出商的 然后ACC左移加上|Y|补为下一个ACC，再确定一个商

### 补码的除法

符号位参与运算，采用双符号位，被除数与除数异号则+|Y|补，同号则+|-Y|补，根据余数和除数同号则商1，左移，循环，末位商横置为1，*2^-n

## 强制类型转换

> c语言中的定点整数 short int lang 都是补码的形式存储
>
> unsigned 无符号
>
> short x=-4321 2字节 16bit **1**110 1111 0001 1111

强制转换： unsigned short y = (unsigned short)x    y = 61215  都是2字节则bit位原封不同

int 强制转化为 short 时，截断高字节

小字节转化为大字节-符号扩展 真值不变 负数在符号位和数值位间添1，正数在符号位和数值位之间添0

## 数据的存储和排列

### 大小端模式

4字节int **01** 23 45 **67** H (16进制)		1908878743 D (10进制)

01 MSB 最高有效字节

67 LSB 最低有效字节

大端:内存低地址->高地址 MSB->LSB 符合阅读习惯

小端:便于机器处理

### 边界对齐

**按字节编址**:每个字节对应一个地址 

假设一个字32位,则半字16位,一个字节8bit

**寻址方式**:可以按照字,半字,字节寻址,但是都要需要转化为字节地址 

字和半字寻址需要逻辑左移转化为字节地址

字地址->字节地址 逻辑左移2位 *4 比如2号字,也就是第3行,10,左移2位,1000,8,8号字节,2号字则是从8号字节开始连续读4字节内容

半字->字节地址,逻辑左移1位

**边界对齐**:比如一个结构体,存储3个char,3个short,1个int,发现有两个需要填充的空白

边界对齐访问更快

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241023220437207.png" alt="image-20241023220437207" style="zoom: 25%;" />

##浮点数

> 定点数表示的数据范围有限
>
> 浮点数:位数不变的情况下增加范围
>
> 用科学计数法表示  +3.026*10^11  =  +11 +3.062

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024215357212.png" alt="image-20241024215357212" style="zoom:33%;" />

N=r^E×M E是阶码,M是尾数

> 底r通常为2.方便左移右移得到真值
>
> E表示范围,M表示精度

浮点数尾数字的规格化,尾数的最高位必须是有效值,尽可能保留精度

> 左规:规格化,尾数左移,阶码-1
>
> 右规:尾数溢出(双符号位为01或10),尾数右移,阶码+1

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024220649494.png" alt="image-20241024220649494" style="zoom:33%;" />

### IEEE 754

阶码用移码的方式表示	移码:补码的基础上符号位取反,只能表示整数

移码=真值+偏置值

当n=8,偏置值=128D=1000 0000 即 2^n-1

eg:真值-127=-111 1111B   移码=-111 1111+1000 0000 = 0000 0001

IEEE 754 中偏置置是127D = 2^n-1 - 1

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024221748453.png" alt="image-20241024221748453" style="zoom:33%;" />

M23位是因为默认尾数为1.xxx

float 4字节 1+8+23 真值:(-1)^s × 1.M × 2^(E-127)  

double 8字节 1+11+52

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024222421297.png" alt="image-20241024222421297" style="zoom:33%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024222724406.png" alt="image-20241024222724406" style="zoom:33%;" />

### 浮点数的运算

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024223351366.png" alt="image-20241024223351366" style="zoom:33%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241024223749995.png" alt="image-20241024223749995" style="zoom:33%;" />

舍入:规格化尾数右移时如果舍弃了右侧的1要+1,如果+1后又溢出,又需要右规  或   如果舍弃了1需要把最后一位改为1

判溢出:阶码+1看符号位是否改变

> 32位机器long占32位,64位机器long占64位
>
> 64位机器,lang向double转化会有精度损失
>
> int -> float 会损失精度,但是范围不损失
>
> float -> int 可能损失精度,可能溢出

# 存储系统

## 基本概念

### 层次结构

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026110400727.png" alt="image-20241026110400727" style="zoom:33%;" />

>
>
>16+512 16是主存，512是辅存，使用辅存数据要先掉入主存，CPU能直接访问的是内存和Cache

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026110929964.png" alt="image-20241026110929964" style="zoom:33%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026110951010.png" alt="image-20241026110951010" style="zoom:33%;" />

### 分类

按存储介质分类

* 半导体器件，主存 Cache

* 磁表面存储器，磁盘，磁带

* 光存储器，光盘，DVD

存取方式

* 随机存取存储器 RAM，读写任何一个存储单元需要的时间都相同 内存条

* 顺序存取存储器 SAM 取决于存储单元所在维持 磁带

* 直接存取存储器 DAM 磁盘 兼具特性

* 相联存储器 CAM 按照内容检索到存储位置进行读写 “快表”

信息可更改性

* 读写存储器，磁盘，内存，Cache

* 只读存储器，ROM 实体专辑，BIOS

信息可保存性

* 易失性存储器：断电后存储信息消失，主存，Cache

* 非易失性：磁盘，光盘

* 破坏性读出：信息读出后原信息被破坏，DRAM芯片，读出后需要重写

* 非破坏性：SRAM芯片，磁盘，光盘

###性能指标

存储容量：存储字长 × 字长 (1M × 8位)

单位成本：每位价格=总成本/总容量

存储速度：数据传输速率=数据的宽度/存储周期  存储周期=存取时间+恢复时间

## 主存储器的基本组成

###半导体元件的原理

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026115637393.png" alt="image-20241026115637393" style="zoom:25%;" />

###存储芯片的原理

存储体由很多存储单元组成，存储单元由存储原组成，一个存储字是一条线连接的MOS管的字节数

MAR 译码器：n位的地址 -> 2^n个存储单元,给出哪个地址就转化对应的存储单元为高电频信号

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026121805130.png" alt="image-20241026121805130" style="zoom: 25%;" />

判断存储单元的金属引脚的数目

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026122139759.png" alt="image-20241026122139759" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026122155986.png" alt="image-20241026122155986" style="zoom:25%;" />

偏选线是选择对哪一块存储单元运算,一个内存条上多个存储单元

###如何实现不同的寻址方式

一个小格是一个字节8bit，一整行是一个存储字，一行四字节，也就是字长为4B，

如果总容量为1KB，也就是256个字，也就是256行

现代计算机按字节编址，一个字节就是一个地址，1KB，也就是有1K个地址

按字节编址，但是也可按字节寻址，按字寻址，按半字寻址，按双字寻址

1KB 地址线10根，2^10=1 K 所以10根地址线才能表示1K的地址

按字寻址：以行为单位，一共256个单位(行)，转化为字节地址，需要算术左移两位，末尾+2个0，因为一行四个字节，2^2 = 4, 

## SRAM和DRAM

### 存储元件不同导致的特性差异

DRAM用的栅极电容，如上，读取的时候是破坏性读出，读出后应该有重写操作。速度更慢，常做主存，集成度高。发热相对要小

SRAM用的双稳态触发器，非破坏性读出，不需要重写，运行速度快，用于Cache，集成度低，发热大

### DRAM的刷新

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026153237705.png" alt="image-20241026153237705" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026181527765.png" alt="image-20241026181527765" style="zoom:25%;" />

###DRAM的地址线复用技术

n位的地址用n/2条地址线代替n条，分两次传行地址和列地址，地址线减半，芯片引脚减少

SRAM同时送行列地址，不用地址复用技术，因为集成度低点

DRAM采用地址线复用技术

刷新由存储器控制不由CPU控制

## 只读存储器ROM

RAM-易失性，断电后数据消失

ROM-非易失

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026182455768.png" alt="image-20241026182455768" style="zoom: 25%;" />

BIOS芯片ROM用于引导开机，将辅存ROM中的指令调入主存RAM，然后CPU就可以执行指令了

## 内存优化技术

存取周期：可连续读写的最短时间=存取时间+恢复时间

DRAM芯片的恢复时间比较长，有可能是存取时间的好几倍

### 双端口RAM

忽略，不考

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026184825768.png" alt="image-20241026184825768" style="zoom:25%;" />

### 多模块存储器

####多体并行存储器

高位交叉编址的多体存储器 体号+体内地址

低位交叉编址的多体存储器 体内地址+体号

先根据体号选择不同的存储体，然后根据体内地址再在存储体内寻址，低位效率高于高位

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241026185415268.png" alt="image-20241026185415268" style="zoom:25%;" />

所以连续访问更快！存取周期T，存取时间r，为了使流水线不间断，应保证模块数m>=T/r ,最好=，小于会更待，大于会过剩空闲时间

####单体多字存储器

### 主存储器和cpu的连接

字扩展：扩展主存字数

位扩展：当数据总线(比如64位计算机)>存储芯片字长(一个芯片只有8*8位)

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027174939168.png" alt="image-20241027174939168" style="zoom:25%;" />

==位扩展==

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027175132613.png" alt="image-20241027175132613" style="zoom:25%;" />

这里的8K × 1位 表示8k个地址 即2^13次方，所以需要13根地址线，然后每个地址只有1位，数据线一根，这里连了两个芯片

当连续接了8个芯片之后，即8片8k*1位的存储芯片，得到一个8K\*8位的存储器，容量8KB

线选法：根据不同的数据线，n条数据线连n个芯片

==字扩展==

连接多个8K\*8位的存储芯片，然后然后根据A13-A15来控制选择不同的芯片

译码器片选法：n条线，2^n个片选信号，n=3时，可以连8个存储芯片(38译码器)，这样就得到了8K*64位的存储器



<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027180549552.png" alt="image-20241027180549552" style="zoom:25%;" />



下面右上方是74LS138译码器，三个使能端，三个输入端，8个初始端，头上带横线是低电平有效

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027180849150.png" alt="image-20241027180849150" style="zoom:25%;" />

## 外部存储器

###磁盘存储器

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027181508321.png" alt="image-20241027181508321" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241027183650702.png" alt="image-20241027183650702" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028215254594.png" alt="image-20241028215254594" style="zoom:25%;" />

RAID 多个独立的物理磁盘组成一个独立的逻辑盘

### 固态硬盘SSD

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028215551601.png" alt="image-20241028215551601" style="zoom:33%;" />

## Cache

Cache被集成到CPU内部，用SRAM实现

> 设tc为访问一次Cache需要的时间，tm为访问一次主存需要的时间
>
> 命中率H：CPU欲访问的信息已经在cache中的比率
>
> 缺失率：M=1-H
>
> 系统的平均访问时间t=Htc+(1-H)(tc+tm)
>
> 或t=Htc+(1-H)tm 同时访问cache和内存，若cache命中则停止访问主存

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028220545280.png" alt="image-20241028220545280" style="zoom:25%;" />

将cpu目前访问地址的周围的数据放到cache中，如何定义周围？

将主存的存储空间分块/页，主存与Cache之间以块为单位进行数据交换，比如1kb一块，主存4M，分为4096块，每一块进行编号

Cache中的块也称为行

### Cache与主存的映射

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028221018419.png" alt="image-20241028221018419" style="zoom:25%;" />

a：最慢，命中率高，空间利用充分

b：最快，命中率低，空间利用不充分

c：折中

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028225625187.png" alt="image-20241028225625187" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028225749634.png" alt="image-20241028225749634" style="zoom:25%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028225912939.png" alt="image-20241028225912939" style="zoom:25%;" />

### 替换算法

Cache满了之后怎么办

a：满了才需要换 b：直接替换 c：分组满了才替换

#### RAND随机算法

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028235814120.png" alt="image-20241028235814120" style="zoom:25%;" />

#### FIFO先进先出算法

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241028235916893.png" alt="image-20241028235916893" style="zoom:25%;" />

抖动现象：频繁替换，刚被替换的块很快又被调入

#### LRU近期最少使用

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029000334058.png" alt="image-20241029000334058" style="zoom:25%;" />

#### LFU最不经常使用算法

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029000520815.png" alt="image-20241029000520815" style="zoom:25%;" />

### Cache写策略

写命中

写回法：只修改Cache中的内容，当块被换出时才写回主存

全写法：同时写入Cache和主存，一般使用写缓冲(SRAM实现的FIFO队列)，可能写缓冲饱和发生阻塞

写不命中

写分配法：把主存中的块掉入Cache，再写，通常搭配写回法使用

非写分配法：只写入主存，不掉入Cache，搭配全写法

### 页式存储器

进程分为页，页大小与主存物理块大小相同，每个页面离散的放入不同的主存块

逻辑地址：虚地址 程序员看到的地址

物理地址：实地址 主存中看到的地址

逻辑地址：逻辑页号+页内地址 -> 物理地址：主存块号+块内地址

页表：逻辑页号 -> 主存块号

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029010036915.png" alt="image-20241029010036915" style="zoom:25%;" />

快表：SRAM  慢表：DRAM

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029010228650.png" alt="image-20241029010228650" style="zoom:25%;" />

### 虚拟存储器

虚拟存储系统，每次使用一个程序不会调入全部的数据而是调入部分

页式虚拟存储系统：

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029012646272.png" alt="image-20241029012646272" style="zoom:25%;" />

了解：

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241029012722279.png" alt="image-20241029012722279" style="zoom:25%;" />

# 指令系统

##指令格式

指令：操作码OP+地址码A (做什么+对谁做)

根据指令的地址码数量分

* 零地址指令  不需要操作数或者堆栈计算机(操作数隐含在栈顶和次栈顶-后缀表达式)
* 一地址指令  只需要单操作数 +1 -1 取反 取补 等 或 其中一个操作数被隐含在寄存器中
* 二地址指令  a+b
* 三地址指令 结果存到第三个地址
* 四地址指令 将下一个指令的地址指向第四个地址

指令字长：可能会变

机器字长：不变，和cpu有关，一次整数运算能处理的二进制位数

存储字长：一个存储单元中二进制代码的位数 和主存有关

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120202530858.png" alt="image-20241120202530858" style="zoom: 25%;" />

**扩展操作码指令格式**

定长指令字结构+可变操作码

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120202911048.png" alt="image-20241120202911048" style="zoom: 25%;" />

![image-20241120203357948](http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120203357948.png)

## 指令寻址

指令寻址：如何确定下一条指令的存放地址

程序计数器PC指令下一条指令的存放地址

* **顺序寻址**

1. 定长指令字结构+指令字长=存储字长=2B+主存按字编制

每次PC+1

2. 定长指令字结构+指令字长=存储字长=2B+主存按字节编制  （每个指令占两个字节）

每次PC+2

3. 变长指令字结构 + 主存字节编址

读入第一个字，根据操作码确定该指令占n字节，然后PC+n

* **跳跃寻址**

由转移指令指出

1. 定长指令字结构+指令字长=存储字长=2B+主存按字编制

每次执行指令PC+1，如果指令是转移指令JMP，PC跳到转移指令指定的位置

## 数据寻址

确定本条指令的地址码指明的真实地址

![image-20241120204802820](http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120204802820.png)

![image-20241120204823772](http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120204823772.png)

基于指令字长=机器字长=存储字长 的 一地址指令

* 直接寻址 EA=A 访存两次 取指令+执行指令
* 间接寻址 EA=(A) A是有效地址所在存储单元的地址，要在主存中寻找   访存三次取指令+执行指令2
* 寄存器寻址 EA=Ri 操作数在Ri所指的寄存器内 访存一次：取地址      速度快
* 寄存器间接寻址 EA=(Ri)   2
* 隐含寻址 另一个操作数在ACC中
* 立即寻址 A就是操作数本身 #+立即数   1

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120210348147.png" alt="image-20241120210348147" style="zoom:33%;" />

* 偏移寻址
* * <img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241120210448919.png" alt="image-20241120210448919" style="zoom:33%;" />
* 堆栈寻址 





# CPU

## 功能和结构

cpu的功能：

* 指令控制
* 操作控制
* 时间控制
* 数据加工
* 中断处理

==CPU==：

运算器  对数据加工

控制器  协调并控制计算机各部件执行程序的指令序列，包括：取指令，分析指令，执行指令

==运算器的结构==

运算器的核心：**ALU 算术逻辑单元**

通用寄存器R0 R1 R2 SP(堆栈寄存器) 其中保存的数据可能作为ALU的输入A或B，用MUX多路选择器与ALU的输入端连接，或者使用内部单总线的方式，所有寄存器的输入输出都连到一条公共的通路上

暂存寄存器：暂存从主存读过来的数据

程序状态字寄存器

移位器

计数器

==控制器的结构==

* 程序计数器PC 指出下一个指令的地址
* 指令寄存器 保存正在执行的那条指令
* 指令译码器 仅对操作码进行译码，向控制器提供特定信号
* 微操作信号发生器
* 时序系统
* 存储器地址寄存器MAR  存放要访问的主存单元的地址
* 存储器数据寄存器MDR  存放从主存读入的信息

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241121221412904.png" alt="image-20241121221412904" style="zoom:67%;" />

## 指令执行过程

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241121222334954.png" alt="image-20241121222334954" style="zoom:33%;" />

* 取址周期

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241123150816737.png" alt="image-20241123150816737" style="zoom:33%;" />

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20241123151013947.png" alt="image-20241123151013947" style="zoom:33%;" />

<img src="C:\Users\Tutu\AppData\Roaming\Typora\typora-user-images\image-20241123151110723.png" alt="image-20241123151110723" style="zoom:33%;" />



