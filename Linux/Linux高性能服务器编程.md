Linux高性能服务器编程  -游双著

作者充分理解巨作《TCP/IP协议详解》（三卷本），以及《UNIX网络编程》（两卷本）后融入自己的理解编写

主题：==如何通过各种手段编写高性能的服务器程序==

*如何提高服务器程序性能？*

比如使用“池”以牺牲空间换取效率，使用零拷贝函数以避免内核和用户空间的切换等；

其次，介绍一些高效的编程模式及其应用，比如使用**有限状态机**来分析用户数据，使用**进程池**或**线程池**来处理用户请求；最后，探讨如何通过**调整系统参数**来从服务器程序外部提高其整体性能。



为了帮助读者进一步把书中的知识融汇到实际项目中，笔者还特意编写了一个较为完整的负载均衡服务器程序springsnail。该程序能从所有逻辑服务器中选取负荷最小的一台来处理新到的客户连接。在这个程序中，使用了进程池、有限状态机、高效数据结构来提高其性能；同时，细致地封装了每个函数和模块，使之更符合实际工程项目。由于篇幅的限制，笔者未将该程序的源代码列在书中，读者可从华章网站www.hzbook.com。

#TCP/IP协议详解

## TCP/IP协议族

**TCP/IP协议族**包含众多协议，我们无法一一讨论。本书将在后续章节详细讨论**IP协议**和**TCP协议**

ICMP协议 ARP协议 DNS协议

### TCP/IP协议族体系结构以及主要协议

TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830171024950.png" alt="image-20240830171024950" style="zoom:33%;" />

####数据链路层

实现了网卡接口的网络驱动程序 以处理数据在物理媒介（比如以太网、令牌环等）上的传输 

网络驱动程序隐藏了这些细节为上层协议提供一个统一的接口

* 协议

数据链路层两个常用的协议是==**ARP**==协议（Address ResolveProtocol，地址解析协议）和==**RARP**==协议（Reverse Address ResolveProtocol，逆地址解析协议）。它们实现了**IP地址和机器物理地址**（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换

* 作用

* 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。

* RARP协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。

#### 网络层

网络层实现数据包的选路和转发

* 连接

**WAN**（Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或**LAN**（LocalArea Network，局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。

* 协议

网络层最核心的协议是==**IP协议**==（Internet Protocol，因特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（nexthop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，IP协议使用逐跳（hop by hop）的方式确定通信路径。

网络层另外一个重要的协议是==**ICMP协议**==（Internet Control MessageProtocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于检测网络连接。

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830171814478.png" alt="image-20240830171814478" style="zoom: 33%;" />

* 8位类型字段用于区分报文类型。它将ICMP报文分为两大类：一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）；另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。
* 有的ICMP报文还使用8位代码字段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。
* ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（CyclicRedundancy Check，CRC），以检验报文在传输过程中是否损坏。

**ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务）**

#### 传输层

传输层为两台主机上的应用程序提供端到端（end to end）的通信。不在乎中转过程

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830172329679.png" alt="image-20240830172329679" style="zoom:33%;" />

实线是实体通信，虚线是逻辑通信

传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等

* 协议
* ==**TCP协议**==（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。
* ==**UDP协议**==（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。
* ==**SCTP协议**==（Stream Control Transmission Protocol，流控制传输协议）是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。

#### 应用层

应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节

* 协议
* ==**ping**==是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。
* ==**telnet**==协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上
* ==**OSPF**==（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息
* ==**DNS**==（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换

应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。

### 封装

应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830180219652.png" alt="image-20240830180219652" style="zoom:33%;" />

经过TCP封装后的数据称为TCP报文段，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲区（发送缓冲区或接收缓冲区）数据一起构成了**TCP报文段**

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830180552636.png" alt="image-20240830180552636" style="zoom:33%;" />

经过UDP封装后的数据称为**UDP数据报**（UDP datagram）。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。

经过IP封装后的数据称为**IP数据报**（IP datagram）。IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。

经过数据链路层封装的数据称为**帧**（frame）。传输媒介不同，帧的类型也不同。比如，以太网上传输的是以太网帧（ethernet frame），而令牌环网络上传输的则是令牌环帧（token ring frame）

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830180822945.png" alt="image-20240830180822945" style="zoom: 50%;" />

4字节CRC字段对帧的其他部分提供循环冗余校验

帧的最大传输单元（Max Transmit Unit，**MTU**），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。正因为如此，过长的IP数据报可能需要被分片（fragment）传输

帧才是最终在物理网络上传送的字节序列

### 分用

当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用

分用是依靠头部信息中的类型字段实现的

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830181045417.png" alt="image-20240830181045417" style="zoom:33%;" />

* **分用帧** 为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们

以太网帧为例，它使用2字节的类型字段来标识上层协议。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报，以太网驱动程序就将帧交付给IP模块；若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块；若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模块

* **分用IP数据报** 因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。

* TCP报文段和UDP数据报则通过其头部中的16位的端口号（portnumber）字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议（Hyper-Text Transfer Protocol，超文本传送协议）对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。

### ARP协议工作原理

ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从**IP地址到以太网地址**（MAC地址）的转换。其工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。

#### 以太网ARP请求/应答报文详解

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830181627862.png" alt="image-20240830181627862" style="zoom: 50%;" />

* 硬件类型字段定义物理地址的类型，它的值为1表示MAC地址
* 协议类型字段表示要映射的协议地址类型，它的值为0x800，表示IP地址
* 硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为4。
* 操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。
* 最后4个字段指定通信双方的以太网地址和IP地址。发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之（当然，如前所述，操作字段需要设置为2）。

ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(ARP为数据部分)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节(512bit)。

#### ARP高速缓存的查看和修改

通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度

Linux下可以使用arp命令来查看和修改ARP高速缓存。比如在某一时刻（注意，ARP高速缓存是动态变化的）的ARP缓存内容使用**arp-a**

~~~powershell
$sudo arp-d 192.168.1.109 #删除对应的ARP缓存项
$sudo arp-s 192.168.1.109 08:00:27:53:10:67 #添加对应的ARP缓存项
~~~

#### 使用tcpdump观察ARP通信过程

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830183143933.png" alt="image-20240830183143933" style="zoom: 50%;" />

为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet命令登录Kongming20的echo服务（已经开启），并用tcpdump抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下：

~~~
$sudo arp-d 192.168.1.109#清除ARP缓存中Kongming20对应的项
$sudo tcpdump-i eth0-ent'(dst 192.168.1.109 and src 192.168.1.108)or
(dst 192.168.1.108 and src 192.168.1.109)'#如无特殊声明，抓包都在机器ernest-laptop上执行
$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令
Trying 192.168.1.109...
Connected to 192.168.1.109.
Escape character is'^]'.
^]（回车）#输入Ctrl+]并回车
telnet＞quit（回车）
Connection closed.
~~~

应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行

当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容）。tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出（数据包前面的编号是笔者加入的，后同）：

~~~
1. 00:16:d3:5c:b9:e3＞ff:ff:ff:ff:ff:ff,ethertype
ARP(0x0806),length 42:Request who-has 192.168.1.109 tell
192.168.1.108,length 28

2. 08:00:27:53:10:67＞00:16:d3:5c:b9:e3,ethertype
ARP(0x0806),length 60:Reply 192.168.1.109 is-at
08:00:27:53:10:67,length 46
~~~

由tcpdump抓取的数据包本质上是以太网帧，我们通过该命令的众多选项来控制帧的过滤（比如用dst和src指定通信的目的端IP地址和源端IP地址）和显示（比如用-e选项开启以太网帧头部信息的显示）。

第一个数据包中，ARP通信的源端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop），目的端的物理地址是ff:ff:ff:ff:ff:ff，这是以太网的广播地址，用以表示整个LAN。该LAN上的所有机器都会收到并处理这样的帧。数值0x806是以太网帧头部的类型字段的值，它表示分用的目标是ARP模块。该以太网帧的长度为42字节（实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段），其中数据部分长度为28字节。“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。

第二个数据包中，ARP通信的源端的物理地址是08:00:27:53:10:67（Kongming20），目的端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop）。“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20报告其物理地址。该以太网帧的长度为60字节（实际上是64字节），可见它使用了填充字节来满足最小帧长度。

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830184538728.png" alt="image-20240830184538728" style="zoom:50%;" />

ARP请求和应答是从以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以我们将它们用虚线表示

路由器也将接收到以太网帧1，因为该帧是一个广播帧。不过很显然，路由器并没有回应其中的ARP请求

### DNS工作原理

我们通常使用机器的域名来访问这台机器，而不直接使用其IP地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢？这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS（Network Information Service，网络信息服务）、DNS和本地静态文件等。本节主要讨论DNS。

#### DNS查询和应答报文详解

DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830184838542.png" alt="image-20240830184838542" style="zoom:50%;" />

* 16位标识字段用于标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。
* 16位标志字段用于协商具体的通信方式和反馈通信状态。

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830185013889.png" alt="image-20240830185013889" style="zoom: 50%;" />

* * QR，查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。
  * opcode，定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态。
  * AA，授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器
  * TC，截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断
  * RD，递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考。
  * RA，允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询
  * zero，这3位未用，必须都设置为0。
  * rcode，4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。
* 接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。
* <img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830190135772.png" alt="image-20240830190135772" style="zoom:50%;" />
* 查询名以一定的格式封装了要查询的主机域名。16位查询类型表示如何执行查询操作，常见的类型有如下几种
* * 类型A，值是1，表示获取目标主机的IP地址。
  * 类型CNAME，值是5，表示获得目标主机的别名
  * 类型PTR，值是12，表示反向查询
* 16位查询类通常为1，表示获取因特网地址（IP地址）
* 应答字段、授权字段和额外信息字段都使用资源记录（ResourceRecord，RR）格式

<img src="http://typora-tutu.oss-cn-chengdu.aliyuncs.com/img/image-20240830190540948.png" alt="image-20240830190540948" style="zoom:50%;" />

* * 32位域名是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。
  * 16位类型和16位类字段的含义也与DNS查询问题的对应字段相同
  * 32位生存时间表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒
  * 16位资源数据长度字段和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）。

#### Linux下访问DNS服务

我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下

nameserver 219.239.26.42  nameserver 124.207.160.106

我的机子上是nameserver 114.114.114.114  nameserver 8.8.8

分别是首选和备选

Linux下一个常用的访问DNS服务器的客户端程序是host ？？？，比如下面的命令是向首选DNS服务器219.239.26.42查询机器www.baidu.com的IP地址：

~~~powershell
$host-t A www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 119.75.217.56
www.a.shifen.com has address 119.75.218.77
~~~

host命令的输出告诉我们，机器名www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。

#### 使用tcpdump观察DNS通信过程

为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行host命令以查询主机www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下：

$sudo tcpdump-i eth0-nt-s 500 port domain

$host-t A www.baidu.com

这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示只抓取使用domain（域名）服务的数据包，即DNS查询和应答报文。tcpdump的输出如下：

~~~powe
1. IP 192.168.1.108.34319＞219.239.26.42.53 :57428+A?www.baidu.com.
(31)
2. IP 219.239.26.42.53＞192.168.1.108.34319 :57428 3/4/4 CNAME
www.a.shifen.com.,A 119.75.218.77,A 119.75.217.56(226)
~~~

tcpdump以“IP地址.端口号”的形式来描述通信的某一端  第一个是DNS查询报文第二个是应答报文

第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A?”表示使用A类型的查询方式。“www.baidu.com”则是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度（以字节为单位）。

第二个数据包中，“3/4/4”表示该报文中包含3个应答资源记录、4个授权资源记录和4个额外信息记录。“CNAME www.a.shifen.com.，A119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。该应答报文的长度为226字节。

我们抓包的时候没有开启tcpdump的-X选项（或者-x选项）。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就能明白上面31字节的查询报文和226字节的应答报文的具体含义

### socket和TCP/IP协议族的关系

前文提到，数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（Application Programming Interface，应用程序编程接口）主要有两套：socket和XTI。XTI现在基本不再使用，本书仅讨论socket。

由socket定义的这一组API提供如下两点功能：一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发送数据，或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。

值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）

##IP协议详解

IP协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之一

* IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为

* IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。

### IP服务的特点

IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。

* **无状态**（stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。接收端的IP模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。

面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。

虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。

在网络协议中，无状态是很常见的，比如UDP协议和HTTP协议都是无状态协议。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。

* **无连接**（connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。
* **不可靠**是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的

### IPv4头部结构

### IP分片

### IP路由

### IP转发

### 重定向

### IPv6头部结构

##TCP协议详解

### TCP服务的特点



##TCP/IP通信案例：访问Internet上的Web服务器

## Linux网络编程基础API

* socket地址API。socket最开始的含义是一个IP地址和端口对（ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。

* socket基础API。socket的主要API都定义在sys/socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。

* 网络信息API。Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。

###socket地址API