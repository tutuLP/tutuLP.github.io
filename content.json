{"meta":{"title":"tutulp's blog","subtitle":"","description":"tutulp的博客网站","author":"tutulp","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2025-03-03T14:24:26.345Z","updated":"2025-03-03T14:24:26.345Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-03-04T06:48:14.039Z","updated":"2025-03-04T06:48:14.039Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"tutulp 从此天边尽沉云， 风卷残阳没旧痕 邮箱：n199m992@163.comQQ：2061867903github：https://github.com/tutuLPgitee：https://gitee.com/tutuLP"},{"title":"所有标签","date":"2025-03-03T14:24:13.215Z","updated":"2025-03-03T14:24:13.215Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象","slug":"source/C++/C++ 面向对象","date":"2025-03-10T16:00:00.000Z","updated":"2025-03-11T14:51:50.472Z","comments":true,"path":"2025/03/11/source/C++/C++ 面向对象/","permalink":"http://example.com/2025/03/11/source/C++/C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"类局部类：函数内部定义类 访问控制public 任意都可访问 private 被类的成员函数访问 （只能自己） protected 当前类或者子类 (血脉连接，自己和子孙) 友元&#x3D;&#x3D;friend&#x3D;&#x3D; 可以访问类的所有成员 friend void getName(A&amp; a); 友元类friend void B::getName(A&amp; a); 友元类函数friend class B; 友元类 &#x2F;&#x2F;必须在此之前声明class B; ###struct与class的区别 默认的访问权限struct的成员默认为public，class的成员默认为private 继承时的默认访问权限 struct的继承默认是public继承，而class的继承默认是private继承。 语义上的区别struct：关注数据集合而不是行为。class：OOP 静态成员static静态函数谁都可以调用，静态成员变量谁都可以修改 静态成员变量 类里声明，类外初始化 static int count; int A::count&#x3D; 0; 类内初始化 static constexpr或const int constVar &#x3D; 42; 生命周期全局 类的静态成员的类型可以是这个类，而非静态成员只能是该类的指针或引用，因为分配内存的时候会导致无限嵌套 静态成员函数 只能访问静态数据成员和其他静态成员函数 没有this指针，只能显式传入对象的指针或引用才能访问成员变量。 类内声明和定义 或者类外不加static定义 const struct和class前+const 不会报错，但是没有意义 常量对象 123456class base&#123;&#125;const base a;base const a;//常量类对象，只能调用const函数，只能修改mutable声明的变量const int b;int const b; mutable声明的变量，表示可以被const成员对象或函数修改。 const类成员函数void getname() const {}只能调用const函数，只能修改mutable成员变量可以const重载，给不同的对象调用this指针默认为(const Base*)this，所以如果返回值为this，返回类型必须是const Base*，如果返回值为*this，返回值类型可以为Base，因为返回的是副本不影响。 有一种情况可以通过const函数修改成员变量的值：那就是const函数内部调用静态成员函数，然后静态成员函数的参数是非指向const成员的指针或者非const对象的引用，这时可以通过这个参数修改。参数是类对象不能修改，因为修改的是副本。 const成员变量，必须提供构造函数的初始化列表 const指针指向cosnt对象的指针：const Base* ptr &#x3D; &obj1; 不能通过该指针修改对象的值，指针可以指向其他对象。const指针：Base* const ptr &#x3D; &obj; 指针不能指向其他对象。指向const对象的const指针：const Base* const ptr &#x3D; &obj;既不能通过该指针修改对象的值，指针也不能再指向其他对象。 const引用const Base&amp; y&#x3D;a; 不能修改a的内容。Base&amp; const y&#x3D;a; ❌没有这种表达 this指针this指针指向调用该函数的对象a.com(b); a隐式绑定到this上*this，相当于this指针的解引用代表这个对象 1234MyClass&amp; operator=(const MyClass&amp; other) &#123; // 赋值操作... return *this; // 返回当前对象的引用 &#125; 类的作用域类允许包含指向自身的引用和指针 声明中的名字，参数名字，返回类型都必须在使用前声明 函数体会在整个类全部可见后再处理，所以会看到后续public中的成员变量，可以做函数体的返回值。 类外已经定义了一个全局变量名为name，则类里不能再定义一个同名的成员name ###聚合类 所有成员都是public 没有private，protected 没有定义构造函数 没有基类 不从其他地方继承而来 没有虚函数 不支持多态 123456struct Point &#123; int x; int y; &#125;; // 聚合类初始化 ，使用花括号初始化列表Point p = &#123;1, 2&#125;; 字面值常量类在编译时创建对象，并且其对象能用于常量表达式的类 数据成员都是字面值类型 字面值类型：整形，浮点型，枚举类型，指针(指向字面值类型或空指针)，引用类型，字面值常量类 有一个constexpr构造函数 constexpr函数的参数值和返回值必须是字面值类型，且不能抛出异常，用noexcept 如果定义了析构函数，必须是constexpr的 constexpr构造函数可以声明成&#x3D;default的形式、或者删除函数的形式。否则，constexpr构造函数必须符合构造函数的要求又符合constexpr函数的要求（拥有的唯一可执行语句就是返回语句）constexpr构造函数必须初始化所有的数据成员 123456789101112131415161718192021222324class Debug &#123;private: bool hw; bool io; bool other;public: constexpr Debug(bool b = true) :hw(b), io(b), other(b) &#123;&#125; constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) &#123;&#125; constexpr bool any() &#123; return hw || io || other; &#125; void set_io(bool b) &#123; io = b; &#125; void set_hw(bool b) &#123; hw = b; &#125; void set_other(bool b) &#123; other = b; &#125;&#125;; int main()&#123; constexpr Debug io_sub(false, true, false); //调试IO constexpr Debug prod(false); //无调试 if (io_sub.any()) //等价于if(true) cerr &lt;&lt; &quot;print appropriate error messages;&quot; &lt;&lt; endl; if(prod.any()) //等价于if(false) cerr &lt;&lt; &quot;print an error message;&quot; &lt;&lt; endl; return 0;&#125; 类函数自由函数不属于任何结构体和类，在全局任何地方都可以调用 不接受this指针std::ostream&amp; print(std::ostream&amp; os, const sals&amp; item) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;// 定义 sals 类class sals &#123;private: std::string bookNumber;public: // 构造函数 sals(const std::string&amp; number) : bookNumber(number) &#123;&#125; // 返回书籍编号 std::string isbn() const &#123; return bookNumber; &#125;&#125;;// 输出 sals 对象的内容到任何输出流std::ostream&amp; print(std::ostream&amp; os, const sals&amp; item) &#123; os &lt;&lt; &quot;Book Number: &quot; &lt;&lt; item.isbn(); return os;&#125;int main() &#123; // 创建一个 sals 对象 sals myBook(&quot;1234567890&quot;); // 输出到标准输出流 print(std::cout, myBook) &lt;&lt; std::endl; // 输出到文件流 std::ofstream outFile(&quot;book_info.txt&quot;); if (outFile.is_open()) &#123; print(outFile, myBook) &lt;&lt; std::endl; outFile.close(); std::cout &lt;&lt; &quot;Data written to file successfully.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Unable to open file.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 构造函数只要定义了构造函数就不会自动生成默认构造函数，如果需要应该显示定义成员是const或者引用，某种未提供默认构造函数的类类型，必须通过构造函数初始值列表提供初始值，而不是在函数体内赋值 默认构造函数 没有参数 如果类中没有显式定义任何构造函数，编译器会自动生成一个默认构造函数（仅当类中有需要初始化的成员时）。 显示定义构造函数 MyClass() &#x3D; default; MyClass(){}; 使用这种方式，编译器就不会再生成其他隐式的特殊成员函数（如拷贝构造函数、拷贝赋值运算符等），除非你显式地定义它们。 有一个成员变量int c;无论如何不会自动初始化为0(内置参数类型),使用默认构造函数则c会初始化为一个类似32691的值 拷贝构造函数使用原有对象的值初始化一个新的对象。 第一个参数是自身引用类型(推荐为const const MyClass&amp; other)，任何额外参数都有默认值如果不为const自身引用类型： 不能接受const和volatile 不能使用 MyClass obj2 &#x3D; MyClass (obj1);因为obj1是一个临时变量，临时变量是一个右值，不能被修改 可以存在多个拷贝构造函数 一般隐式使用 MyClass B&#x3D;A; 显式使用：MyClass B &#x3D; MyClass(A); 什么时候会使用拷贝构造函数？ 对象作为函数参数，以值传递的方式传入函数体，会使用拷贝构造函数生成副本。(建议传指针或者引用)对象作为函数返回值，以值传递的方式从函数返回使用原有对象的值初始化一个新的对象。 &#x3D;&#x3D;浅拷贝&#x3D;&#x3D;默认拷贝构造函数 ClassName(const ClassName&amp; other);定义了拷贝构造函数就不会自动生成默认的不能处理需要动态分配内存的的情况(含指针等)，使多个对象指向同一个内存静态成员变量count用于计数，计数在构造函数中实现，调用默认拷贝不会实现计数 &#x3D;&#x3D;深拷贝&#x3D;&#x3D; 123MyClass(const MyClass&amp; other) &#123; data = new int(*(other.data));&#125; 自定义实现，解决动态分配问题。 移动构造函数高效转移资源，避免不必要的深拷贝 什么时候使用？ 函数返回临时对象：将临时对象的资源转移到接收返回值的对象中。容器插入临时对象：在向容器（如 std::vector）中插入临时对象时，会调用移动构造函数来避免不必要的拷贝。MyClass obj2(std::move(obj1));MyClass obj &#x3D; MyClass(5); &#x2F;&#x2F;区别MyClass obj &#x3D; MyClass(obj1); MyClass(5)是一个右值 参数是该类对象的一个右值引用（T&amp;&amp;），用于通过移动一个已存在的对象（通常是临时对象）来初始化新创建的对象。 定义ClassName(ClassName&amp;&amp; other); 转移之后需要置空原资源，防止原对象被析构时释放了转移的资源 MyClass(MyClass&amp;&amp;) &#x3D; delete; 123456MyClass(MyClass&amp;&amp; other) noexcept : data(other.data), size(other.size) &#123; other.data = nullptr; //原对象资源置空 other.size = 0; std::cout &lt;&lt; &quot;Move constructor called&quot; &lt;&lt; std::endl;&#125;//noexcept 不会抛出异常 转换构造函数 转换构造函数允许将一个其他类型的数据转换成一个临时类对象。 只有一个参数，并且该参数不是本类的const引用时，该构造函数被视为转换构造函数。 转换构造函数可以隐式地转换其他类型的对象到本类的对象，使用explicit关键字可以禁用这种隐式转换。 可以用类对象直接与int相加 使用：Complex c2 &#x3D; 12；隐式，非explictComplex c2 &#x3D; Complex(12); 显式c1 &#x3D; Complex(9); 转换构造函数返回的是一个临时类对象c1 + 1; 隐式，非explict配合+运算符重载 12345678910111213class Complex&#123;public: double real , imag; explicit Complex(int i)&#123; std::cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; std::endl; real = i; imag = 0; &#125;&#125;;void operator+(const Complex&amp; a) &#123; this-&gt;real += a.real; this-&gt;imag += a.imag;&#125; explicit使用explicit关键字可以防止构造函数进行隐式类型转换。一个类的对象与另一个类型的值进行赋值或比较时，如果类的构造函数可以接受该类型的参数，编译器可能会尝试使用构造函数来隐式地将一个类型的值转换为类的对象。 用于转换构造函数或者单参数模板构造函数 ，explicit TemplateClass(T value) : data(value) 委托构造函数 委托构造函数允许一个构造函数调用同一个类中的另一个构造函数来执行初始化工作。 委托构造函数通过初始化列表中的’类名后跟参数列表’来调用另一个构造函数。 123 Person(const std::string&amp; name, int age) : name(name), age(age) &#123;&#125;//委托构造函数 Person(const std::string&amp; name) : Person(name, 0) &#123;&#125; 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;class MyClass &#123;private: int value; std::string name;public: // 默认构造函数 MyClass() : value(0), name(&quot;default&quot;) &#123; std::cout &lt;&lt; &quot;Default constructor called&quot; &lt;&lt; std::endl; &#125; // 拷贝构造函数 MyClass(const MyClass&amp; other) : value(other.value), name(other.name) &#123; std::cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt; std::endl; &#125; // 移动构造函数 MyClass(MyClass&amp;&amp; other) noexcept : value(other.value), name(std::move(other.name)) &#123;//更高效 other.value = 0; std::cout &lt;&lt; &quot;Move constructor called&quot; &lt;&lt; std::endl; &#125; // 转换构造函数 MyClass(int val) : value(val), name(&quot;converted&quot;) &#123; std::cout &lt;&lt; &quot;Conversion constructor called&quot; &lt;&lt; std::endl; &#125; // 委托构造函数 MyClass(int val, const std::string&amp; str) : MyClass(val) &#123;//委托转换构造函数 name = str; std::cout &lt;&lt; &quot;Delegating constructor called&quot; &lt;&lt; std::endl; &#125; // 打印对象信息的成员函数 void printInfo() const &#123; std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 使用默认构造函数 std::cout &lt;&lt; &quot;Using default constructor:&quot; &lt;&lt; std::endl; MyClass obj1; obj1.printInfo(); // 使用转换构造函数 std::cout &lt;&lt; &quot;\\nUsing conversion constructor:&quot; &lt;&lt; std::endl; MyClass obj2(42); obj2.printInfo(); // 使用委托构造函数 std::cout &lt;&lt; &quot;\\nUsing delegating constructor:&quot; &lt;&lt; std::endl; MyClass obj3(100, &quot;custom&quot;); obj3.printInfo(); // 使用拷贝构造函数 std::cout &lt;&lt; &quot;\\nUsing copy constructor:&quot; &lt;&lt; std::endl; MyClass obj4(obj3); obj4.printInfo(); // 使用移动构造函数 std::cout &lt;&lt; &quot;\\nUsing move constructor:&quot; &lt;&lt; std::endl; MyClass obj5(std::move(obj2)); obj5.printInfo(); return 0;&#125; ##内联函数 是在编译的时候将函数嵌到调用了它的地方隐式内联：类声明和定义放在一起，只是建议编译器内联显示内联：使用inline 析构函数~MyClass() {} 隐式调用：当离开当前作用域会自动调用析构函数，如果有动态内存分配的成员在函数实现中添加释放显示调用：当用new管理对象时 1234char* buffer = new char[sizeof(MyClass)];MyClass* obj = new (buffer) MyClass();obj-&gt;~MyClass();delete[] buffer; 不可重载 没有参数和返回值 private多用于设计模式中，单例等 一个类有虚函数或作为基类，析构函数应该声明为虚函数 virtual ~Base() {…} 首先调用该类的析构函数，然后按继承层次依次向上调用基类的析构函数。 纯虚析构函数**抽象类：**如果一个类的析构函数被声明为纯虚函数，该类是抽象类，不能实例化。纯虚析构函数仍然需要定义，因为对象销毁时必须调用析构函数。 1234567class AbstractBase &#123;public: virtual ~AbstractBase() = 0; // 纯虚析构函数&#125;;AbstractBase::~AbstractBase() &#123; // 纯虚析构函数的定义&#125; 禁止析构 以禁止对象被销毁。这在某些设计模式中可能会用到。~NonDestructible() &#x3D; delete; 拷贝赋值运算符已存在的对象给一已存在的对象赋值ClassName&amp; operator&#x3D;(const ClassName&amp; other);ClassName a;ClassName b; b&#x3D;a; 默认拷贝赋值运算符-参考浅拷贝 深拷贝需要自己定义 禁止对象被拷贝 删除拷贝赋值运算符 MyClass&amp; operator&#x3D;(const MyClass&amp;) &#x3D; delete; 检查自赋值-避免资源意外释放 释放已有资源 释放当前对象已经持有的资源（例如内存） 深拷贝新资源 返回当前对象的引用 123456MyClass&amp; operator=(const MyClass&amp; other) &#123; if (this == &amp;other) return *this; // 防止自我赋值 delete data; // 释放原来的内存 data = new int(*(other.data)); // 深拷贝 return *this; &#125; 移动赋值运算符实现步骤 检查自赋值 释放当前资源 转移资源 返回 *this 123456789MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; // 检查自赋值 delete[] data; // 释放当前资源 data = other.data; // 转移资源 other.data = nullptr; // 防止资源释放 &#125; return *this; &#125;obj5 = std::move(obj2); 三五法则定义其中一个需要定义其他的 三法则 析构函数 拷贝构造函数 拷贝赋值运算符比如：当成员中有动态分配的数组时，需要显示定义析构函数来释放内存。同时避免浅拷贝的问题(多个对象共享一块内存，导致多次释放)，所以需要实现深拷贝。 五法则 移动构造函数 移动赋值运算符移动构造函数和移动赋值运算符通过将临时对象的资源所有权转移到新对象，避免了不必要的深拷贝，提高了性能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;class MyClass &#123;private: int* data;public: // 默认构造函数 MyClass(int value) : data(new int(value)) &#123; std::cout &lt;&lt; &quot;默认构造函数被调用&quot; &lt;&lt; std::endl; &#125; // 拷贝构造函数 MyClass(const MyClass&amp; other) : data(new int(*(other.data))) &#123; std::cout &lt;&lt; &quot;拷贝构造函数被调用&quot; &lt;&lt; std::endl; &#125; // 拷贝赋值运算符 MyClass&amp; operator=(const MyClass&amp; other) &#123; if (this == &amp;other) return *this; // 防止自我赋值 *data = *(other.data); // 拷贝数据 std::cout &lt;&lt; &quot;拷贝赋值运算符被调用&quot; &lt;&lt; std::endl; return *this; &#125; // 移动构造函数 MyClass(MyClass&amp;&amp; other) noexcept : data(other.data) &#123; other.data = nullptr; // 将源对象的数据指针设为nullptr std::cout &lt;&lt; &quot;移动构造函数被调用&quot; &lt;&lt; std::endl; &#125; // 移动赋值运算符 MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123; if (this == &amp;other) return *this; // 防止自我赋值 delete data; // 释放当前对象的资源 data = other.data; // 接管源对象的数据指针 other.data = nullptr; // 将源对象的数据指针设为nullptr std::cout &lt;&lt; &quot;移动赋值运算符被调用&quot; &lt;&lt; std::endl; return *this; &#125; // 析构函数 ~MyClass() &#123; delete data; // 释放资源 std::cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; std::endl; &#125; // 获取值 int getValue() const &#123; return *data; &#125;&#125;;int main() &#123; MyClass obj1(42); // 默认构造函数 MyClass obj2 = obj1; // 拷贝构造函数 MyClass obj3(0); // 默认构造函数 obj3 = obj1; // 拷贝赋值运算符 MyClass obj4 = std::move(obj1); // 移动构造函数 MyClass obj5(0); // 默认构造函数 obj5 = std::move(obj2); // 移动赋值运算符 std::cout &lt;&lt; &quot;obj1的值: &quot; &lt;&lt; (obj1.getValue() ? std::to_string(obj1.getValue()) : &quot;nullptr&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj2的值: &quot; &lt;&lt; (obj2.getValue() ? std::to_string(obj2.getValue()) : &quot;nullptr&quot;) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj3的值: &quot; &lt;&lt; obj3.getValue() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj4的值: &quot; &lt;&lt; obj4.getValue() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj5的值: &quot; &lt;&lt; obj5.getValue() &lt;&lt; std::endl; return 0;&#125; 操作重载 de1+de2 或 operator+(de1+de2) de1+&#x3D;de2 或 de1.operator+&#x3D;(de2) this绑定到de1 de2作为实参 #面向对象程序设计 OOP： 封装 继承 多态 继承class Dog : public Animal继承会继承私有成员，占用内存，但是不能访问 &#x3D;&#x3D;继承类型&#x3D;&#x3D; 默认为private 公有继承（public）：不能访问基类的private，其他类型不变 保护继承（protected）：public，protected -&gt; protected 私有继承（private）：public，protected -&gt; private 继承来的成员变量 可以使用using改变可访问性 public: using A::num; 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数。c++ 11中使用using Base::Base;可以继承构造函数 析构函数。 赋值运算符重载函数 友元关系。 多继承一个子类有多个父类 class C: public A, public B &#x3D;&#x3D;菱形继承&#x3D;&#x3D;A B有一个共同的祖宗O，这时A B都有O的元素，C不知道继承A和B哪一个的元素 1234567891011121314class Base &#123;public:int data;&#125;;// 中间基类 Aclass DerivedA : public Base &#123;&#125;;// 中间基类 Bclass DerivedB : public Base &#123;&#125;;// 最终派生类class FinalDerived : public DerivedA, public DerivedB &#123;&#125;;// obj.data = 10; 二义性报错obj.DerivedA::data = 10; //需要指定路径//虚继承解决class A : virtual public Base &#123;&#125;;class B : virtual public Base &#123;&#125;;obj.data = 10; 赋值子类的构造函数用初始化列表的方式时不能直接给继承来的变量赋值，必须要在列表中调用父类的构造函数，否则就在函数体内赋值。 1234Fu(int value) : baseValue(value) &#123;&#125;Zi() : Fu(2), derivedValue(2) &#123;&#125;//或者Zi() : derivedValue(2) &#123;baseValue=2;&#125; 子类对象给父类对象赋值 1234Zi a;Fu b;b=a; //会将继承来的变量的值赋值给父类对象//a=b;不可以 父类引用子类对象或者父类指针指向子类对象，只能访问子类能访问的父类对象 123Zi a;Fu&amp; b = a;Fu* p = &amp;a; &#x3D;&#x3D;同名&#x3D;&#x3D; 如果子类有一个和父类同名的成员，子类对象默认访问子类成员，访问父类成员要加fu:: 如果子类有一个和父类同名的函数，访问也是先访问子类的函数，如果子类的函数参数与父类不一样，调用函数也不会自动去匹配参数 &#x3D;&#x3D;构造函数&#x3D;&#x3D; 会先调用父类的构造函数，然后调用子类的构造函数子类隐式调用父类的默认构造函数，或显示调用构造函数 1234567891011121314151617class human &#123;protected: std::string _name;public: human(std::string name = &quot;小明&quot;) : _name(name) &#123;std::cout &lt;&lt; &quot;调用 human 构造函数，姓名: &quot; &lt;&lt; _name &lt;&lt; std::endl;&#125;&#125;;class student : public human &#123;private: int _age;public: student(std::string name, int age) : _age(age)&#123;std::cout &lt;&lt; &quot;调用 student 构造函数，姓名: &quot; &lt;&lt; _name &lt;&lt; &quot;, 年龄: &quot; &lt;&lt; _age &lt;&lt; std::endl;&#125;&#125;;int main() &#123; student st(&quot;小红&quot;, 18); return 0;&#125;//human的构造函数带有默认参数，它可以当作默认构造函数来使用，隐式调用 小明 18 这时如果还有一个默认构造函数human()&#123;_name=&quot;小黄&quot;;&#125;，那么编译会有歧义，因为不知道隐式调用哪一个函数student(std::string name, int age) : _age(age),human(name)//显示调用父类构造函数 小红 18 &#x3D;&#x3D;析构函数&#x3D;&#x3D; 先调用子类的析构再父类的析构，禁止子类中调用父类的析构-造成空间释放两次。 子类拷贝构造函数调用父类的拷贝构造函数时，直接传入子类的对象，父对象会拿到他有的哪部分，剩下的在子类拷贝构造函数中完成 123456student(student&amp; s) :human(s)//直接将子类传过来通过切片拿到父类中的值 ,_age(s._age)//拿除了父类之外的值 &#123; cout &lt;&lt; s._age &lt;&lt; endl&lt;&lt;s._name&lt;&lt;endl; &#125; 显示调用父类的拷贝赋值运算符 123456789student&amp; operator=(const student&amp; s)&#123; if (this != &amp;s)&#123; cout &lt;&lt; &quot;调用了子类&quot; &lt;&lt; endl; human::operator=(s);//必须调用父类运算符 _age = s._age; _name = s._name; &#125; return *this; &#125; 多态编译时多态：静态绑定，编译时就确定了要调用的函数或方法，比如重载(函数重载，运算符重载)，模板。运行时多态：动态绑定，在运行时确定调用哪个函数 ，实现：通过对象的虚函数表指针找到并调用正确的函数 虚函数：在基类中使用关键字virtual声明的函数。虚函数表：每个有虚函数的类都有一个虚函数表。虚函数表是一个指针数组，其中每个指针指向类的虚函数。存放在全局数据空间。就算是继承父类的虚函数也有自己的虚函数表，如果没有重写，那么虚函数表中的指针还是指向父类的虚函数。虚函数表指针：指向虚函数表(开头位置)。大小：32位系统(4字节)，64位系统(8字节)调用顺序：判断函数是否为虚函数，如果是则通过虚函数表指针找到虚函数表，再在虚函数表中找到该虚函数调用。 如果派生类还有一个int类型的变量，64位系统中，虚函数表指针为8 节，int为4字节，考虑内存对齐后，对象大小通常为16字节（按8字节对齐），32位系统中为8字节(四字节对齐)。 多继承：如果一个派生类继承了两个类，两个类都有虚函数，这个派生类就有两个虚函数表指针，如果这个派生类再次声明自己新的虚函数，那么会放到第一个虚函数表的末尾。 vitual overridevitual 声明虚函数，当基类的指针或者引用指向派生类，调用虚函数时，子类如果对虚函数重写，调用的是子类重写的虚函数，没有重写调用的就是父类的虚函数，如果没有声明为虚函数，则调用的都是父类的函数。override 显示声明重写了虚函数，void reload() override{}; 有override的函数编译时会检查重写是否正确。 重写虚函数传入参数和返回类型不能改变-如果类型不同会造成重定义例外： 协变 ，父类的虚函数返回类型是自身的指针或引用，子类的虚函数返回类型可以改为子类的指针或引用 重写析构函数 123Base* ptr = new Derived();delete ptr;//如果Base的析构函数没有声明为虚函数将不会调用Derived的析构函数，造成无法释放的内存泄露。如果声明为虚函数，则先调用子类的析构函数，再调用基类的虚构函数。 注意区别重载，重载是同一个作用域内函数名相同，所以子类中可以有与继承的虚函数相同函数名的函数，但是一个是重写，一个重载，当没有重写虚函数时，子类对象调用该函数名函数不会做动态匹配，如果要使用父类的同名函数需要加作用域:: 建议析构函数都声明为虚函数，避免内存泄漏构造函数不能声明为虚函数 finalc++11，用于类名后或者虚函数后防止被继承。class student final{};virtual void abc() override final{}; 一般是某个子类对继承的虚函数进行重写之后，它的子类不会用到这个虚函数了就,子类也不能出现和这个虚函数相同名字，参数，返回值的函数。 抽象基类含纯虚函数 virtual void draw()&#x3D; 0; 子类必须提供实现不能创建抽象基类对象 1234567891011// 这里常考一道笔试题：sizeof(Base)是多少？class Base&#123;public: virtual void Func1()&#123; cout &lt;&lt; &quot;Func1()&quot; &lt;&lt; endl; &#125;private: int _b = 1;&#125;;//虚函数表指针(32位系统4字节，64位系统8字节)+int成员4字节,考虑内存对齐，8/32//类的成员函数不占空间，存放在程序的代码段 union联合union成员共享一个内存空间，给其中一个成员赋值，另一个已经赋值的成员就没有值了。只给unino分配最大的成员所需的空间 123456789101112131415161718192021222324252627282930union MyUnion &#123; int i; float f; char str[20]; &#125;;MyUnion u;u.i=10;//匿名联合union &#123; int intValue; char charValue;&#125;;// 直接访问成员intValue = 10;//构造与析构union MyUnion &#123; int intValue; std::string stringValue; // 手动定义构造函数 MyUnion() &#123; new (&amp;intValue) int(0); &#125; // 手动定义析构函数 ~MyUnion() &#123; // 由于 string 有非平凡析构函数，需要手动调用 stringValue.~basic_string(); &#125;&#125;; 标准库中的 std::variant：C++17 引入了 std::variant，它提供了一种类型安全的方式来存储一个值，这个值可以是几种类型中的任何一种。std::variant 是 union 的一个更现代、更安全的替代品。 variantc++ 17中对union更现代，安全的替代品 123456789#include &lt;variant&gt;// 定义一个 variant 类型，它可以存储 int、double 或 std::string 类型的值std::variant&lt;int, double, std::string&gt; myVariant;// 存储一个 int 值myVariant = 42;// 使用 std::get_if 检查当前存储的是否为 int 类型, 是则返回其值的指针if (const int* intPtr = std::get_if&lt;int&gt;(&amp;myVariant)) &#123; td::cout &lt;&lt; &quot;The stored value is an int: &quot; &lt;&lt; *intPtr &lt;&lt; std::endl;&#125; 类型匹配 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;variant&gt;#include &lt;string&gt;#include &lt;vector&gt;// 定义一个访问器结构体，使用重载的 () 运算符处理不同类型struct VariantVisitor &#123; void operator()(int value) const &#123; std::cout &lt;&lt; &quot;Received an int: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void operator()(double value) const &#123; std::cout &lt;&lt; &quot;Received a double: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; void operator()(const std::string&amp; value) const &#123; std::cout &lt;&lt; &quot;Received a string: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;int main() &#123; std::vector&lt;std::variant&lt;int, double, std::string&gt;&gt; variants = &#123;42, 3.14, &quot;Hello&quot;&#125;; for (const auto&amp; var : variants) &#123; // 使用 std::visit 调用访问器来处理 variant 中的值 std::visit(VariantVisitor&#123;&#125;, var); &#125; return 0;&#125; 异常处理 1234567std::variant&lt;int, std::string&gt; myVariant = 42;try &#123; // 尝试获取一个 std::string 类型的值，由于当前存储的是 int，会抛出异常 std::string str = std::get&lt;std::string&gt;(myVariant);&#125; catch (const std::bad_variant_access&amp; e) &#123; std::cout &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"c++ STL","slug":"source/C++/STL","date":"2025-03-10T16:00:00.000Z","updated":"2025-03-11T14:51:50.472Z","comments":true,"path":"2025/03/11/source/C++/STL/","permalink":"http://example.com/2025/03/11/source/C++/STL/","excerpt":"","text":"C++标准库 &#x2F; STL 标准模板库 容器#include ##顺序容器 容器类型 描述 访问支持 增删 vector向量 动态扩容的数组 连续存储-随机访问 尾部快 deque双端队列 指针数组-每个元素指向一块连续数组 随机 两端快 list双向链表 双向顺序 any 不常用： forward_list 单向链表 array就是普通数组 string 与vector相似 存字符串 使用 初始化 12345678910111213//默认构造vector&lt;int&gt; vec; //空vector&lt;int&gt; vec(10); //10个值为0的int 默认构造vector&lt;int&gt; vec(10, 42); //10个值为42的int 42作为参数的构造函数//范围初始化vector&lt;int&gt; vec(arr.begin(), arr.end()); // 使用arr的范围初始化vec //拷贝初始化-容器类型和元素类型一致vector&lt;int&gt; copy(original);vector&lt;int&gt; copy2 = original;//移动构造vector&lt;int&gt; moved(move(original)); //original的资源交给moved c++11 original为空且未定义状态//列表初始化 c++11vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;; 123array&lt;int,5&gt; ia; 赋随机数?array&lt;int,5&gt; ia&#123;1,2,3,41,1&#125;; &#123;0&#125; 全为0 &#123;2&#125;第一个是2其余为0int ia(5); 不能拷贝或赋值 容器操作 size empty max_size 可包含的最大大小 reserve vector和string 请求容器保留足够的空间来存储指定数量的元素，但不改变容器的大小 shrink_to_fit c++11 vector和string 尝试减少容器的容量以匹配其大小 元素访问 [] 下标 除了list at() 返回指定位置的元素引用 front 第一个元素 back 最后一个 data 第一个元素的指针 除了list 修改器 push_back() &#x2F; emplace_back()：在容器末尾添加一个元素&#x2F;构造一个元素。 pop_back()：移除容器末尾的元素。 insert(itrator,value) &#x2F; emplace()：在指定位置插入一个元素&#x2F;构造一个元素。 指定位置用迭代器实现 erase()：移除指定位置的元素或元素范围。 clear resize()：改变容器的大小，如果新大小大于当前大小，则添加默认构造的元素；如果小于当前大小，则删除多余的元素。 vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 插入元素到 vectorvoid insertElements(std::vector&lt;int&gt;&amp; vec, const std::initializer_list&lt;int&gt;&amp; elements) &#123; for (int element : elements) &#123; vec.push_back(element); &#125;&#125;// 遍历 vectorvoid traverseVector(const std::vector&lt;int&gt;&amp; vec) &#123; for (int element : vec) &#123; std::cout &lt;&lt; element &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;int main() &#123; std::vector&lt;int&gt; myVector; // 插入元素 insertElements(myVector, &#123;5, 2, 8, 1, 9&#125;); std::cout &lt;&lt; &quot;插入元素后的 vector: &quot;; traverseVector(myVector); // 排序 std::sort(myVector.begin(), myVector.end()); //反向排序 std::sort(myVector.begin(), myVector.end(), std::greater&lt;int&gt;()); std::cout &lt;&lt; &quot;排序后的 vector: &quot;; traverseVector(myVector); // 查找元素 int target = 8; if (std::find(myVector.begin(), myVector.end(), target) != myVector.end()) &#123; std::cout &lt;&lt; target &lt;&lt; &quot; 存在于 vector 中。&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; target &lt;&lt; &quot; 不存在于 vector 中。&quot; &lt;&lt; std::endl; &#125; // 删除元素 auto newEnd = std::remove(myVector.begin(), myVector.end(), target); myVector.erase(newEnd, myVector.end()); std::cout &lt;&lt; &quot;删除 &quot; &lt;&lt; target &lt;&lt; &quot; 后的 vector: &quot;; traverseVector(myVector); return 0;&#125; ###string string::size_type类型 size函数的返回类型，能存任何string的大小，无符号 比较： “hello”&lt;”hello world” “hi”&gt;”he” i的ascll码在后面 string+字符字面值+字符串字面值(不是string) 必须保证+两侧的对象至少一个是string string s2&#x3D;s1+”,”+”world”; 正确 s1放最后不对 ##关联容器 按关键字有序 map(键值对) set multimap multiset multi-可重复出现键 红黑树，元素按键自动排序 无序 unordered_map unordered_set unordered_multimap unordered_multiset 哈希表 都是双向迭代器(可以向前或向后遍历) 不支持随机访问(不能使用下标)除了map 使用1234567891011121314//默认初始化map&lt;int, string&gt; myMap;set&lt;int&gt; mySet;//拷贝初始化map&lt;int, string&gt; myMap2(myMap1); set&lt;int&gt; mySet2(mySet1);//迭代器范围初始化set&lt;int&gt; mySet(myVector.begin(), myVector.end()); // 对于map，需要确保范围中的元素是pair或可以隐式转换为pair的类型 vector&lt;pair&lt;int, string&gt;&gt; myVectorPairs = &#123; &#123;1, &quot;One&quot;&#125;, &#123;2, &quot;Two&quot;&#125; &#125;; map&lt;int, string&gt; myMap(myVectorPairs.begin(), myVectorPairs.end());//列表初始化 c++11map&lt;int, string&gt; myMap = &#123; &#123;1, &quot;One&quot;&#125;, &#123;2, &quot;Two&quot;&#125; &#125;;set&lt;int&gt; mySet = &#123;1, 2, 3, 4, 5&#125;; 插入 insert emplace 底层插入 map可以用下标 map[“123”] 没有”123”会自动创建一个 map插入时 .int( make_pair(“123”, 1) ) 或pair 删除 erase 根据迭代器(单个或范围)或者关键字 clear 删除所有 查找 find 返回迭代器指向第一个关键字匹配 否则返回尾后迭代器 count 返回与关键字匹配的个数 lower_bound和upper_bound （仅适用于有序关联容器） 返回指向第一个关键字不小于和大于给定关键字的元素的迭代器 equal_range （仅适用于有序关联容器） 返回一个pair，包含两个迭代器，分别表示关键字等于给定关键字的元素范围的开始和结束。 大小 size empty 有序关联容器（如set和map）允许通过传递自定义的比较函数或函数对象来定义元素之间的比较方式。 1234567891011121314151617181920#include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; // 自定义比较器类 struct CompareLength &#123; bool operator()(const std::string&amp; a, const std::string&amp; b) const &#123; return a.length() &lt; b.length(); // 根据字符串长度进行比较 &#125; &#125;; int main() &#123; // 使用自定义比较器类 std::map&lt;std::string, int, CompareLength&gt; myMap; myMap[&quot;apple&quot;] = 1; myMap[&quot;banana&quot;] = 2; myMap[&quot;cherry&quot;] = 3; for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; return 0; &#125; 无序关联容器（如unordered_set和unordered_map）允许通过传递自定义的哈希函数和比较函数来定义元素的存储和比较方式。 unordered_map12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;int main() &#123; // 创建一个无序映射，键是字符串，值是整数 std::unordered_map&lt;std::string, int&gt; myMap; // 插入元素 myMap[&quot;apple&quot;] = 5; myMap[&quot;banana&quot;] = 2; myMap[&quot;orange&quot;] = 8; // 访问元素 std::cout &lt;&lt; &quot;apple: &quot; &lt;&lt; myMap[&quot;apple&quot;] &lt;&lt; std::endl; // 修改元素 myMap[&quot;apple&quot;] = 10; // 遍历元素 for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; // 查找元素 if (myMap.find(&quot;banana&quot;) != myMap.end()) &#123; std::cout &lt;&lt; &quot;Found banana&quot; &lt;&lt; std::endl; &#125; // 删除元素 myMap.erase(&quot;orange&quot;); // 获取元素数量 std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; myMap.size() &lt;&lt; std::endl; return 0;&#125; 容器适配器stack 后进先出 queue 先进先出 priority_queue 优先队列 ###stack stack a 初始化 push() 添加元素 pop() 移除元素，不返回值 top() 返回顶部元素引用，不移除 empty() 是否为空 size() 元素个数-性能较低 swap(stack&amp; other) 交换两个stack的元素 queue 没有top front() 返回最先进入的元素引用 back() 最后进入的 priority_queue 构造 带比较函数 默认为less 创建一个最大堆-元素大的优先级高 :greater&gt;最小堆 最小堆 必须显示指出底层类型为vector priority_queue&lt;int, vector,greater&gt; ll; emplace() 底层容器上创建新元素，避免额外复制和移动 自定义比较函数 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;functional&gt; // 对于 std::less 和 std::greater，虽然在这个例子中我们将自定义比较 class MyClass &#123; public: int a; MyClass(int val) : a(val) &#123;&#125; &#125;; // 自定义比较函数对象，用于比较 MyClass 对象的 a 成员 struct CompareMyClass &#123; bool operator()(const MyClass&amp; lhs, const MyClass&amp; rhs) const &#123; // 如果你想要最小堆，就返回 lhs.a &gt; rhs.a return lhs.a &gt; rhs.a; &#125; &#125;; int main() &#123; std::priority_queue&lt;MyClass, std::vector&lt;MyClass&gt;, CompareMyClass&gt; minHeap; // 添加元素 minHeap.push(MyClass(3)); minHeap.push(MyClass(1)); minHeap.push(MyClass(4)); minHeap.push(MyClass(1)); minHeap.push(MyClass(5)); // 访问并移除优先级最高的元素（在最小堆中是基于 a 成员的最小值） while (!minHeap.empty()) &#123; MyClass topElement = minHeap.top(); std::cout &lt;&lt; &quot;Top element (min a): &quot; &lt;&lt; topElement.a &lt;&lt; std::endl; minHeap.pop(); &#125; return 0; &#125;//比较字符串priority_queue&lt;string, vector&lt;string&gt;, CompareStr&gt; pq;struct CompareStr &#123; bool operator()(const string&amp; lhs, const string&amp; rhs) const &#123; return lhs &gt; rhs; //小的优先 &#125; &#125;; #迭代器 类型：::const_iterator &#x2F;&#x2F;仅需要读::iterator &#x2F;&#x2F;修改存储在容器中的值使用容器类型为const则返回::const_iterator，const vecotr 使用： (*iter).name。 .优先级比*高iter-&gt;nameauto b&#x3D;v.begin(),e&#x3D;v.end(); &#x2F;&#x2F;如果容器为空，b，e返回同一个迭代器-尾后迭代器”尾元素的下一位” 基本操作 *iter 解引用 访问当前指向的值 ++ –移动 双向和随机可以使用– &#x3D;&#x3D; !&#x3D; &gt;&#x3D; &lt;&#x3D; &lt; &gt; 比较迭代器的位置 注意 避免迭代器失效 在对容器进行修改操作(删除元素之后的，插入扩容等)，导致元素位置改变的，指向这些元素的迭代器会失效，需要重新获取迭代器 解引用之前确保不是空迭代器 不同的容器类型有不同的迭代器类型 类型 vector deque string 随机访问迭代器 list 双向 foward_list双向 输入&#x2F;输出迭代器通常与特定的算法或适配器一起使用 cbegin cend 方便不是常量的容器也能返回const迭代器c.rbegin() c.rend() 反向迭代器，rbegin是最后一个元素的迭代器，rend是第一个元素之前的迭代器c.crbegin() c.crend() const反向迭代器 123for(auto it=v.cbegin();it!=v.cend() &amp;&amp; !it-&gt;empty();++it) cout&lt;&lt;*it&lt;&lt;endl; 算法算法 遍历 最值 排序 查找 反转 （没有：稳定婚姻 树链部分 后缀自动机 跳舞链 模拟退火 随机算法） 排序 sort 查找 find 遍历 traversal #仿函数 123456789101112131415161718192021222324252627#include &lt;iostream&gt; #include &lt;algorithm&gt; // std::sort #include &lt;vector&gt; // 定义仿函数 class CompareInt &#123; public: // 重载operator()，用于比较两个整数 bool operator()(int a, int b) const &#123; return a &lt; b; &#125; &#125;; int main() &#123; std::vector&lt;int&gt; vec = &#123;5, 3, 8, 4, 2&#125;; // 使用仿函数作为std::sort的第三个参数 std::sort(vec.begin(), vec.end(), CompareInt()); // 输出排序后的结果 for(int num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0; &#125; #动态内存 分配器 内存泄漏：忘记释放 引用非法指针：指针正在引用内存的时候被释放 new deletenew 分配内存并返回指针 int *pi&#x3D;new int; 未定义值int *pi&#x3D;new int(24); 初始化为24string *pi&#x3D;new string(10,’9’);int* arrPtr &#x3D; new int[5];int *p&#x3D;new int[5]{0,1,2,3,4};const int *p&#x3D;new const int; delete p;p&#x3D;nullptr; 防止释放之后依然指向无效地址delete []arrPtr allocator#include STL容器默认使用的内存分配器 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; // 1. 创建分配器对象，指定分配的对象类型为 int std::allocator&lt;int&gt; alloc; // 2. 分配内存，这里分配 5 个 int 类型的内存空间 int* ptr = alloc.allocate(5); // 3. 构造对象，使用 std::construct 在分配的内存上构造对象 for (int i = 0; i &lt; 5; ++i) &#123; std::construct_at(ptr + i, i * 2); &#125; // 输出分配内存上构造的对象的值 for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; ptr[i] &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // 4. 析构对象，使用 std::destroy 析构对象 for (int i = 0; i &lt; 5; ++i) &#123; std::destroy_at(ptr + i); &#125; // 5. 释放内存 alloc.deallocate(ptr, 5); return 0;&#125; 嵌入式web后端-基于linux系统的非客户端的各种应用 如自动驾驶后端 手写常用设计模式 linux系统编程 进阶 压力测试10万+ 高性能数据处理 金融量化 游戏服务器 自动驾驶 高性能中间件开发-网路模块 linux后端-银行业务 搜索 * c++ c++ 后端 c++ linux","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"c++知识点","slug":"source/C++/知识点总结","date":"2025-03-10T16:00:00.000Z","updated":"2025-03-11T14:51:50.710Z","comments":true,"path":"2025/03/11/source/C++/知识点总结/","permalink":"http://example.com/2025/03/11/source/C++/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"建议看一下源码：前缀效率更高 –i,后缀先复制一个副本尽量以const enum inline替换#define尽可能使用const 手册：比如找get函数在线手册网址https://zh.cppreference.com/ 标准库(标头)-ctrl+f搜索istream-basic_istream-找到get函数就可以了https://cplusplus.com/reference 英文版解释-这个网站可以直接搜用法cin.get就会出来 数据-存储数据类型1234567891011//unsignedbool bo;//1 byteshort sh; //至少16位 2 byte -32768到32767（有符号）或从0到65535（无符号）。int in; //4 bytelong lo;//8 bytelong long lolo=2; //16bytechar ch;//1 byte ascllfloat fl;// 4/7double do;//8/17 long double lodo;//19//头⽂件climits定义了符号常量：例如：INT_MAX 表示 int 的最⼤值，INT_MIN 表示 int 的最⼩值 char [-128,127]unsigned char [0,255]char a&#x3D;34;使用的是ascll编码，而char a &#x3D; ‘1’存储的是字符 char字符函数 isspace(c) 判空，是返回true isalpha(c) 判字母 isdigit(c) 数字 isalnum(c) 字母或数字 ispunct(c) 标点 isupper(c) 大写字母 islower(c) 小写字母 toupper(c) 产生=c的大写字符 tolower(c) 小写 补码补码:正数的补码是本身,负数是其二进制取反+1 字节:最小存储单元(8比特)。一个字节范围[-128,127] 。 11111111 -1 11111110 表示-2 10000001 表示-127 10000000 -128 00000000 0 00000001 1 01111111 127 -1 + -2 11111101 &#x3D; -3 所以隐式转化就是非负数前面+0，负数前面+1,强制转换就是把前面多余的字节直接切掉,极大可能导致数据改变位运算：&lt;&lt; 向左移动低位补0 左移一次*2&gt;&gt; 右移,高位补0&#x2F;1 除2&gt;&gt;&gt; 无符号右移,高位补1整形都可以使用位运算 比如char，但是要根据数据看是否会丢出数据，一般位数高的无符号整型不会丢失数据，比如uint64_t(unsigned long-linux 64位) 有符号和无符号无符号数和有符号数进行比较时，有符号数会被隐式转换为无符号数 1234567int change(unsigned num)&#123;return num;&#125;;int main() &#123; unsigned b = -3; std::cout &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; change(b) &lt;&lt; std::endl; return 0;&#125; unsigned b &#x3D; -3; 省略了int，本来是unsigned int b &#x3D; -3;unsigned p&#x3D;&b; 指针类型是unsigned intchange函数做了隐式转换，转换为了int变量，也可以直接显示转换 32位和64位计算机32位只有4GB内存(2^32) 一次只能处理四个字节的数据64位 一次能处理8个字节数据C:\\Program Files\\ 是 64 位软件的默认安装目录C:\\Program Files(x86)\\ 是 32 位软件的默认安装目录 对于数据方面 只有long 64是8字节 32是4字节 win下long是4字节 long long8字节 32位指针大小为4byte，而64位的指针大小为8byte sizeof() string的大小，64和32，和指针大小相同，因为string不保存字符串本身只存了开头的指针 long long* a&#x3D;&amp;num sizeof(long long*)是8 而sizeof(a)也是8，都是指针大小 大端序和小端序一个32位的整数0x12345678在大端序内存中的表示就是12 34 56 78 在小端序内存中的表示就是78 56 34 12。大端序：网络字节序，人类阅读习惯序列。高字节存在低地址。小端序：机器存储序。高字节高地址。 win下vs测试是小端序 打印出数据的二进制数 123456789101112131415161718192021222324252627#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;bitset&gt; // C++11及以后版本可用 // 使用bitset（C++11及以后） void printBinaryUsingBitset(int num) &#123; std::bitset&lt;32&gt; binary(num); // 假设int是32位的，根据实际情况调整 std::cout &lt;&lt; binary &lt;&lt; std::endl;&#125;// 手动实现 void printBinaryManually(int num) &#123; std::string binaryStr = &quot;&quot;; for (int i = 31; i &gt;= 0; --i) &#123; // 假设int是32位的 往右移31个就是左边数第一个bit的值 binaryStr += (num &gt;&gt; i) &amp; 1 ? &#x27;1&#x27; : &#x27;0&#x27;; &#125; std::cout &lt;&lt; binaryStr &lt;&lt; std::endl;&#125;int main() &#123; int num = -2; // 示例数字 // 使用bitset std::cout &lt;&lt; &quot;Using bitset: &quot;; printBinaryUsingBitset(num); // 手动实现 std::cout &lt;&lt; &quot;Manually: &quot;; printBinaryManually(num); return 0;&#125; vs打断点-调试-窗口-内存-内存1 将指针的地址值复制到窗口回车查找，默认是以16进制存储-16进制表示一个字节就是两位数 这里表示的是-2 前面四个fe ff ff ff就是其内存表示fe ff ff ff由于小端序 0xfffffffe的最低有效字节fe放到内存的地位12345678的16进制是0x00bc614e但是由于小端序所以内存是 4e 61 bc 00声明成long long则是8字节 4e 61 bc 00 00 00 00 00 char b[5] &#x3D; {‘a’,’b’,’\\0’}; char* a &#x3D; b; char每个占一个字节通过a看b的地址61 62 00 00 0061 62 是16进制对应的ascll编码 编码char a[] &#x3D; u8”你”; 使用utf-8则内存 e4 bd a0 00 cout输出乱码char a[] &#x3D; “你”; c4 e3 00 cout输出正常看看VS的编码设置-可以直接搜高级保存选项或者看攻略https://blog.csdn.net/qq_41868108/article/details/105750175我现在的编码是 简体中文(GB2312)-代码页936改成Unicode(UTF-8 带签名)-代码页 65001 但是不知道为啥我改完没有区别 输出ascll-charcout&lt;&lt;int(‘a’); cout&lt;&lt;int(‘4’); 输出ascll码 char转化为int是转化为ascll 输出char(‘3’)会输出3本身 如何避免转化为ascll：int(‘3’-‘0’) int-&gt;char 65-&gt;A 有效位12double num = 3.1415926; std::cout &lt;&lt; std::setprecision(4) &lt;&lt; num &lt;&lt; std::endl; // 设置输出的有效数字位数为 4 指针 &amp; * constint a;int* n&#x3D;&a; &amp;取地址赋值给指针 n是a的地址 *n(解引用)就是a*n&#x3D;c; 改变a的值n&#x3D;&amp;c 改变指向的地址int&amp; ref &#x3D; x; &amp;引用 两者地址相同，只是有个代号 左值 有持久状态，可以被引用的对象。左值可以被赋值或取地址右值 临时的、非持久的值，例如临时对象、函数返回的值（除非明确指定为返回引用）、字面量等。右值不能作为非常量引用的目标。int&amp; r &#x3D; 5; &#x2F;&#x2F; 错误，5 是右值 或者函数返回是int&amp; 不能直接返回一个非引用的int类型const int&amp; r &#x3D; 5; &#x2F;&#x2F; 正确，使用 const 引用可以接受右值 指针函数-函数指针指针函数-是函数-返回值是指针类型（地址）函数指针-是指针-指向函数所在地址的首地址-可以用来调用函数 函数指针声明方式： 比如有一个函数int max(int a, int b) int(*f)(int, int); f&#x3D;max 或者 f&#x3D;&amp;max int(*f)(int, int)&#x3D;max; 或者 &#x3D;&amp;max 使用方式： (*f)(1, 2) f(1, 2) 作为参数值 123int calculate(int (*operation)(int, int), int a, int b) &#123; return operation(a, b);&#125; switch123456789switch(表达式) &#123; case 常量表达式1:语句1; case 常量表达式2:语句2; case 常量表达式3:语句3; // … … case 常量表达式n:语句n; default:语句n+1； &#125; 循环输入get cin getline读取数据只读能读的多余的会继续存在缓冲区 operator&gt;&gt; 有格式输入-遇到空白符截至(跳过空白符)-会滞留换行符\\n，可以使用get读取这个滞留的换行符 get 无格式输入-不会跳过空白字符(空白，回车等)，读取一个字符之后，保留换行符在输入队列&#x3D;cin.get() 读取一个字符，返回int类型的ascll码值，如果用char接收会隐式转换为对应字符cin.get(a) 将读取的字符直接存储到char a 所以int类型只能使用&#x3D;cin.get()存ascll编码，而char类型都可以使用读取失败设置failbit(输入出错)和eofbit(到达末尾)，cin.fail() cin.eof() 为真 getline 读入一行数据，会丢弃换行符std::getline(std::cin, line); &#x2F;&#x2F;std::cin可以替换为文件流std::getline(std::cin, line, ‘,’); &#x2F;&#x2F; 使用逗号作为分隔符读取int name[20]; cin.getline(name,20); &#x2F;&#x2F;读取一行到数组指针，遇到换行符或者读入19个字符后停止，最后一个为\\0 operator&lt;&lt; 有格式 put cout.put(ch); 输出字符(如果是ascll编码会转化为字符) 无格式 终止 !cin.fail() !cin.eof() ch!&#x3D;EOF 都可以 ctrl+z终止 失效位 get读取到空行&#x2F;getline遇到输入字符比分配空间长会设置失效位，接下来的输入将会阻断，可以用cin.clear();恢复失效位 循环读入字符建议使用 123456789101112131415//能读取空白字符版本int ch;//或chch=cin.get(); //不用cin cin只能读整数，并且用get避免一次读取多个while(!cin.fail())&#123; cout.put(ch);//换成cout 输出ascll码 ch=cin.get();&#125;//不读取空白字符版本char ch;cin&gt;&gt;ch;while(!cin.eof())&#123; cout&lt;&lt;ch;//或cin.put(ch); cin&gt;&gt;ch;&#125;//终止条件可以写成ch!=EOF 用int因为int能正确处理EOF‘-1’ 循环读入字符串 isspace(ch) 检查输入的字符是否位空 input.empty() 检查string是否为空 input.clear(); 清除输入流的错误标志 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; cout &lt;&lt; &quot;请输入字符串（遇到空白字符时会循环一次读入）：\\n&quot;; while (cin &gt;&gt; s) &#123; // 使用流操作符自动处理空白字符 cout &lt;&lt; &quot;你输入的字符串是: &quot; &lt;&lt; s &lt;&lt; std::endl; &#125; return 0;&#125; 枚举enum定义一组命名的整数常量，用枚举类型来声明和使用。大小默认为0 1 2手动赋值后下一位比前一位大1 1234567891011121314151617181920enum Color &#123; RED = 10, GREEN, // 未指定值，默认比前一个大 1，即 11 BLUE = 20&#125;;int main()&#123; Color myColor=GREEN;&#125;//C++11引入了强类型枚举（enum class），它提供了更强的类型安全和作用域管理enum class Color&#123; RED, //0 GREEN, //1 BLUE //2&#125;;int main()&#123; Color myColor = Color::GREEN;&#125;//强类型枚举不会自动转换为整数// 使用强类型枚举时，需要显示转换为整数cout &lt;&lt; &quot;Green value: &quot; &lt;&lt; static_cast&lt;int&gt;(Color::GREEN); 宏在编译前进行代码替换或生成 可以用于定义常量、函数样式的代码片段，或进行条件编译 定义常量值 #define PI 3.14159 像使用变量一样使用PI 宏函数 #define SQUARE(x) ((x) * (x)) cout&lt;&lt;”5的平方是：”&lt;&lt;SQUARE(5)&lt;&lt;endl; 应用： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#define CC_SYNTHESIZE(varType, varName, funName)\\protected: varType varName;\\public: varType get##funName() const &#123; return varName; &#125;\\public: void set##funName(varType var)&#123; varName = var; &#125;#define CC_SUM(var1, var2) \\std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; #var1 &lt;&lt; &quot; and &quot; &lt;&lt; #var2 &lt;&lt; &quot; is: &quot; &lt;&lt; var1 + var2 &lt;&lt; std::endl;#define PI 3.14159 //定义常量值class MyClass &#123; CC_SYNTHESIZE(int, num1, Num1) CC_SYNTHESIZE(int, num2, Num2)public: MyClass(int n1, int n2) &#123; setNum1(n1); setNum2(n2); &#125; void printSumAndMax() &#123; CC_SUM(getNum1(), getNum2()); &#125;&#125;;int main() &#123; MyClass obj(10, 20); obj.printSumAndMax(); return 0;&#125; ## 用于连接# 用于将参数转化为字符串常量，这里被替换成getNum1() 条件编译 #ifdef, #ifndef, #if, #elif, #else 和 #endif 123456789#include &lt;iostream&gt;#define DEBUGint main() &#123;#ifdef DEBUG std::cout &lt;&lt; &quot;Debug 模式开启&quot; &lt;&lt; std::endl;#endif std::cout &lt;&lt; &quot;程序运行中...&quot; &lt;&lt; std::endl; return 0;&#125; 宏展开与参数 #define DOUBLE(x) x + x DOUBLE(1 + 2) 实际展开为1 + 2 + 1 + 2 为了避免这种情况，应该用括号包围宏参数和结果： #define DOUBLE(x) ((x) + (x)) 宏保护 确保头文件内容只会被包含一次 1234#ifndef MY_HEADER_H#define MY_HEADER_H// 头文件内容#endif // MY_HEADER_H 内联函数与宏 由于宏没有类型安全检查，通常在现代C++中使用 inline函数代替宏函数 inline int square(int x) {return x * x;} 修饰符类型别名typedef using类型别名 定义类型别名typedef float fl; using dou &#x3D; double;typedef double wages,*n; wages&#x3D;double n&#x3D;double* NULL nullptrnullptr类型安全 类型是std::nullptr_t 代表空指针NULL 宏定义 通常定义为0，不具备安全性，被解释成整数或空指针 ##volatile 修饰变量 阻止编译器优化（比如访问优化的时候，将变量的值缓存到寄存器，使用之后会每次都从内存中读取值） 告知编译器变量值可能意外改变 用途：在一些值随时都可能会被修改的环境，确保每次都读取最新的值 访问硬件寄存器 多线程或中断服务程序中 信号处理，与const一起使用，确保程序不修改，但是程序外部可以改变 数组一维数组 int abc[3]&#x3D;{1,2,3}; 初始化元素少于总个数时，其他初始化为0初始化元素少于总个数时，其他初始化为0 long total[100]&#x3D;{0}; 全部元素为0int dfg[3];int g[]&#x3D;{2,3}; 会自动计算个数，使g[2] 二维数组 int b[2][3]{1,2,3}; &#x3D;&#x3D;c++11&#x3D;&#x3D; 可省略等号大括号内不带东西 所有元素为0 int a[4]{};初始化禁止缩窄转换 int a[]{23,2.0} 浮点转化为整型是缩窄操作新增vector 123456789std::vector&lt;std::array&lt;int, 3&gt;&gt; vec;// 初始化方式一：逐个添加元素std::array&lt;int, 3&gt; arr1 = &#123;1, 2, 3&#125;;vec.push_back(arr1);// 初始化方式二：使用花括号直接添加vec.push_back(&#123;4, 5, 6&#125;);//访问：vec[0][1]: //for(auto i : vec) 数组元素个数sizeof(nums) &#x2F; sizeof(int) &#x2F;&#x2F;sizeof返回的是字节数std::size(nums) &#x2F;&#x2F;返回行数？ 数组赋值数组名代表数组首元素的地址，是一个常量指针，不是一个可以赋值的左值。array可以用&#x3D; vector&lt;vector&gt;初始化二维数组 1234567vector&lt;vector&lt;int&gt;&gt; fac(n, vector&lt;int&gt;(m, 0));vector&lt;vector&lt;int&gt;&gt; triangle(n, vector&lt;int&gt;());for (int i = 0; i &lt; triangle.size(); i++) &#123; triangle[i].resize(i + 1); //resize改变容器大小，每行大小加1&#125; 遍历二维数组 1234567for (int i = 0; i &lt; fac.size(); i++) for (int j = 0; j &lt; fac[i].size(); j++) cin &gt;&gt; fac[i][j];for(auto nums:fac)&#123; for(auto i:nums)&#123;&#125; &#125; 字符串初始化c风格 char dog[3]&#x3D;{‘a’,’b’,’\\0’}; ‘\\0’编码为0 char a[6]&#x3D;”bull”; 字符串常量&#x2F;字符串字面值 隐式包含空字符，自动添加\\0 string #include 自动处理大小std::string name {“tutu”};std::string name &#x3D; “tutu”;std::string name &#x3D; {“tutu”}; 区别字符常量和字符串常量‘S’在ASCLL中只是83的另一种写法，char a &#x3D; ‘s’; “S”表示的是两个字符S和\\0组成的字符串，实际表示的是字符串所在的地址，char a&#x3D;”S”; ❌ 赋值 拼接string可直接使用+ &#x3D; 可以使用strcpy(char*2,char*1) strcat 1接到2后 注意2长度要够大，strncpy strncat第三个参数指出能接受的最大长度 获取长度**char ***strlen(a) 到第一个\\n string.size() .length() 原始字符串cout &lt;&lt; R”(acs\\n)”&lt;&lt;’\\n’&lt;&lt;”azx\\n”; 用R”( )” 等效 前面加cout&lt;&lt;R”+*(“(who)”,she)+*“; R”+*( )+*“ 可以使用任意数量的基本字符 strcmp strcmpint strcmp(const char *str1, const char *str2);按照ascll码顺序，挨个比较两个字符串的字符，直至第一个不同的或到末尾返回值：小于0：两个字符串第一个不同的字符的ascll码str1小于str2，或者前者是后者的子串等于0：两个字符串相同大于0 string可以直接使用符号进行比较 字符串排序sort默认是升序排序，如果要降序排序需要提供自定义函数 123456789101112131415161718192021222324252627//vetctor&lt;string&gt;类型排序//升序std::sort(words.begin(), words.end());//降序bool caseSensitiveCompare(const std::string&amp; a, const std::string&amp; b) &#123; return a &lt; b;&#125;std::sort(words.begin(), words.end()，caseSensitiveCompare);//忽略大小写bool caseInsensitiveCompare(const std::string&amp; a, const std::string&amp; b) &#123; std::string lowerA = a, lowerB = b; std::transform(lowerA.begin(), lowerA.end(), lowerA.begin(), ::tolower); std::transform(lowerB.begin(), lowerB.end(), lowerB.begin(), ::tolower); return lowerA &lt; lowerB;&#125;//string类型排序//升序std::sort(str.begin(), str.end());//降序bool compareChars(const char&amp; a, const char&amp; b) &#123; return a &lt; b;&#125;std::sort(str.begin(), str.end(),compareChars);//或者使用标准库函数std::greater&lt;char&gt;()std::sort(str.begin(), str.end(), std::greater&lt;char&gt;()); 模板与内联函数12345678910111213141516//模板类 后续在类中用T代替要使用的类型template &lt;typename T&gt; //使用：Stack&lt;int&gt; intStack;template &lt;class T&gt;;template &lt;typename T, int Size&gt; //使用：Stack&lt;int,5&gt; intStack;class Stack &#123;&#125;//模板类的特化template &lt;typename T&gt;class MyClass &#123;&#125; template &lt;&gt; //MyClass&lt;int&gt;时特殊使用class MyClass&lt;int&gt; &#123;&#125;//模板类的定义和实现默认在同一个文件，因为在编译时生成，而不是动态绑定的//模板类的函数定义默认在函数声明时实现-内联，如果在类外部实现需要带上模板参数列表template &lt;typename T&gt;void MyTemplateClass&lt;T&gt;::func() &#123;&#125; 函数模板： 12345678910template &lt;typename T&gt;void swapValues(T&amp; a, T&amp; b) &#123; T temp = a; a = b; b = temp;&#125;int num1 = 10, num2 = 20;swapValues(num1, num2); //可以根据num的类型自动匹配swapValues&lt;int&gt;(num1, num2);//或者使用&lt;&gt; 使用.hpp文件（声明和定义在一个文件） 如：内联函数，模板类模板函数，小型库 内联函数在函数声明前面加inline 在编译的时候，把函数代码插入到函数调用处-编译时确定，所以声明和实现要在一个文件 内联函数与register变量类似，仅仅是我们提给编译器的一个请求，最终是否真正会实现内联，由编译器根据情况自行选择。&#x2F;&#x2F;register声明变量之前，建议编译器将变量放入寄存器 内存alloca用于在栈上申请空间，离开作用域会自动释放 12void *alloca(size_t size);int *arr = (int *)alloca(n * sizeof(int)); 链接 静态链接：在编译期将库文件的所有代码嵌入到最终可执行文件中，体积大，快 （.a .lib） 动态链接：在程序执行过程中遇到了再链接（.so .dll），体积小，慢 I&#x2F;O类(待看)有三个关于I&#x2F;O类的头文件 IO对象不能拷贝赋值,不能是const,读写会改变状态 C++ Effective类型 constexpr int p &#x3D; 1; 常量表达式进行初始化 constexpr int *p&#x3D;nullptr; constexpr修饰顶层 const修饰底层 constexpr const *p&#x3D;&i; constexpr:一直指向i，const：指向的值不被修改 编译时期就需要能够确定其值 constexpr用于修饰函数时,一般只有一条return语句,用于构造函数中什么都不用有 #异常处理 基础 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;// 自定义异常类class MyException : public exception &#123;public: const char* what() const throw () &#123; return &quot;自定义异常发生&quot;; &#125;&#125;;// 抛出异常的函数double division(int a, int b) &#123; if (b == 0) &#123; throw &quot;除数不能为零&quot;; // 抛出字符串类型的异常 &#125; return (a / b);&#125;int main() &#123; int x = 50; int y = 1; double z = 0; try &#123; z = division(x, y); cout &lt;&lt; z &lt;&lt; endl; &#125; catch (const char* msg) &#123; cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; msg &lt;&lt; endl; &#125; catch (MyException&amp; e) &#123; // 捕获自定义异常 cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; 嵌套异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stdexcept&gt;#include &lt;exception&gt;// 自定义异常类，继承自std::exceptionclass MyException : public std::exception &#123;public: const char* what() const noexcept override &#123; return &quot;MyException发生&quot;; &#125;&#125;;// 另一个自定义异常类，用于嵌套异常class MyNestedException : public std::exception &#123;private: std::nested_exception nested;public: MyNestedException() : nested() &#123;&#125; void rethrow_nested() const &#123; if (nested) nested.rethrow_nested(); &#125; const char* what() const noexcept override &#123; return &quot;MyNestedException发生，包含嵌套异常&quot;; &#125;&#125;;// 抛出嵌套异常的函数void throwNestedException() &#123; try &#123; throw MyException(); &#125; catch (...) &#123; std::throw_with_nested(MyNestedException()); &#125;&#125;int main() &#123; try &#123; throwNestedException(); &#125; catch (const MyNestedException&amp; e) &#123; std::cout &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; try &#123; e.rethrow_nested(); &#125; catch (const MyException&amp; e) &#123; std::cout &lt;&lt; &quot;捕获到嵌套异常: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch (...) &#123; std::cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; std::endl; &#125; &#125; catch (...) &#123; std::cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 使用智能指针管理资源 RAII 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;memory&gt;class Resource &#123;public: Resource() &#123; std::cout &lt;&lt; &quot;资源被创建\\n&quot;; &#125; ~Resource() &#123; std::cout &lt;&lt; &quot;资源被销毁\\n&quot;; &#125;&#125;;void processResource() &#123; // 使用智能指针管理资源 std::unique_ptr&lt;Resource&gt; ptr(new Resource()); // 这里执行一些操作... throw std::runtime_error(&quot;在处理资源时发生异常&quot;); // 智能指针会在函数结束时自动释放资源&#125;int main() &#123; try &#123; processResource(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; // 即使发生异常，资源也会被正确释放 return 0;&#125; noexcept 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;// noexcept关键字指定函数不会抛出异常void noThrowFunction() noexcept &#123; std::cout &lt;&lt; &quot;这个函数保证不抛出异常。\\n&quot;;&#125;// 这个函数可能抛出异常void mayThrowFunction() &#123; throw std::runtime_error(&quot;发生了一个异常！&quot;);&#125;// noexcept(false)指定函数可能抛出异常void mayThrowFunctionWithNoexcept(false) noexcept(false) &#123; throw std::runtime_error(&quot;这个函数可能抛出异常！&quot;);&#125;int main() &#123; try &#123; noThrowFunction(); mayThrowFunction(); // 这里会抛出异常 &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; try &#123; mayThrowFunctionWithNoexcept(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 异常的传播和堆栈展开 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdexcept&gt;// 基础资源类class Resource &#123;public: Resource() &#123; std::cout &lt;&lt; &quot;资源被创建\\n&quot;; &#125; ~Resource() &#123; std::cout &lt;&lt; &quot;资源被销毁\\n&quot;; &#125;&#125;;// 使用资源的函数void useResource() &#123; Resource res; // 局部资源 std::cout &lt;&lt; &quot;使用资源\\n&quot;; throw std::runtime_error(&quot;发生异常，资源将被清理&quot;);&#125;// 调用使用资源的函数void callUseResource() &#123; try &#123; useResource(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;异常被捕获: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; throw; // 重新抛出异常 &#125;&#125;int main() &#123; try &#123; callUseResource(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;异常在main中被捕获: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 异常链和异常传播 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;stdexcept&gt;// 自定义异常类class CustomException : public std::runtime_error &#123;public: CustomException(const std::string&amp; msg) : std::runtime_error(msg) &#123;&#125;&#125;;// 第一层函数，可能抛出异常void functionLevel1() &#123; throw CustomException(&quot;从functionLevel1抛出的异常&quot;);&#125;// 第二层函数，调用第一层函数void functionLevel2() &#123; try &#123; functionLevel1(); &#125; catch(const CustomException&amp; e) &#123; std::cerr &lt;&lt; &quot;在functionLevel2捕获异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; throw; // 重新抛出异常 &#125;&#125;// 主函数int main() &#123; try &#123; functionLevel2(); &#125; catch(const CustomException&amp; e) &#123; std::cerr &lt;&lt; &quot;在main捕获异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 自定义异常类 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;exception&gt;// 自定义异常类class MyException : public std::exception &#123;private: std::string message;public: MyException(const std::string&amp; msg) : message(msg) &#123;&#125; const char* what() const noexcept override &#123; return message.c_str(); &#125;&#125;;// 可能抛出自定义异常的函数void riskyFunction(int value) &#123; if (value &lt; 0) &#123; throw MyException(&quot;负值错误：函数只接受非负整数&quot;); &#125; // 正常处理流程 std::cout &lt;&lt; &quot;输入值为: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123; try &#123; riskyFunction(-1); // 这将抛出自定义异常 &#125; catch (const MyException&amp; e) &#123; std::cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; catch (...) &#123; std::cerr &lt;&lt; &quot;捕获到未知异常\\n&quot;; &#125; return 0;&#125; RTTI 类型信息运行时类型信息。它允许程序在运行时确定对象的类型。RTTI 主要通过两种方式实现：typeid 运算符和 dynamic_cast 运算符。 typeid 获取表达式的类型信息，返回一个 const std::type_info&amp; 引用必须有虚函数，才能支持运行时类型识别 123Base* basePtr = new Derived();const std::type_info&amp; typeInfo = typeid(*basePtr); std::cout &lt;&lt; &quot;Type name: &quot; &lt;&lt; typeInfo.name() &lt;&lt; std::endl; dynamic_cast 用于在继承层次结构中进行安全的向下转型（将基类指针或引用转换为派生类指针或引用）。如果转换成功，返回目标类型的指针或引用；如果转换失败，对于指针类型返回 nullptr，对于引用类型抛出 std::bad_cast 异常。 123Base* basePtr = new Derived();Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);if (derivedPtr) 四大类型的转换static_cast 主要用于编译时的类型转换，即在编译时确定转换的类型。 可以用于基本数据类型之间的转换，以及非多态类型之间的转换。 还可以用于向上转换和向下转换，但不进行运行时类型检查，因此向下转换时需要注意安全性。 12int i = 10;double d = static_cast&lt;double&gt;(i); // 将整数转换为浮点数 const_cast 主要用于去除常量性（const）或增加常量性（const）。 用于修改对象的常量属性，但需要谨慎使用，可能导致未定义行为。 123const int i = 10;int* ptr = const_cast&lt;int*&gt;(&amp;i); // 去除常量性*ptr = 20; // 此时可能会导致未定义行为 dynamic_cast reinterpret_cast 主要用于低级类型转换，将一个指针转换为另一种指针类型，或将指针转换为整数类型，反之亦然。 不进行任何类型检查或调用构造函数&#x2F;析构函数，因此风险较高，应该谨慎使用。 1int* p = reinterpret_cast&lt;int*&gt;(0x12345678); // 将地址转换为指针 自动推导类型autoauto会忽略引用属性，需要手动使用auto&amp; 123456const int c=8;auto a=c; //a被推到为int，顶层const会被忽略(变量本身是常量)auto b=&amp;c; //b被推到为const int*，底层的const不会被忽略(指针指向的对象是常量)auto &amp;c=a; //auto &amp;时，顶层const不会被忽略，这里a是int，c是int &amp;auto &amp;d = 42; //错误，不能绑定到普通引用，普通引用必须绑定到一个左值const auto &amp;d = 42; //使用const引用时会临时创建一个对象绑定给d decltype类型说明符1234567891011121314//推导变量类型const int x = 10;decltype(x) y = 20; //推导函数返回值类型int func() &#123; return 42;&#125;decltype(func()) result;//推导左值表达式为引用类型int arr[5] = &#123;1, 2, 3, 4, 5&#125;;decltype(arr[0]) ref = arr[0]; // ref 的类型是 int&amp;，因为 arr[0] 是左值//推导右值为普通类型int a = 5, b = 3;decltype(a + b) sum;//a+b是右值 空间与堆栈内存对齐一个4字节(32位)系统中都按4字节边界对齐，地址是4的倍数 在这个示例中，alignas(16) 表示 MyData 结构体的对齐方式为 16 字节。使用 alignof(MyData) 可以获取 MyData 结构体的对齐要求 123456789101112#include &lt;iostream&gt;struct alignas(16) MyData &#123; int x; double y;&#125;;int main() &#123; std::cout &lt;&lt; &quot;Alignment of MyData: &quot; &lt;&lt; alignof(MyData) &lt;&lt; std::endl; return 0;&#125; new和delete原理new 和 delete 是 C++ 中用于动态内存管理的关键字，它们用于在堆（heap）上分配和释放内存。以下是它们的工作原理： new 操作符： 当程序执行 new 操作符时，首先会调用一个用于分配内存的函数（例如 operator new），该函数负责从堆中分配足够的内存来存储对象。 new 操作符接收类型的大小作为参数，并分配足够的内存以存储该类型的对象。如果内存分配失败，则会抛出 std::bad_alloc 异常。 分配的内存足够容纳对象后，构造函数被调用以初始化对象。如果对象有构造函数，则会自动调用它来完成对象的初始化。 new 操作符返回指向新分配内存的指针，该指针的类型与所分配对象的类型相匹配。 1int* p = new int; // 分配足够的内存来存储一个 int 对象，并调用 int 类的构造函数进行初始化 delete 操作符： 当程序执行 delete 操作符时，首先会调用一个用于释放内存的函数（例如 operator delete），该函数负责释放之前分配的内存。 delete 操作符接收指向动态分配内存的指针作为参数，然后释放该指针所指向的内存。这意味着它会销毁对象，并释放对象占用的内存。 在销毁对象之前，析构函数被调用以清理对象的资源。如果对象有析构函数，则会自动调用它来完成对象的清理工作。 使用 delete 操作符释放的内存将会返回给堆，以便供后续的内存分配使用。 12int* p = new int; // 分配内存delete p; // 释放内存 总的来说，new 和 delete 关键字提供了 C++ 中动态内存分配和释放的机制，可以方便地在堆上创建和销毁对象，但需要注意避免内存泄漏和悬挂指针等问题。在现代 C++ 中，推荐使用智能指针（如 std::unique_ptr、std::shared_ptr）来管理动态内存，以减少手动内存管理带来的风险。 ##delete[] delete[] 与 delete 的不同之处在于，delete 用于释放单个对象动态分配的内存，而 delete[] 用于释放动态数组动态分配的内存。 找到数组元素的个数：在 C++ 中，new[] 会在分配内存时存储数组元素的个数。因此，delete[] 首先需要找到数组元素的个数，以便正确地释放每个元素所占用的内存空间。 释放数组元素的内存空间：delete[] 将遍历数组的每个元素，并调用其析构函数（如果有的话），然后释放每个元素所占用的内存空间。这确保了动态数组中的每个元素都得到了正确的清理和释放。 释放数组的内存空间：最后，delete[] 会释放整个动态数组所占用的内存空间，即释放数组的起始地址。 12345678910111213141516#include &lt;iostream&gt;int main() &#123; // 使用 new[] 分配一个包含 5 个整数的动态数组 int* array = new int[5]; // 对数组进行赋值 for (int i = 0; i &lt; 5; ++i) &#123; array[i] = i; &#125; // 使用 delete[] 释放动态数组的内存 delete[] array; return 0;&#125; 多线程与多进程进程间通信IPC管道pipe，半双工(单方向)，只能用于父子等具有亲缘关系的进程间使用 消息队列：全双工，在不同程序的进程间都可以使用 共享内存： 同上 套接字 线程通信共享变量：全局变量或类的成员变量，结合锁或信号量 消息队列 多进程fork()，创建新线程，返回两次，父进程中返回子进程ID，子进程中返回0，失败返回-1execlp(pname,argvs…,nullptr),子进程中执行新程序，程序名，参数waitpid(pid, &amp;status, 0) 或 wait(nullptr)，等待子进程结束getpid() 返回PID 子进程与原来的进程几乎完全相同。子进程将复制父进程的内存空间、打开的文件描述符、环境变量等资源。子进程与父进程共享代码段，但在进程空间中有自己的数据段和堆栈段。 示例：子进程使用ls -l 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t pid = fork(); if (pid &lt; 0) &#123; // 错误处理：fork失败 std::cerr &lt;&lt; &quot;Fork failed!&quot; &lt;&lt; std::endl; return 1; &#125; else if (pid == 0) &#123; // 子进程 std::cout &lt;&lt; &quot;This is the child process. PID: &quot; &lt;&lt; getpid() &lt;&lt; std::endl; // 执行一个新程序，这里以ls命令为例 execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, nullptr); // 如果execlp执行失败，会执行到这里 std::cerr &lt;&lt; &quot;Exec failed!&quot; &lt;&lt; std::endl; return 1; &#125; else &#123; // 父进程 std::cout &lt;&lt; &quot;This is the parent process. PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;, Child PID: &quot; &lt;&lt; pid &lt;&lt; std::endl; // 等待子进程结束 int status; waitpid(pid, &amp;status, 0); std::cout &lt;&lt; &quot;Child process has finished.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; 管道int pipefd[2]; pipefd[0]读端，pipefd[1]写端pipe(pipefd) 创建管道，失败返回-1 123456789//一个进程-读线程close(pipefd[1]);//关闭写端ssize_t n = read(pipefd[0], buffer, BUFFER_SIZE); //阻塞读取数据，失败返回-1，写端关闭返回0close(pipefd[0]);//读取完毕，关闭读端//另一个线程-写线程close(pipefd[0]); // 关闭读端const char* message = &quot;Hello, child process!&quot;;ssize_t n = write(pipefd[1], message, strlen(message));close(pipefd[1]); 消息队列int msgget(key_t key, int msgflg); key：消息队列表示，两个进程使用同一个消息队列，消息标识相同，msgflg：创建标志和权限，IPC_CREAT | 0666表示如果指定key的消息队列不存在则创建，存在则返回消息标识符，0666代表有读写权限没有执行权限msgsnd，发送消息msgrcv 接收消息msgctl 删除消息队列 demo 发送端： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;cstring&gt;#define MSG_KEY 1234#define MAX_MSG_SIZE 1024// 消息结构体struct msgbuf &#123; long mtype; // 消息类型 char mtext[MAX_MSG_SIZE]; // 消息内容&#125;;int main() &#123; // 创建或获取消息队列 int msgid = msgget(MSG_KEY, IPC_CREAT | 0666); if (msgid == -1) &#123; std::cerr &lt;&lt; &quot;msgget failed&quot; &lt;&lt; std::endl; return 1; &#125; // 准备消息 msgbuf message; message.mtype = 1; std::strcpy(message.mtext, &quot;Hello from sender!&quot;); // 发送消息 if (msgsnd(msgid, &amp;message, strlen(message.mtext) + 1, 0) == -1) &#123; std::cerr &lt;&lt; &quot;msgsnd failed&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Message sent successfully.&quot; &lt;&lt; std::endl; return 0;&#125; 接收端 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;cstring&gt;#define MSG_KEY 1234#define MAX_MSG_SIZE 1024// 消息结构体struct msgbuf &#123; long mtype; // 消息类型 char mtext[MAX_MSG_SIZE]; // 消息内容&#125;;int main() &#123; // 创建或获取消息队列 int msgid = msgget(MSG_KEY, IPC_CREAT | 0666); if (msgid == -1) &#123; std::cerr &lt;&lt; &quot;msgget failed&quot; &lt;&lt; std::endl; return 1; &#125; // 准备接收消息的缓冲区 msgbuf message; // 接收消息 if (msgrcv(msgid, &amp;message, MAX_MSG_SIZE, 1, 0) == -1) &#123; std::cerr &lt;&lt; &quot;msgrcv failed&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Received message: &quot; &lt;&lt; message.mtext &lt;&lt; std::endl; // 删除消息队列 if (msgctl(msgid, IPC_RMID, nullptr) == -1) &#123; std::cerr &lt;&lt; &quot;msgctl failed&quot; &lt;&lt; std::endl; return 1; &#125; return 0;&#125; 共享内存int shmid &#x3D; shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666); 创建共享内存将共享内存段附加到当前进程的地址空间从共享内存读数据或写数据删除共享内存段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;cstring&gt;#define SHM_KEY 1234#define SHM_SIZE 1024int main() &#123; // 创建共享内存段 int shmid = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666); if (shmid == -1) &#123; std::cerr &lt;&lt; &quot;shmget failed&quot; &lt;&lt; std::endl; return 1; &#125; // 将共享内存段附加到当前进程的地址空间 char* shmaddr = static_cast&lt;char*&gt;(shmat(shmid, nullptr, 0)); if (shmaddr == reinterpret_cast&lt;char*&gt;(-1)) &#123; std::cerr &lt;&lt; &quot;shmat failed&quot; &lt;&lt; std::endl; return 1; &#125; // 向共享内存写入数据 const char* message = &quot;Hello, shared memory!&quot;; std::strcpy(shmaddr, message); // 将共享内存段从当前进程的地址空间分离 if (shmdt(shmaddr) == -1) &#123; std::cerr &lt;&lt; &quot;shmdt failed&quot; &lt;&lt; std::endl; return 1; &#125; std::cout &lt;&lt; &quot;Data written to shared memory.&quot; &lt;&lt; std::endl; return 0;&#125;#include &lt;iostream&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;cstring&gt;#define SHM_KEY 1234#define SHM_SIZE 1024int main() &#123; // 获取共享内存段 int shmid = shmget(SHM_KEY, SHM_SIZE, 0666); if (shmid == -1) &#123; std::cerr &lt;&lt; &quot;shmget failed&quot; &lt;&lt; std::endl; return 1; &#125; // 将共享内存段附加到当前进程的地址空间 char* shmaddr = static_cast&lt;char*&gt;(shmat(shmid, nullptr, 0)); if (shmaddr == reinterpret_cast&lt;char*&gt;(-1)) &#123; std::cerr &lt;&lt; &quot;shmat failed&quot; &lt;&lt; std::endl; return 1; &#125; // 从共享内存读取数据 std::cout &lt;&lt; &quot;Data read from shared memory: &quot; &lt;&lt; shmaddr &lt;&lt; std::endl; // 将共享内存段从当前进程的地址空间分离 if (shmdt(shmaddr) == -1) &#123; std::cerr &lt;&lt; &quot;shmdt failed&quot; &lt;&lt; std::endl; return 1; &#125; // 删除共享内存段 if (shmctl(shmid, IPC_RMID, nullptr) == -1) &#123; std::cerr &lt;&lt; &quot;shmctl failed&quot; &lt;&lt; std::endl; return 1; &#125; return 0;&#125; ##进程同步 信号量(主要)POSIX 信号量分为有名信号量和无名信号量，有名信号量可以用于不相关的进程间同步，无名信号量通常用于线程间或有亲缘关系的进程间同步 1234567sem_t* sem = sem_open(SEM_NAME, O_CREAT, 0666, 1); //SEM_NAME信号量名字，O_CREAT表示如果信号量不存在则创建它，信号量初始值为1sem_wait(sem) == -1) &#123; //等待请求信号量//进行资源操作，完成之后释放sem_post(sem) == -1 //释放信号量sem_close(sem) == -1//关闭信号量sem_unlink(SEM_NAME); //删除信号量 互斥锁pthread_mutex_t mutex;pthread_mutex_lock(&amp;mutex); &#x2F;&#x2F; 加锁pthread_mutex_unlock(&amp;mutex); &#x2F;&#x2F; 解锁 条件变量pthread_mutex_init(&amp;mutex, nullptr);pthread_cond_init(&amp;cond, nullptr); 123456789101112131415161718pthread_mutex_t mutex;pthread_cond_t cond;bool condition_met = false;//一个进程pthread_mutex_lock(&amp;mutex);condition_met = true; //条件pthread_cond_signal(&amp;cond); // 发送信号pthread_mutex_unlock(&amp;mutex);//另一个进程pthread_mutex_lock(&amp;mutex);while (!condition_met) &#123; pthread_cond_wait(&amp;cond, &amp;mutex); // 等待条件成立 //do something&#125;pthread_mutex_unlock(&amp;mutex);//清理资源pthread_mutex_destroy(&amp;mutex);pthread_cond_destroy(&amp;cond); 多线程thread-c++11#include std::thread t(threadFunction); &#x2F;&#x2F;创建线程执行函数std::thread t(threadFunction, x, y); &#x2F;&#x2F;执行函数并传递参数t.join(); &#x2F;&#x2F;等待线程结束 lambda表达式创建线程 12345int a = 2, b = 4;std::thread t([a, b]() &#123; std::cout &lt;&lt; &quot;The product of &quot; &lt;&lt; a &lt;&lt; &quot; and &quot; &lt;&lt; b &lt;&lt; &quot; is &quot; &lt;&lt; a * b &lt;&lt; std::endl;&#125;);t.join(); 使用成员函数创建线程std::thread t(&amp;MyClass::memberFunction, &amp;obj); 需要传入函数地址和对象指针 pthread-POSIX#include &lt;pthread.h&gt; pthread_t thread;int result &#x3D; pthread_create(&amp;thread, nullptr, threadFunction, nullptr); 成功返回0，线程执行函数threadFunction，最后一个是函数参数result &#x3D; pthread_join(thread, nullptr); 等待结束 std::async不一定会使用多线程第一个参数为std::launch::async则会创建一个新线程 std::launch::deferred会延迟到使用result.get()的线程中执行 12std::future&lt;int&gt; result = std::async(std::launch::async, asyncFunction); //可以传参，异步执行asyncFunction函数int value = result.get(); //获取异步执行的结果 线程同步互斥锁、递归互斥锁，读写锁，条件变量、信号量、等 原子操作atomic，线程局部存储thread_local 原子操作常用于实现锁、信号量、计数器等线程同步机制 在C++中，标准库提供了&lt;atomic&gt;头文件，其中定义了一系列原子操作类型和函数，用于在多线程环境下进行原子操作。常见的原子操作类型包括std::atomic、std::atomic_flag等。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;thread&gt;std::atomic&lt;int&gt; atomicCounter(0);void incrementCounter() &#123; for (int i = 0; i &lt; 10000; ++i) &#123; atomicCounter++; // 原子自增操作 &#125;&#125;int main() &#123; std::thread t1(incrementCounter); std::thread t2(incrementCounter); t1.join(); t2.join(); std::cout &lt;&lt; &quot;Final value of counter: &quot; &lt;&lt; atomicCounter &lt;&lt; std::endl; return 0;&#125; std::atomic&lt;int&gt;类型的atomicCounter被用作一个计数器，它可以被多个线程同时访问而不会产生数据竞争问题。 std::atomic提供了原子操作的功能，它可以确保对共享变量的操作是原子的，即不会被中断或交错。当一个线程正在对共享变量进行原子操作时，其他线程需要等待这个操作完成，不能插入自己的操作，从而保证了共享变量的一致性。 无锁编程通过使用原子操作和其他并发编程技术来避免使用传统的锁机制，从而降低了线程间的竞争和同步开销，提高了程序的并发性能 原子操作： 使用原子操作，如std::atomic，可以在不需要锁的情况下对共享变量进行原子性操作，从而避免了锁带来的竞争和开销。 原子操作通常包括自增、自减、比较交换等操作，可以在多线程环境中安全地对共享变量进行修改。 无锁数据结构： 设计无锁数据结构，如无锁队列、无锁栈、无锁哈希表等，可以避免使用锁进行并发访问控制。 无锁数据结构通常基于原子操作和一些特殊的算法实现，确保并发访问时的数据一致性和正确性。 无锁算法： 设计无锁算法，如无锁排序、无锁并行搜索等，可以在不需要互斥锁的情况下实现高效的并发算法。 无锁算法通常基于原子操作和一些并发编程技术，如分治、分布式计算等，以提高程序的并发性能。 无锁编程模式： 使用无锁编程模式，如消息传递、事件驱动等，可以在不需要显式锁的情况下实现线程间的同步和通信。 无锁编程模式通常基于异步编程和事件驱动模型，以提高程序的并发性能和响应性。 需要注意避免一些常见的陷阱和错误，如ABA问题、内存重排等。 ABA问题具体来说，ABA问题的发生可以分为以下步骤： 初始时刻，共享变量的值为A。 线程T1读取共享变量的值A，并进行一些操作。 在此过程中，另一个线程T2将共享变量的值从A修改为B，然后又将其修改回A，此时共享变量的值又变成了A。 线程T1继续执行，根据共享变量值是否为A做出判断，认为共享变量的值没有被修改，继续执行操作。 在这个过程中，虽然共享变量的值在T1执行期间被修改了，但T1并没有察觉到这一变化，因为它只关心共享变量的当前值是否为A。这种情况下，T1可能会基于错误的假设继续执行，导致程序出现逻辑错误或安全问题。 为了解决ABA问题，通常需要使用一些技术手段，如版本号、时间戳等，来辅助判断共享变量的值是否发生了变化。另外，一些数据结构，如无锁队列、无锁栈等，也会使用类似的技术来避免ABA问题的发生。 内存重排内存重排包括两种类型的重排： 编译器重排：编译器可能会对代码进行优化，改变指令的执行顺序，但不会改变代码的语义。例如，编译器可能会将一些独立的指令重排以提高局部性或减少分支预测失败的可能性。 处理器重排：处理器在执行指令时，为了提高性能，可能会对指令进行乱序执行或者延迟执行。处理器会根据指令之间的数据依赖关系和相关性进行重排，以尽可能地利用处理器的各种功能单元，提高指令执行效率。 内存重排的存在使得在多线程编程中保证程序的正确性变得更加困难。为了避免内存重排导致的问题，通常需要使用同步原语（如互斥锁、原子操作、内存栅栏等）来保证指令的顺序一致性，以及使用volatile关键字来告诉编译器不要对指令进行重排。 ###mutex互斥锁 用于保护临界区 确保在同一时间只有一个线程可以访问共享资源。互斥锁提供了两种基本操作：锁定（lock）和解锁（unlock），线程在进入临界区之前先尝试获取锁，如果锁已被其他线程持有，则该线程被阻塞直到锁可用。 在C++中，互斥锁通常使用std::mutex类来实现。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx; // 定义互斥锁对象void incrementCounter(int&amp; counter) &#123; for (int i = 0; i &lt; 10000; ++i) &#123; // 在访问临界区之前先锁定互斥锁 mtx.lock(); counter++; // 访问完成后解锁互斥锁 mtx.unlock(); &#125;&#125;int main() &#123; int counter = 0; // 创建多个线程并发执行自增操作 std::thread t1(incrementCounter, std::ref(counter)); std::thread t2(incrementCounter, std::ref(counter)); // 等待所有线程结束 t1.join(); t2.join(); std::cout &lt;&lt; &quot;Final value of counter: &quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125; 条件变量条件变量（Condition Variable）是一种线程同步机制，用于在线程间进行通信和同步。它允许一个线程在某个条件不满足时等待（阻塞），而另一个线程在满足条件时通知等待线程继续执行。条件变量通常与互斥锁（Mutex）一起使用，以确保线程之间的安全访问共享资源。 下面是条件变量的一般用法： 创建条件变量和互斥锁： 12std::condition_variable condVar; // 条件变量std::mutex mtx; // 互斥锁 等待条件： 等待线程在进入临界区之前先锁定互斥锁，然后调用wait方法等待条件变量满足： 12std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁condVar.wait(lock, []()&#123; return condition; &#125;); // 等待条件满足 唤醒等待线程： 唤醒线程在进入临界区之前先锁定互斥锁，然后调用notify_one或notify_all方法通知等待线程： 123std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁condition = true; // 修改条件condVar.notify_one(); // 唤醒等待线程 条件变量的使用可以帮助线程之间进行高效的同步和通信，避免了轮询等低效的等待方式。它常用于生产者-消费者模型、读者-写者模型等多线程编程场景中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;std::queue&lt;int&gt; dataQueue; // 共享数据队列std::mutex mtx; // 互斥锁std::condition_variable condVar; // 条件变量void producer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁 // 生产数据并放入队列 dataQueue.push(i); std::cout &lt;&lt; &quot;Produced data: &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; // 在解锁前释放互斥锁 // 唤醒等待的消费者线程 condVar.notify_one(); // 模拟生产数据的间隔 std::this_thread::sleep_for(std::chrono::milliseconds(100)); &#125;&#125;void consumer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁 // 等待条件变量满足 condVar.wait(lock, []()&#123; return !dataQueue.empty(); &#125;); // 从队列中获取数据并消费 int data = dataQueue.front(); dataQueue.pop(); std::cout &lt;&lt; &quot;Consumed data: &quot; &lt;&lt; data &lt;&lt; std::endl; // 模拟消费数据的处理时间 std::this_thread::sleep_for(std::chrono::milliseconds(250)); &#125;&#125;int main() &#123; // 创建生产者线程和消费者线程 std::thread producerThread(producer); std::thread consumerThread(consumer); // 等待生产者线程和消费者线程结束 producerThread.join(); consumerThread.join(); return 0;&#125; 信号量在这个示例中，使用了 Semaphore 类来实现信号量的功能。Semaphore 类包含了 notify() 和 wait() 方法，用于通知和等待信号量。 生产者线程在每次生产数据后，调用 semProducer.wait() 等待生产者信号量，然后将数据放入队列并通知消费者信号量。消费者线程在每次消费数据前，调用 semConsumer.wait() 等待消费者信号量，然后从队列中取出数据并通知生产者信号量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;chrono&gt;class Semaphore &#123;public: Semaphore(int count = 0) : count_(count) &#123;&#125; void notify() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); ++count_; condition_.notify_one(); &#125; void wait() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); while (count_ == 0) &#123; condition_.wait(lock); &#125; --count_; &#125;private: std::mutex mutex_; std::condition_variable condition_; int count_;&#125;;std::queue&lt;int&gt; dataQueue; // 共享数据队列Semaphore semProducer(1), semConsumer(0); // 生产者和消费者信号量void producer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; semProducer.wait(); // 等待生产者信号量 dataQueue.push(i); // 生产数据 std::cout &lt;&lt; &quot;Produced data: &quot; &lt;&lt; i &lt;&lt; std::endl; semConsumer.notify(); // 通知消费者信号量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟生产数据的间隔 &#125;&#125;void consumer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; semConsumer.wait(); // 等待消费者信号量 int data = dataQueue.front(); // 消费数据 dataQueue.pop(); std::cout &lt;&lt; &quot;Consumed data: &quot; &lt;&lt; data &lt;&lt; std::endl; semProducer.notify(); // 通知生产者信号量 std::this_thread::sleep_for(std::chrono::milliseconds(250)); // 模拟消费数据的处理时间 &#125;&#125;int main() &#123; // 创建生产者线程和消费者线程 std::thread producerThread(producer); std::thread consumerThread(consumer); // 等待生产者线程和消费者线程结束 producerThread.join(); consumerThread.join(); return 0;&#125; 读写锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;chrono&gt;#include &lt;vector&gt;class RWLock &#123;public: RWLock() : readerCount(0), writerCount(0) &#123;&#125; void lockRead() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); while (writerCount &gt; 0) &#123; condition_.wait(lock); &#125; ++readerCount; &#125; void unlockRead() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); --readerCount; if (readerCount == 0) &#123; condition_.notify_one(); &#125; &#125; void lockWrite() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); ++writerCount; while (readerCount &gt; 0 || writerCount &gt; 1) &#123; condition_.wait(lock); &#125; &#125; void unlockWrite() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); --writerCount; condition_.notify_all(); &#125;private: std::mutex mutex_; std::condition_variable condition_; int readerCount; int writerCount;&#125;;int data = 0; // 共享数据RWLock rwLock; // 读写锁void reader() &#123; for (int i = 0; i &lt; 10; ++i) &#123; rwLock.lockRead(); // 加读锁 std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; reads data: &quot; &lt;&lt; data &lt;&lt; std::endl; rwLock.unlockRead(); // 解读锁 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟读操作的间隔 &#125;&#125;void writer() &#123; for (int i = 0; i &lt; 5; ++i) &#123; rwLock.lockWrite(); // 加写锁 data++; // 修改数据 std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; writes data: &quot; &lt;&lt; data &lt;&lt; std::endl; rwLock.unlockWrite(); // 解写锁 std::this_thread::sleep_for(std::chrono::milliseconds(250)); // 模拟写操作的间隔 &#125;&#125;int main() &#123; // 创建多个读者线程和写者线程 std::vector&lt;std::thread&gt; readers, writers; for (int i = 0; i &lt; 3; ++i) &#123; readers.emplace_back(reader); &#125; for (int i = 0; i &lt; 2; ++i) &#123; writers.emplace_back(writer); &#125; // 等待所有线程结束 for (auto&amp; readerThread : readers) &#123; readerThread.join(); &#125; for (auto&amp; writerThread : writers) &#123; writerThread.join(); &#125; return 0;&#125; 在这个示例中，使用了 RWLock 类来实现读写锁的功能。RWLock 类包含了 lockRead()、unlockRead()、lockWrite() 和 unlockWrite() 方法，分别用于读锁的加锁、读锁的解锁、写锁的加锁和写锁的解锁。 读者线程在每次读取数据前，调用 rwLock.lockRead() 加读锁，读取数据后调用 rwLock.unlockRead() 解读锁。写者线程在每次修改数据前，调用 rwLock.lockWrite() 加写锁，修改数据后调用 rwLock.unlockWrite() 解写锁。 通过使用读写锁，实现了读者-写者模型中的线程同步和并发控制，提高了读操作的并发性能。 线程局部存储TLS线程局部存储（Thread-Local Storage，TLS）是一种线程特定数据（Thread-Specific Data，TSD）的存储机制 允许每个线程都拥有自己独立的数据副本。这意味着每个线程都可以独立地访问和修改自己的数据副本，而不会影响其他线程的数据。 但是自C++11起，标准库提供了一个名为std::thread_local的关键字，可以轻松实现线程局部存储。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;// 定义线程局部变量thread_local int tls_variable = 0;void threadFunction() &#123; // 每个线程都有自己的tls_variable副本 tls_variable++; std::cout &lt;&lt; &quot;Thread ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;, TLS variable: &quot; &lt;&lt; tls_variable &lt;&lt; std::endl;&#125;int main() &#123; std::thread t1(threadFunction); std::thread t2(threadFunction); t1.join(); t2.join(); return 0;&#125; tls_variable是一个线程局部变量，每个线程都有自己独立的副本。在threadFunction()函数中，每个线程都会递增自己的tls_variable副本，并打印出当前线程的ID和TLS变量的值。因为每个线程都有自己的副本，所以输出的结果会显示不同的线程ID和不同的TLS变量值。 RPC与序列化技术远程过程调用（Remote Procedure Call，RPC）是一种分布式系统中常用的通信机制，它允许一个进程调用另一个进程（通常在不同的计算机上）的函数或方法，就像调用本地函数一样。 序列化技术是RPC的重要组成部分之一，它负责将数据从内存中的对象转换为可以在网络上传输的字节流（通常是二进制或文本格式），以及将接收到的字节流转换回原始对象。 常见的序列化技术包括： JSON（JavaScript Object Notation）： 一种轻量级的数据交换格式，易于人阅读和编写，通常用于Web应用中的数据交换。 XML（eXtensible Markup Language）： 一种标记语言，用于描述数据结构和传输数据，支持复杂的数据结构和元数据。 Protocol Buffers（ProtoBuf）： 由Google开发的二进制序列化格式，具有高效的编解码性能和较小的数据体积，适用于高性能的分布式系统。 MessagePack： 一种高效的二进制序列化格式，比JSON和XML更轻量级，适用于网络传输和数据存储。 Thrift： 由Facebook开发的跨语言的RPC框架，支持多种编程语言和多种序列化格式。 gRRC与ProtobufgRPC是一个高性能、跨语言的RPC框架，由Google开发并开源。它基于HTTP&#x2F;2协议，使用Protocol Buffers作为默认的序列化技术，旨在简化分布式系统之间的通信和服务调用。下面分别介绍gRPC和Protocol Buffers： gRPC： 特点： 高性能：基于HTTP&#x2F;2的多路复用、二进制传输和帧压缩等特性，提供了更高效的网络通信。 跨语言支持：支持多种编程语言，如C++、Java、Go、Python等，可以让不同语言编写的服务之间进行通信。 自动代码生成：通过Protocol Buffers定义服务和消息类型，可以自动生成客户端和服务器端的代码，简化了开发工作。 支持多种调用类型：支持单向调用、服务器流、客户端流和双向流等四种调用类型，满足不同场景的需求。 使用场景： gRPC适用于构建高性能、跨语言的分布式系统，特别适用于微服务架构和大规模分布式系统中的服务通信。 Protocol Buffers（ProtoBuf）： 特点： 简洁高效：采用二进制格式进行序列化，数据体积小、传输速度快，适合在网络传输和存储中使用。 跨语言支持：支持多种编程语言，可以生成不同语言的数据结构和序列化&#x2F;反序列化代码。 版本兼容性：支持向后和向前兼容，可以在不同版本的服务之间进行通信。 自描述性：使用.proto文件定义数据结构和服务接口，具有自描述性，易于维护和修改。 使用场景： Protocol Buffers适用于需要高效序列化和跨语言通信的场景，如分布式系统中的服务通信、数据存储和数据交换等。 在gRPC中，默认使用Protocol Buffers作为序列化技术，可以通过.proto文件定义服务接口和消息类型，然后使用gRPC工具自动生成客户端和服务器端的代码。这样可以简化开发工作，并提供高性能和跨语言的RPC通信能力。 ThriftThrift 是一种远程过程调用（RPC）框架，同时也是一种序列化技术。它最初由 Facebook 开发，用于解决大规模分布式系统中的通信和数据交换问题。Thrift 支持多种编程语言，包括 C++，使得不同语言编写的应用程序可以进行跨语言通信。 Thrift 提供了一个接口定义语言（IDL），用于定义数据类型和服务接口。通过定义IDL，可以生成对应语言的代码，包括数据结构的序列化&#x2F;反序列化代码和远程服务的客户端和服务器端代码。 在 Thrift 中，数据在传输之前会被序列化成字节流，在接收端再进行反序列化。这样做的好处是可以跨不同语言和平台传输数据，同时节省带宽和网络开销。Thrift 支持多种序列化协议，包括二进制协议、压缩协议和可读文本协议等。 在 C++ 中使用 Thrift，你需要定义你的数据结构和服务接口，并使用 Thrift 编译器生成相应的代码。然后你可以在你的 C++ 代码中使用生成的代码来进行序列化、反序列化和远程调用。Thrift 提供了 C++ 库来支持这些功能，使得在 C++ 中使用 Thrift 变得相对简单 ##RapidJSON RapidJSON 是一个快速的 C++ JSON 解析器&#x2F;生成器，提供了简单易用的 API，能够在高效地处理 JSON 数据。 需要安装库 yum install rapidjson 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/writer.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &lt;iostream&gt;using namespace rapidjson;int main() &#123; // JSON 字符串 const char* json = &quot;&#123;\\&quot;name\\&quot;:\\&quot;John\\&quot;,\\&quot;age\\&quot;:30,\\&quot;city\\&quot;:\\&quot;New York\\&quot;&#125;&quot;; // 解析 JSON 字符串 Document doc; doc.Parse(json); // 检查解析是否成功 if (!doc.IsObject()) &#123; std::cerr &lt;&lt; &quot;Invalid JSON format!&quot; &lt;&lt; std::endl; return 1; &#125; // 获取字段值 if (doc.HasMember(&quot;name&quot;) &amp;&amp; doc[&quot;name&quot;].IsString()) &#123; std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; doc[&quot;name&quot;].GetString() &lt;&lt; std::endl; &#125; if (doc.HasMember(&quot;age&quot;) &amp;&amp; doc[&quot;age&quot;].IsInt()) &#123; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; doc[&quot;age&quot;].GetInt() &lt;&lt; std::endl; &#125; if (doc.HasMember(&quot;city&quot;) &amp;&amp; doc[&quot;city&quot;].IsString()) &#123; std::cout &lt;&lt; &quot;City: &quot; &lt;&lt; doc[&quot;city&quot;].GetString() &lt;&lt; std::endl; &#125; // 生成 JSON 字符串 StringBuffer buffer; Writer&lt;StringBuffer&gt; writer(buffer); doc.Accept(writer); // 输出生成的 JSON 字符串 std::cout &lt;&lt; &quot;Generated JSON: &quot; &lt;&lt; buffer.GetString() &lt;&lt; std::endl; return 0;&#125; AVROApache Avro 是一个数据序列化系统，它提供了一种跨语言的数据交换格式。与 RapidJSON 不同，Avro 旨在提供更多的功能，包括支持数据架构、远程过程调用（RPC）和数据存储等。 需要去官方下载库 C++ 中使用 Avro 进行数据序列化和反序列化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;avro/Encoder.hh&gt;#include &lt;avro/Decoder.hh&gt;#include &lt;avro/Compiler.hh&gt;#include &lt;avro/Generic.hh&gt;using namespace avro;struct Person &#123; std::string name; int age; Person() &#123;&#125; Person(const std::string&amp; name, int age) : name(name), age(age) &#123;&#125; // 序列化函数 template&lt;typename Encoder&gt; void encode(Encoder&amp; encoder) const &#123; encoder.encode(name); encoder.encode(age); &#125; // 反序列化函数 template&lt;typename Decoder&gt; void decode(Decoder&amp; decoder) &#123; decoder.decode(name); decoder.decode(age); &#125;&#125;;int main() &#123; // 创建 Person 对象 Person person(&quot;John&quot;, 30); // 将 Person 对象序列化为 Avro 格式 std::vector&lt;uint8_t&gt; buffer; avro::OutputStreamPtr out = avro::memoryOutputStream(); avro::EncoderPtr encoder = avro::binaryEncoder(); encoder-&gt;init(*out); avro::encode(*encoder, person); // 从 Avro 格式反序列化为 Person 对象 avro::InputStreamPtr in = avro::memoryInputStream(*out); avro::DecoderPtr decoder = avro::binaryDecoder(); decoder-&gt;init(*in); Person deserializedPerson; avro::decode(*decoder, deserializedPerson); // 输出反序列化后的 Person 对象 std::cout &lt;&lt; &quot;Deserialized Person: Name=&quot; &lt;&lt; deserializedPerson.name &lt;&lt; &quot;, Age=&quot; &lt;&lt; deserializedPerson.age &lt;&lt; std::endl; return 0;&#125; 延时循环早期 计数等待 while(wait&lt;10000) wait++; 中定义了一个符号常量 _CLOCKS_PER_SEC 该常量等于每秒钟包含的系统时间单位数 将系统时间除以这个值，可以得到秒数 秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间 ctime将clock_t作为clock( )返回类型的别名，这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。 1234float se;clock_t delay = se*CLOCKS_PER_SEC;clock_t start = clock();while (clock()-start&lt;delay); bitset#include 用于高效存储和访问布尔值-权限控制，状态标记等 构造 bitset b N位全0 bitset b(value) 存value的二进制位数少于N补0，大于只取低位N位 bitset b(str) 字符串只包含01 方法 size 位数 count 1的位数 any 只少有一个1返回true none 全0返回true set 全置为1 reset 设0 set(pos) 指定位设1 reset set(pos，val) 指定位设为val(0,1) flip 翻转所有位 0变1 1变0 (pos) 翻转指定位 test(pos)：测试指定位置的位是否为1，如果是则返回true to_ulong()：将bitset的内容转换为unsigned long类型的值（如果bitset的大小超过了unsigned long的位数，则会发生溢出）。 to_ullong()：将bitset的内容转换为unsigned long long类型的值（如果bitset的大小超过了unsigned long lon的位数，则会发生溢出）。 to_string()：将bitset的内容转换为包含’0’和’1’的字符串。","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"设计模式","slug":"source/C++/设计模式","date":"2025-03-10T16:00:00.000Z","updated":"2025-03-11T14:51:50.711Z","comments":true,"path":"2025/03/11/source/C++/设计模式/","permalink":"http://example.com/2025/03/11/source/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 懒汉模式：&#x3D;&#x3D;用的时候才初始化&#x3D;&#x3D;，在C++11后，不需要加锁，直接使用函数内局部静态对象即可。 1234567891011121314151617181920212223#include &lt;iostream&gt;class Singleton &#123;private: // 构造函数私有化，防止外部实例化 Singleton() &#123;&#125; // 拷贝构造函数和赋值运算符私有化，防止拷贝和赋值 Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete;public: static Singleton&amp; getInstance() &#123; static Singleton instance; //c++11 return instance; &#125;&#125;;int main() &#123; Singleton&amp; s1 = Singleton::getInstance(); Singleton&amp; s2 = Singleton::getInstance(); std::cout &lt;&lt; (&amp;s1 == &amp;s2) &lt;&lt; std::endl; // 输出 1，表示两个引用指向同一个对象 return 0;&#125; 饿汉模式：&#x3D;&#x3D;程序启动时初始化&#x3D;&#x3D;，不需要加锁 123456789101112131415161718192021222324#include &lt;iostream&gt;class Singleton &#123;private: Singleton() &#123;&#125; Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete; static Singleton instance; //区别1public: static Singleton&amp; getInstance() &#123; return instance; &#125;&#125;;// 静态成员变量的初始化Singleton Singleton::instance; //区别2int main() &#123; Singleton&amp; s1 = Singleton::getInstance(); Singleton&amp; s2 = Singleton::getInstance(); std::cout &lt;&lt; (&amp;s1 == &amp;s2) &lt;&lt; std::endl; // 输出 1，表示两个引用指向同一个对象 return 0;&#125; 工厂模式提供了一种创建对象的接口，但允许子类决定要实例化的类是哪一个。工厂模式将对象的创建与使用分离，使得代码更易于扩展和维护。在C++中，工厂模式通常分为简单工厂模式、工厂方法模式和抽象工厂模式。 简单工厂模式（Simple Factory Pattern） 产品类+工厂类，工厂类根据产品特性返回各自类对象指针 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;// 抽象产品类class Product &#123;public: virtual void operation() = 0; //纯虚函数 抽象基类&#125;;//产品类ConcreteProductA和ConcreteProductB继承Product并重写operation函数// 简单工厂类class SimpleFactory &#123;public: static Product* createProduct(char type) &#123; if (type == &#x27;A&#x27;) &#123; return new ConcreteProductA(); &#125; else if (type == &#x27;B&#x27;) &#123; return new ConcreteProductB(); &#125; else &#123; return nullptr; // 或者抛出异常 &#125; &#125;&#125;;int main() &#123; // 使用简单工厂创建产品 Product* productA = SimpleFactory::createProduct(&#x27;A&#x27;); Product* productB = SimpleFactory::createProduct(&#x27;B&#x27;); // 使用产品 if (productA) productA-&gt;operation(); if (productB) productB-&gt;operation(); // 释放内存 delete productA; delete productB; return 0;&#125; 工厂方法模式（Factory Method Pattern） 每个产品有自己的工厂 1234567891011121314151617181920212223242526// 抽象工厂类class Factory &#123;public: virtual Product* createProduct() = 0;&#125;;// 具体工厂类Aclass ConcreteFactoryA : public Factory &#123;public: Product* createProduct() override &#123; return new ConcreteProductA(); &#125;&#125;;// 具体工厂类Bclass ConcreteFactoryB : public Factory &#123;public: Product* createProduct() override &#123; return new ConcreteProductB(); &#125;&#125;; Factory* factoryA = new ConcreteFactoryA(); Product* productA = factoryA-&gt;createProduct(); productA-&gt;operation(); delete productA; delete factoryA; 抽象工厂模式（Abstract Factory Pattern） 工厂方法模式的升级，一个工厂管理一类产品 123456789101112131415161718192021222324252627// 抽象工厂类class AbstractFactory &#123;public: virtual AbstractProductA* createProductA() = 0; virtual AbstractProductB* createProductB() = 0;&#125;;// 具体工厂类1class ConcreteFactory1 : public AbstractFactory &#123;public: AbstractProductA* createProductA() override &#123; return new ConcreteProductA1(); &#125; AbstractProductB* createProductB() override &#123; return new ConcreteProductB1(); &#125;&#125;;int main() &#123; // 使用具体工厂1创建产品 AbstractFactory* factory1 = new ConcreteFactory1(); AbstractProductA* productA1 = factory1-&gt;createProductA(); AbstractProductB* productB1 = factory1-&gt;createProductB(); productA1-&gt;operationA(); productB1-&gt;operationB(); delete productA1; delete productB1; delete factory1; 代理模式代理类封装主题类指针作为成员，然后代理类提供方法，使用代理类的方法实际去调用主题类的方法 应用：记录日志、权限控制、延迟加载等。 在C++中，代理模式通常分为静态代理和动态代理两种实现方式。 静态代理： 静态代理是在编译时就确定代理对象和被代理对象的关系，并在代码中显式定义代理类。以下是一个简单的静态代理示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;// 抽象主题接口class Subject &#123;public: virtual void request() = 0;&#125;;// 具体主题类class RealSubject : public Subject &#123;public: void request() override &#123; std::cout &lt;&lt; &quot;RealSubject handles the request.&quot; &lt;&lt; std::endl; &#125;&#125;;// 代理类class Proxy : public Subject &#123;private: RealSubject* realSubject;public: Proxy() : realSubject(new RealSubject()) &#123;&#125; void request() override &#123; // 在调用实际主题对象前后可以执行额外的操作 std::cout &lt;&lt; &quot;Proxy handles the request.&quot; &lt;&lt; std::endl; realSubject-&gt;request(); &#125; ~Proxy() &#123; delete realSubject; &#125;&#125;;int main() &#123; Proxy proxy; proxy.request(); return 0;&#125; 动态代理： 动态代理是在运行时生成代理对象，无需显式地编写代理类。C++中可以通过使用第三方库（如Boost、C++标准库提供的std::function和std::bind）或手动实现动态代理。以下是一个使用std::function和std::bind手动实现的动态代理示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;functional&gt;// 抽象主题接口class Subject &#123;public: virtual void request() = 0;&#125;;// 具体主题类class RealSubject : public Subject &#123;public: void request() override &#123; std::cout &lt;&lt; &quot;RealSubject handles the request.&quot; &lt;&lt; std::endl; &#125;&#125;;// 动态代理类class DynamicProxy : public Subject &#123;private: std::function&lt;void()&gt; before; std::function&lt;void()&gt; after; RealSubject* realSubject;public: DynamicProxy(RealSubject* realSubject, std::function&lt;void()&gt; before, std::function&lt;void()&gt; after) : realSubject(realSubject), before(before), after(after) &#123;&#125; void request() override &#123; before(); // 在调用实际主题对象前执行额外的操作 realSubject-&gt;request(); after(); // 在调用实际主题对象后执行额外的操作 &#125; ~DynamicProxy() &#123; delete realSubject; &#125;&#125;;int main() &#123; RealSubject* realSubject = new RealSubject(); // 定义前置和后置操作 auto before = []() &#123; std::cout &lt;&lt; &quot;DynamicProxy handles the request before RealSubject.&quot; &lt;&lt; std::endl; &#125;; auto after = []() &#123; std::cout &lt;&lt; &quot;DynamicProxy handles the request after RealSubject.&quot; &lt;&lt; std::endl; &#125;; // 创建动态代理对象并调用方法 DynamicProxy dynamicProxy(realSubject, before, after); dynamicProxy.request(); return 0;&#125; 观察者模式主题类含有多个观察者类对象，通过主题类维护观察者类的数据结构，主题类还有一个变量记录当前状态，当发生变化时调用观察者类的update，告诉观察者类状态改变了，并且观察者类可以调用主题类的接口查看状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;// 观察者接口class Observer &#123; public: virtual void update() = 0; //纯虚函数 抽象基类 &#125;;// 主题接口class Subject &#123;protected: std::vector&lt;Observer*&gt; observers;public: void attach(Observer* observer) &#123; observers.push_back(observer); &#125; void detach(Observer* observer) &#123; observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); &#125; void notify() &#123; for (Observer* observer : observers) &#123; observer-&gt;update(); &#125; &#125;&#125;;// 具体主题类class ConcreteSubject : public Subject &#123;private: int state;public: void setState(int newState) &#123; state = newState; notify(); // 状态改变时通知观察者 &#125; int getState() const &#123; return state; &#125;&#125;;// 具体观察者类class ConcreteObserver : public Observer &#123;private: ConcreteSubject* subject;public: ConcreteObserver(ConcreteSubject* subject) : subject(subject) &#123;&#125; void update() override &#123; std::cout &lt;&lt; &quot;Observer received state update: &quot; &lt;&lt; subject-&gt;getState() &lt;&lt; std::endl; &#125;&#125;;int main() &#123; // 创建具体主题对象和具体观察者对象 ConcreteSubject subject; ConcreteObserver observer1(&amp;subject); ConcreteObserver observer2(&amp;subject); // 将观察者对象添加到主题对象的观察者列表中 subject.attach(&amp;observer1); subject.attach(&amp;observer2); // 改变主题对象的状态，观察者对象将收到通知并更新 subject.setState(10); // 将观察者对象从主题对象的观察者列表中移除 subject.detach(&amp;observer2); // 再次改变主题对象的状态，只有剩余的观察者对象将收到通知并更新 subject.setState(20); return 0;&#125; 策略模式策略模式是一种行为设计模式，它允许你定义一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;// 定义支付策略的抽象基类class PaymentStrategy &#123;public: virtual void pay(double amount) const = 0; virtual ~PaymentStrategy() &#123;&#125;&#125;;// 具体的支付策略：信用卡支付class CreditCardPayment : public PaymentStrategy &#123;public: void pay(double amount) const override &#123; std::cout &lt;&lt; &quot;Paid $&quot; &lt;&lt; amount &lt;&lt; &quot; using Credit Card.&quot; &lt;&lt; std::endl; &#125;&#125;;// 具体的支付策略：支付宝支付class AlipayPayment : public PaymentStrategy &#123;public: void pay(double amount) const override &#123; std::cout &lt;&lt; &quot;Paid $&quot; &lt;&lt; amount &lt;&lt; &quot; using Alipay.&quot; &lt;&lt; std::endl; &#125;&#125;;// 上下文类，使用支付策略class ShoppingCart &#123;private: PaymentStrategy* paymentStrategy;public: ShoppingCart(PaymentStrategy* strategy) : paymentStrategy(strategy) &#123;&#125; // 设置支付策略 void setPaymentStrategy(PaymentStrategy* strategy) &#123; paymentStrategy = strategy; &#125; // 结账方法，使用当前的支付策略进行支付 void checkout(double amount) &#123; paymentStrategy-&gt;pay(amount); &#125;&#125;;int main() &#123; // 创建具体的支付策略对象 CreditCardPayment creditCardPayment; AlipayPayment alipayPayment; // 创建购物车并使用信用卡支付策略 ShoppingCart cart(&amp;creditCardPayment); cart.checkout(100.0); // 切换到支付宝支付策略 cart.setPaymentStrategy(&amp;alipayPayment); cart.checkout(200.0); return 0;&#125; 装饰器模式场景：奶茶店 组件类（子类：咖啡），装饰器类（子类：牛奶，糖），装饰器类含组件类牛奶指针，通过装饰器类可以将牛奶或糖的信息与咖啡结合，打印出新的价格等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;// 抽象组件类：饮品class Beverage &#123;public: virtual std::string getDescription() const = 0; virtual double cost() const = 0; virtual ~Beverage() &#123;&#125;&#125;;// 具体组件类：咖啡class Coffee : public Beverage &#123;public: std::string getDescription() const override &#123; return &quot;Coffee&quot;; &#125; double cost() const override &#123; return 2.0; &#125;&#125;;// 抽象装饰器类class CondimentDecorator : public Beverage &#123;protected: Beverage* beverage;public: CondimentDecorator(Beverage* bev) : beverage(bev) &#123;&#125; std::string getDescription() const override = 0; double cost() const override = 0;&#125;;// 具体装饰器类：牛奶class Milk : public CondimentDecorator &#123;public: Milk(Beverage* bev) : CondimentDecorator(bev) &#123;&#125; std::string getDescription() const override &#123; return beverage-&gt;getDescription() + &quot;, Milk&quot;; &#125; double cost() const override &#123; return beverage-&gt;cost() + 0.5; &#125;&#125;;// 具体装饰器类：糖class Sugar : public CondimentDecorator &#123;public: Sugar(Beverage* bev) : CondimentDecorator(bev) &#123;&#125; std::string getDescription() const override &#123; return beverage-&gt;getDescription() + &quot;, Sugar&quot;; &#125; double cost() const override &#123; return beverage-&gt;cost() + 0.3; &#125;&#125;;int main() &#123; // 创建一杯纯咖啡 Beverage* coffee = new Coffee(); std::cout &lt;&lt; coffee-&gt;getDescription() &lt;&lt; &quot; costs $&quot; &lt;&lt; coffee-&gt;cost() &lt;&lt; std::endl; // 为咖啡添加牛奶 Beverage* coffeeWithMilk = new Milk(coffee); std::cout &lt;&lt; coffeeWithMilk-&gt;getDescription() &lt;&lt; &quot; costs $&quot; &lt;&lt; coffeeWithMilk-&gt;cost() &lt;&lt; std::endl; // 为加了牛奶的咖啡再添加糖 Beverage* coffeeWithMilkAndSugar = new Sugar(coffeeWithMilk); std::cout &lt;&lt; coffeeWithMilkAndSugar-&gt;getDescription() &lt;&lt; &quot; costs $&quot; &lt;&lt; coffeeWithMilkAndSugar-&gt;cost() &lt;&lt; std::endl; // 释放内存 delete coffeeWithMilkAndSugar; delete coffeeWithMilk; delete coffee; return 0;&#125; 适配器模式桥接模式责任链模式","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"c++新特性","slug":"source/C++/C++ 新特性","date":"2025-03-10T16:00:00.000Z","updated":"2025-03-11T14:51:50.471Z","comments":true,"path":"2025/03/11/source/C++/C++ 新特性/","permalink":"http://example.com/2025/03/11/source/C++/C++%20%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"c++11c++11中有特别的经常使用的东西，所以说最少都得使用c++11 auto unordered_map thread c++正则表达式库(RE) ##move std::move是c++11中提供的一个函数模板，将一个左值强制转换为右值引用，从而可以调用对象的移动构造函数或移动赋值运算符，避免不必要的深拷贝，配合右值引用声明符 &amp;&amp; 使用 右值引用它为 C++ 中的移动语义和完美转发提供了基础。右值引用可以绑定到临时对象（右值），并允许对其进行修改或移动 int&amp;&amp; rvalueRef &#x3D; 5; &#x2F;&#x2F; 右值引用绑定到临时对象 5 右值引用声明符 &amp;&amp; 移动语义：移动构造函数和移动赋值运算符配合std::move使用 MyString(MyString&amp;&amp; other) noexcept : data(other.data), length(other.length) MyString&amp; operator&#x3D;(MyString&amp;&amp; other) noexcept 完美转发：std::forward()：在函数模板中保持参数的类型和值类别（左值或右值）不变 12345678910#include &lt;iostream&gt;#include &lt;utility&gt;void print(int&amp; x) &#123;std::cout &lt;&lt; &quot;Lvalue: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;void print(int&amp;&amp; x) &#123;std::cout &lt;&lt; &quot;Rvalue: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;template&lt;typename T&gt; void forwardPrint(T&amp;&amp; arg) &#123;print(std::forward&lt;T&gt;(arg));&#125;//forward用在函数模板中，保持参数类型一致int main() &#123; int a = 10; forwardPrint(a); // 转发左值 forwardPrint(20); // 转发右值 return 0;&#125; 引用折叠规则：参数为左值&#x2F;左值引用，T&amp;&amp;将转化为int&amp;；参数为右值&#x2F;右值引用，T&amp;&amp;将转化为int&amp;&amp; 声明出来的左值引用、右值引用都是左值 tuple#include 创建 12auto t1 = make_tuple(1, 3.14, &#x27;a&#x27;); // 使用 make_tuple tuple&lt;int, double, char&gt; t2(1, 3.14, &#x27;a&#x27;); // 直接初始化 访问 123456// 使用 std::get int first = get&lt;0&gt;(t1); double second = sget&lt;1&gt;(t1); char third = get&lt;2&gt;(t1); // C++17 结构化绑定 auto [i, d, c] = t1; 大小和类型 12static_assert(tuple_size&lt;decltype(t1)&gt;::value == 3, &quot;Tuple size is 3&quot;); static_assert(is_same&lt;tuple_element&lt;1, decltype(t1)&gt;::type, double&gt;::value, &quot;Second element is double&quot;); 修改值 12tuple&lt;int, double, char&gt; mutableTuple(1, 3.14, &#x27;a&#x27;); get&lt;0&gt;(mutableTuple) = 2; // 修改第一个元素 比较 1234auto t3 = make_tuple(1, 2.0, &#x27;b&#x27;); if (t1 &lt; t3) &#123; // t1 在字典序上小于 t3 &#125; 结构与合并 c++17 12auto [a, b, c] = t1; // 解构 auto combined = tuple_cat(t1, make_tuple(42)); // 合并 使用场景 需要从函数返回多个值时 需要存储或传递一组异质（不同类型）的数据时 模板元编程中，用于类型列表或值列表 lambda它是一种匿名函数的声明方式，可以在需要时内联定义函数，使得代码更加简洁和易读 [capture list] (parameter list) -&gt; return type &#123; function body &#125; capture list：捕获列表，用于指定 lambda 表达式访问的外部变量的方式。 值捕获[var]、引用捕获[&amp;var] [&#x3D;],捕获所在作用域所有变量的值 [&amp;]，捕获作用域内所有参数的引用 [&#x3D;, &amp;var] var以引用方式捕获其他以值的方式 [&amp;, var] parameter list：参数列表，指定 lambda 函数的参数。与普通函数参数类似，可以为空或包含一个或多个参数。 return type：返回类型，指定 lambda 函数的返回类型。可以省略，编译器会自动推导返回类型。 function body：函数体，指定 lambda 函数的具体实现 可变lambda：一般捕获的变量不能修改要修改需要使用mutable auto lambda &#x3D; [num]() mutable { 123456789101112#include &lt;iostream&gt;int main() &#123; // 定义一个 lambda 表达式，接受两个参数并返回它们的和 auto sum = [](int a, int b) -&gt; int &#123; return a + b; &#125;; // 使用 lambda 表达式计算两个整数的和 int result = sum(3, 4); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 12345678910111213#include &lt;iostream&gt;int main() &#123; int x = 3; int y = 4; // 捕获 x 和 y 的值，并计算它们的和 auto sum = [x, y]() &#123; return x + y; &#125;; // 使用 lambda 表达式计算 x 和 y 的和 int result = sum(); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; for each对容器中的元素执行指定的操作,接受一个范围（通常是一个容器的迭代器对）和一个函数对象（函数指针、函数或者 Lambda 表达式），并将该函数对象应用于范围内的每个元素 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 示例函数对象struct Print &#123; void operator()(int x) const &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;; // 使用函数对象 Print 输出每个元素 std::for_each(vec.begin(), vec.end(), Print()); // 使用 Lambda 表达式输出每个元素的平方 std::cout &lt;&lt; std::endl; std::for_each(vec.begin(), vec.end(), [](int x) &#123; std::cout &lt;&lt; x * x &lt;&lt; &quot; &quot;; &#125;); return 0;&#125; 智能指针-RALL机制自动内存管理、自动释放、防止内存泄漏等。 C++11 提供了三种主要的智能指针类型： std::unique_ptr： std::unique_ptr 独占拥有权 当 std::unique_ptr 被销毁时，它所管理的资源会被自动释放。 不能进行拷贝构造和拷贝赋值，但可以进行移动构造(初始化的时候move)和移动赋值(初始化之后使用)-使用std::move()移交控制权。 std::shared_ptr： 多个 std::shared_pt&#96; 可以同时指向同一块内存,共享拥有权。 引用计数 管理资源的生命周期，当最后一个 std::shared_ptr被销毁时，它所管理的资源会被释放。 可以使用拷贝，增加引用计数。 std::weak_ptr： std::weak_ptr 是 std::shared_ptr的弱引用，不会增加引用计数。 不影响资源的生命周期，只是提供了对资源的观察。 主要用于解决 std::shared_ptr 循环引用问题。(两个对象中都有一个shared_ptr指向对方导致计数至少为1，永远不会被释放) 观察者模式：通过-&gt;lock() 方法来获取一个shared_ptr，如果所引用的对象还存在（即引用计数大于 0），会返回一个有效的shared_ptr，否则返回一个空的。这样就可以安全地访问可能已经被销毁的对象，同时避免了不合理地延长对象的生命周期。 缓存系统：如果存在则返回资源，不存在则创建新的 使用1234//直接使用new 需要显式释放std::unique_ptr&lt;int&gt; ptr(new int(42));//使用make_uniqueauto ptr = std::make_unique&lt;int&gt;(42); 1234567unique_ptr / shared_ptrauto ptr1 = std::make_unique&lt;Resource&gt;(&quot;Resource1&quot;);std::unique_ptr&lt;Resource&gt; ptr2(new Resource(&quot;Resource2&quot;));weak_ptrstd::weak_ptr&lt;Resource&gt; ptr5 = ptr3; //*从shared_ptr创建weak_ptr* if (auto shared_ptr = ptr5.lock()) &#123;&#125; //通过lock使用 线程安全互斥锁mutex 原子操作atomic 读写锁 shared_mutex 条件变量condition_variable 线程局部存储 无锁数据结构 单例模式的线程安全实现 mutex#include 定义：std::mutex mtx; 使用： lock&#x2F;unlock 使用 mtx.lock(); mtx.unlock(); lock_guard（RAII方式） std::lock_guard&lt;std::mutex&gt; lock(mtx); unique_lock（更灵活的RAII方式） 可以重新解锁上锁，可以配合条件变量，可以使用move转让所有权 延迟锁定defer_lock std::unique_lock &lt;std::mutex&gt; lock1(mtx, std::defer_lock); std::unique_lock &lt;std::mutex&gt; lock2(to.mtx, std::defer_lock); &#x2F;&#x2F;另一个对象to作为参数， &#x2F;&#x2F; 避免死锁的同时加锁 std::lock(lock1, lock2); try_lock 的使用 非阻塞没有获取锁立即返回 if (mtx.try_lock()) {…} ​ mtx.unlock(); } 条件变量condition_variable#include 相对于mutex，使线程能按顺序执行 mesa语义：while (!condition) &#123;wait(cv);&#125; 防止虚假唤醒，即使被虚假唤醒也会检查条件是否满足，确保安全，而不是用if c++11的wait带谓词(返回bool的判断条件)版本cv.wait(lock, [this]&#123; return condition; &#125;); 1234567891011121314mutable std::mutex mtx; std::condition_variable cv;//一个线程std::unique_lock&lt;std::mutex&gt; lock(mtx);...cv.notify_one(); //通知一个正在wait的线程//另一个线程std::unique_lock&lt;std::mutex&gt; lock(mtx);while (!condition) &#123; cv.wait(lock);&#125;... notify_one notify_all wait wait_for 等待一段时间 wait_until 等待到一个时间点 1234567891011while (queue.empty()) &#123; not_empty.wait(lock);&#125;bool success = not_empty.wait_for(lock, timeout, [this]() &#123; return !queue.empty(); &#125;);bool success = not_empty.wait_until(lock, deadline, [this]() &#123; return !queue.empty();&#125;); 防止被继承 final c++14模板函数make_unique 泛型lambda表达式：允许使用auto类型作为参数 许函数在不使用 decltype 的情况下进行返回类型推导。 变量模板 123456789#include &lt;iostream&gt;template &lt;typename T&gt;constexpr T pi = T(3.1415926535897932385);int main() &#123; std::cout &lt;&lt; pi&lt;double&gt; &lt;&lt; std::endl; return 0;&#125; 二进制字面量和单引号作数字分隔符 使用 0b或 0B 前缀表示二进制数 12int binary = 0b1010; long long largeNumber = 1&#x27;000&#x27;000&#x27;000; c++17 if constexpr是一个编译时条件语句，在编译时就进行条件选择不同路径 跨平台文件系统操作库 std::filesystem variant union联合的现代更安全替代 结构化绑定123456789101112#include &lt;iostream&gt;#include &lt;tuple&gt;std::tuple&lt;int, double&gt; getValues() &#123; return std::make_tuple(1, 2.5);&#125;int main() &#123; auto [a, b] = getValues(); std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; return 0;&#125; std::optionalstd::optional 表示一个可能存在的值，它可以包含一个值或者为空，避免了使用指针和空指针检查 1234567891011121314151617#include &lt;iostream&gt;#include &lt;optional&gt;std::optional&lt;int&gt; getValue(bool condition) &#123; if (condition) &#123; return 42; &#125; return std::nullopt;&#125;int main() &#123; auto result = getValue(true); if (result) &#123; std::cout &lt;&lt; *result &lt;&lt; std::endl; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"使用hexo构建博客网站","slug":"source/工具-环境/hexo","date":"2025-03-03T16:00:00.000Z","updated":"2025-03-11T14:51:50.712Z","comments":true,"path":"2025/03/04/source/工具-环境/hexo/","permalink":"http://example.com/2025/03/04/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/hexo/","excerpt":"","text":"前置准备下载Node.js使用nvm安装Node.js 1234curl -o- https://gitee.com/mirrors/nvm/raw/v0.39.3/install.sh | bash #使用镜像源安装nvmsource ~/.bashrcnvm --versionnvm install --lts #安装Node 下载hexo12345678npm install hexo-cli -ghexo init blog #用hexo搭建一个文件夹cd blog #下载插件npm i hexo-theme-volantis --save #下载主题volantisnpm i hexo-generator-json-content --save #搜索功能npm i giscus --save #下载评论系统npm install hexo-deployer-git --save #git推送 目录结构和使用说明&#x2F;public 存放生成后的静态网页资源&#x2F;source 存放构建网站所需要的源文件 hexo g 生成静态网站hexo s 启动本地服务器，访问4000号端口就可以看到构建的网页hexo d 部署到远程服务器hexo clean &amp;&amp; hexo g -d 前面三个命令的集合 使用nginx代理网页把public目录下的所有内容复制到nginx的html目录下cd publiccp -rf * &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html启动nginx服务访问80端口查看 使用github云代理网页 新建仓库 新建仓库-仓库名字：用户名.github.io仓库的main分支用来存源笔记文件 master分支用来存前端文件 编辑_config.yml 1234deploy: type: git repo: git@github.com:你的用户名/你的用户名.github.io.git branch: master 这里可以使用ssh也可以使用http 使用ssh要先配置密钥我的ssh地址：git@github.com:tutuLP&#x2F;tutuLP.github.io.git 配置git用户信息 git config –global user.email tutu2061867903@gmail.comgit config –global user.name tutuLP 可能需要打开端口22 9418 修改仓库配置 进入GitHub仓库的设置页面-Pages-GitHub Pages选项 将源设置为master分支这时得到网址 https://tutulp.github.io/ hexo d 部署到github服务器平台 直接在&#x2F;source&#x2F;_posts文件夹下克隆仓库进行快速同步 后续更新博客 提交并push到github cd &#x2F;root&#x2F;nginx&#x2F;blog&#x2F;source&#x2F;_posts&#x2F; git pull hexo generate hexo deploy 自定义域名https://tutulp.github.io/ 是的，你可以通过将自定义域名（例如你拥有的域名）映射到你的GitHub Pages网站来实现这一目标。以下是一些步骤： 购买域名：首先，你需要购买一个域名，例如yourdomain.com。你可以通过注册商（例如GoDaddy、Namecheap等）购买域名。 配置DNS记录：登录到你的域名注册商的控制面板，并配置DNS记录，将你的域名指向GitHub Pages。通常，你需要添加一个CNAME记录，将域名指向你的GitHub Pages用户名，例如yourusername.github.io。具体的步骤可能会因注册商而异，你可以参考GitHub Pages提供的文档或向注册商寻求帮助。 在GitHub设置中配置自定义域名：登录到GitHub，进入你的仓库设置页面，将你的自定义域名添加到”Custom domain”字段中。 等待DNS生效：一旦你配置了DNS记录并保存了更改，你需要等待一段时间（通常几小时至48小时），直到DNS记录生效。一旦生效，你的域名就会指向你的GitHub Pages网站。 HTTPS支持：GitHub Pages支持HTTPS，但你需要确保你的域名有有效的SSL证书。你可以使用GitHub提供的自动生成的SSL证书，或者使用其他证书颁发机构提供的证书。 ##shell脚本自动化 &#x2F;root下新建blog.sh 12345678#!/bin/bash cd /root/hexo/blog_new/source/_posts/tutuLP.github.io || exit git pull cd .. cd .. hexo generate hexo deploy echo &quot;博客部署完成！&quot; bash blog.sh 主题美化根目录下可以看到_config.yml的配置文件，新建_config.volantis.yml 修改配置文件_config.yml 123456789title: tutulp&#x27;s blogdescription: &#x27;tutulp的博客网站&#x27;author: tutulplanguage: zh-CNtheme: volantisdeploy: type: git repo: git@github.com:tutuLP/tutuLP.github.io.git branch: master _config.volantis.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135# 平滑滚动效果scroll_smooth: true#作者article: body: meta_library: author: avatar: name: tutulp#搜索search: enable: true service: hexo#暗黑模式plugins: darkmode: enable: true#评论 参考https://giscus.app/zh-CNcomments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 service: giscus giscus: repo: &quot;tutuLP/tutuLP.github.io&quot; repo-id: &quot;R_kgDOLk_elA&quot; category: &quot;Announcements&quot; category-id: &quot;DIC_kwDOLk_elM4Cnh_D&quot; mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot;#首页cover: height_scheme: full # full, half layout_scheme: search display: home: true archive: true others: true # can be written in front-matter &#x27;cover: true&#x27; categorie: true tag: true background: https://s3.bmp.ovh/imgs/2025/03/03/64c32e0ed0f747a9.jpg title: &#x27;Leland Titus&#x27; subtitle: &#x27;风沉云万里&#x27; search: Recover lost knowledge # search bar placeholder features: - name: 博客 icon: # img: volantis-static/media/twemoji/assets/svg/1f4f0.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg url: / - name: 分类 icon: # img: volantis-static/media/twemoji/assets/svg/1f4f0.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg url: /categories/ - name: 标签 icon: # img: volantis-static/media/twemoji/assets/svg/1f4f0.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg url: /tags/ - name: 归档 url: /archives/ - name: 作者 icon: # img: volantis-static/media/twemoji/assets/svg/1f9ec.svg # https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg url: /about/#导航栏navbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: /archives/ - name: 作者 icon: fa-solid fa-info-circle url: about/ - name: 暗黑模式 icon: fas fa-moon toggle: darkmode search: Search...#页尾site_footer: # layout of footer: [aplayer, social, license, analytics, info(本站主题), copyright] layout: [license2, info, copyright] source: https://github.com/volantis-x/volantis-docs/ # analytics using leancloud analytics: &gt; &lt;span id=&quot;lc-sv&quot;&gt;本站总访问量为 &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fa-solid fa-loader fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; 次&lt;/span&gt; &lt;span id=&quot;lc-uv&quot;&gt;访客数为 &lt;span id=&#x27;number&#x27;&gt;&lt;i class=&quot;fa-solid fa-loader fa-spin fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/span&gt; 人&lt;/span&gt; # site copyright license2: &gt; &lt;span id=&quot;lc-sv&quot;&gt;博客内容遵循 tutulp-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议&lt;/span&gt; copyright: &#x27;[Copyright © since 2025 tutulp](/)&#x27;#侧边部件sidebar: widget_library: blogger: avatar: https://s3.bmp.ovh/imgs/2025/03/03/30639e1f0584064f.jpg shape: circle#样式custom_css:#抗锯齿 font_smoothing: true # font-smoothing for webkit#导航栏 navbar: height: 64px width: auto # auto, max effect: [shadow, floatable, blur] # [shadow, floatable, blur]#滚动条 scrollbar: size: 10px border: 2px color: &#x27;#2196f3&#x27; hover: &#x27;#ff5722&#x27;#字体 fontfamily: bodyfont: fontfamily: &#x27;OPPO-Sans&#x27; name: &#x27;OPPO-Sans&#x27; url: /fonts/OPPO-Sans.ttf codefont: fontfamily: &#x27;JetBrainsMono-Bold&#x27; name: &#x27;JetBrainsMono-Bold&#x27; url: /fonts/JetBrainsMono-Bold.ttf source需要的文件123456789101112├── about│ └── index.md├── categories│ └── index.md├── fonts│ ├── JetBrainsMono-Bold.ttf│ ├── OPPO-Sans.ttf│ └── WenQuanYiZenHei.ttf├── _posts│ └── source└── tags └── index.md 新建上述目录结构 about&#x2F;index.md 123456789101112131415161718192021---layout: docsseo_title: 关于bottom_meta: falsesidebar: []twikoo: placeholder: 有什么想对我说的呢？---&#123;% btns circle center grid5 %&#125;&lt;a&gt;&lt;img src=&#x27;https://s3.bmp.ovh/imgs/2025/03/03/30639e1f0584064f.jpg&#x27;&gt;&lt;b&gt;tutulp&lt;/b&gt;&lt;/a&gt;&#123;% endbtns %&#125;从此天边尽沉云， 风卷残阳没旧痕邮箱：n199m992@163.comQQ：2061867903github：https://github.com/tutuLPgitee：https://gitee.com/tutuLP categories&#x2F;index.md 12345---layout: categoryindex: truetitle: 所有分类--- tags&#x2F;index.md 12345---layout: tagindex: truetitle: 所有标签--- fonts存放字体文件，在yml配置文件中使用eg：&#x2F;fonts&#x2F;JetBrainsMono-Bold.ttf需要使用图片的时候也可以这样放和引用 参考链接主题volantis：https://volantis.js.org/v6/getting-started/ ImgURL免费图床：https://www.imgurl.org/vip/manage 评论系统：https://artalk.js.org/ 简历博客：https://resume.js.org/zh-cn/ 参考美化教程：https://busyogg.github.io/article/38effc2a84e9/ 优秀博客：https://inkss.cn/ npm图床：https://xingpingcn.top/npm%E5%9B%BE%E5%BA%8A%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%EF%BC%89.html","categories":[{"name":"工具-环境","slug":"工具-环境","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://example.com/tags/Node-js/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"大作业","slug":"source/大作业","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/大作业/","permalink":"http://example.com/2025/03/02/source/%E5%A4%A7%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"决策树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465!ls /home/aistudio/data!ls /home/aistudio!mkdir /home/aistudio/external-libraries!pip install beautifulsoup4 -t /home/aistudio/external-librariesimport sys sys.path.append(&#x27;/home/aistudio/external-libraries&#x27;)#加载库和文件import pandas as pd from sklearn.preprocessing import LabelEncoderfrom sklearn.model_selection import train_test_splitfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import f1_score# 读取数据train_data = pd.read_csv(&#x27;train_set.csv&#x27;)test_data = pd.read_csv(&#x27;test_set.csv&#x27;)# 删除缺失值train_data.dropna(inplace=True)test_data.dropna(inplace=True)# 编码非数值特征label_encoders = &#123;&#125;for column in train_data.select_dtypes(include=[&#x27;object&#x27;]).columns: if column != &#x27;is_fraud&#x27;: le = LabelEncoder() # 在合并数据上拟合编码器以确保一致性 combined_data = pd.concat([train_data[column], test_data[column]], axis=0) le.fit(combined_data) train_data[column] = le.transform(train_data[column]) test_data[column] = le.transform(test_data[column]) label_encoders[column] = le # 特征工程：选择相关特征features = train_data.drop(&#x27;is_fraud&#x27;, axis=1).columnsX = train_data[features]y = train_data[&#x27;is_fraud&#x27;]# 划分训练集和验证集X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)# 训练模型model = RandomForestClassifier(random_state=42)model.fit(X_train, y_train)# 预测验证集y_pred = model.predict(X_val)# 计算F1值f1 = f1_score(y_val, y_pred)print(f&#x27;F1 Score: &#123;f1&#125;&#x27;)# 预测测试集# 确保特征顺序一致test_features = test_data[features]# 预测测试集test_predictions = model.predict(test_features)# 生成结果文件output = pd.DataFrame(&#123;&#x27;Index&#x27;: test_data[&#x27;index&#x27;], &#x27;is_fraud&#x27;: test_predictions&#125;)output.to_csv(&#x27;202231060621.csv&#x27;, index=False)F1 Score: 0.7398843930635838 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 加载库import pandas as pdfrom sklearn.preprocessing import OrdinalEncoder, StandardScalerfrom sklearn.model_selection import train_test_split, GridSearchCVfrom sklearn.linear_model import LogisticRegressionfrom sklearn.metrics import f1_score# 读取数据train_data = pd.read_csv(&#x27;train_set.csv&#x27;)test_data = pd.read_csv(&#x27;test_set.csv&#x27;)# 删除缺失值train_data.dropna(inplace=True)test_data.dropna(inplace=True)# 编码非数值特征ordinal_encoders = &#123;&#125;categorical_cols = train_data.select_dtypes(include=[&#x27;object&#x27;]).columns.drop(&#x27;is_fraud&#x27;)for column in categorical_cols: oe = OrdinalEncoder() combined_data = pd.concat([train_data[[column]], test_data[[column]]], axis=0) oe.fit(combined_data) train_data[column] = oe.transform(train_data[[column]]) test_data[column] = oe.transform(test_data[[column]]) ordinal_encoders[column] = oe# 特征工程：选择相关特征features = train_data.drop(&#x27;is_fraud&#x27;, axis=1).columnsX = train_data[features]y = train_data[&#x27;is_fraud&#x27;]# 特征缩放scaler = StandardScaler()X = scaler.fit_transform(X)test_data_scaled = scaler.transform(test_data[features])# 划分训练集和验证集X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)# 使用网格搜索调整超参数param_grid = &#123; &#x27;C&#x27;: [0.01, 0.1, 1, 10, 100], &#x27;solver&#x27;: [&#x27;liblinear&#x27;, &#x27;saga&#x27;]&#125;grid_search = GridSearchCV(LogisticRegression(random_state=42), param_grid, scoring=&#x27;f1&#x27;, cv=5)grid_search.fit(X_train, y_train)# 输出最佳参数print(f&#x27;Best Parameters: &#123;grid_search.best_params_&#125;&#x27;)# 使用最佳参数训练模型best_model = grid_search.best_estimator_best_model.fit(X_train, y_train)# 预测验证集y_pred = best_model.predict(X_val)# 计算F1值f1 = f1_score(y_val, y_pred)print(f&#x27;F1 Score: &#123;f1&#125;&#x27;)# 预测测试集test_predictions = best_model.predict(test_data_scaled)# 生成结果文件output = pd.DataFrame(&#123;&#x27;Index&#x27;: test_data[&#x27;index&#x27;], &#x27;is_fraud&#x27;: test_predictions&#125;)output.to_csv(&#x27;202231060621.csv&#x27;, index=False) 12345678910111213141516171819202122232425262728293031323334from sklearn.ensemble import GradientBoostingClassifierfrom sklearn.model_selection import GridSearchCV, cross_val_score# 使用Gradient Boostinggb_model = GradientBoostingClassifier(random_state=42)# 网格搜索优化超参数param_grid = &#123; &#x27;n_estimators&#x27;: [100, 200], &#x27;max_depth&#x27;: [3, 5], &#x27;learning_rate&#x27;: [0.01, 0.1]&#125;grid_search = GridSearchCV(gb_model, param_grid, cv=5, scoring=&#x27;f1&#x27;)grid_search.fit(X_train, y_train)# 使用最佳参数训练模型best_model = grid_search.best_estimator_best_model.fit(X_train, y_train)# 验证集预测y_pred = best_model.predict(X_val)# 计算F1值f1 = f1_score(y_val, y_pred)print(f&#x27;Optimized F1 Score: &#123;f1&#125;&#x27;)# 测试集预测test_predictions = best_model.predict(test_features)# 生成结果文件output = pd.DataFrame(&#123;&#x27;Index&#x27;: test_data[&#x27;index&#x27;], &#x27;is_fraud&#x27;: test_predictions&#125;)output.to_csv(&#x27;optimized_results.csv&#x27;, index=False)","categories":[{"name":"杂说","slug":"杂说","permalink":"http://example.com/categories/%E6%9D%82%E8%AF%B4/"}],"tags":[]},{"title":"闭关一年","slug":"source/闭关一年","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/闭关一年/","permalink":"http://example.com/2025/03/02/source/%E9%97%AD%E5%85%B3%E4%B8%80%E5%B9%B4/","excerpt":"","text":"生死看淡 不服就干写在前面 今天10.30 昨天是小米15和澎湃os2的发布会，开场就是金凡的闭关一年，所以我头脑一热也搞一个闭关一年，主要是感觉最近确实没怎么进步，不过，也没关系，雷军都说大学该玩就玩，说不定以后我也能挤进管理岗，故，仅以此篇来记录我一年的日记和成长过程，望不负青春。 还有，不要追新剧或者新动漫，堆几十集放在一起又想熬夜一直看，所以不如每天等更新，切记晚上不要刷抖音 10.30 计划开始的前一夜 c盘是真爆满，能不能别分盘或者新机就把c盘分大一点，所有软件都装在d盘的也一样爆满 卸载软件的时候发现steam头像被换成了。。。，真的别在网吧登steam，真得被盗号 10.31 计划：完成连接池的设计并完成测试 先完成测试demo的运行 1:01 使用Cmake链接thread和mysql并运行demo成功 …..饿了 分析测试程序流程 使用python脚本自动git push 添加到环境变量方便cmd中直接运行 11.1-11.3 过生日去了 计划中道崩殂，且11.3日晚失眠到凌晨4点半，天，太恐怖了，可能是下雨加上异响 11.4 主线：完成连接池 副线：学习智能指针，lambda表达式，std::bind，RALL机制 运行demo数据库一直没弄好 11.5 11.6这两天一直在写学校机器学习的大作业 11.7 摆烂 11.8 休息 11.9 主线：把帮学校老师做的微信小程序bug修复了 + 有限状态机 支线：重装系统(C盘无法拯救) + 购买一张流量卡(选了一张24元100G的) 轮播图数目问题 现在是请求的一页三张，数据库有5张，我看能不能作成五张，没用问题，那就做成有多少张就做多少张，10张上限 新闻标题格式化问题 设置标题最多16个字，超出的部分设置为… 成功 more新闻部分 格式化问题 + 分页问题 直接GPT解决 令牌2小时过期问题 定期实现自动退出功能 在登录之后保存时间戳到内存中,App.vue中实现定期检查这个时间戳,然后触发退出登录的逻辑 ai的web socket问题 今天把王者荣耀卸载了，不能用我的手机来干这事，耽误我，加油！ 11.10 主线：测试http连接 支线：学校计组的实验作业 找一下公司出去团建的地点：这活居然交给我了，就要轻易在群里回答领导的问题！ 11.11 主线：梳理Tinywebserver流程 看了一些，今天又失眠了 11.12 早上去公司下雨了，走到楼下又不想回去拿伞，结果淋着雨去的，难受，晚上还加班，物理机上安装华为的欧拉操作系统，测试高斯数据库，还有阿里和华为的 10点下班回来继续梳理，绘制一下流程图，感觉差不多都理解了 11.13 自己梳理了一下完整的tinywebserver的流程 我觉得可用做到更好 现在的逻辑是一个线程池靠队列来处理收到的数据和发送数据，那池子满了就只有等待，而且现在默认是8个线程，fd完成状态转变则释放线程资源，其实也可以 完成时间堆 11.14 封装epoller 明日计划：深度理解触发模式和注册事件的区别，并实际应用，计划顺延，周五应该会玩 11.15周五 和女朋友一起玩 11.16-11.17 玩+准备17的技术经济考试 17号晚上，彻夜难眠，屋漏偏逢连夜雨，这出租屋不知道什么东西一直响，下雨吹风就这样，烦 11.18 休息 后面准备计算机组成原理考试和IT项目管理的大作业 11.30 周六 完成计算机组成考试和IT项目管理的大作业 12.5 今天实习结束了办理了离职，前几天一直忙着搬运东西，思考下一步的计划。电脑恢复初始化(因为C盘满了?，本来清空D盘然后合盘就解决的事情，但是之前vmware下载在d盘的导致安装不成功，就算我插上u盘修改为d盘，其他软件也有各种各样的残留问题，真的我觉得windows上各个软件设计的low爆了，昨天晚上重装之后发现天塌了，我谷歌浏览器上的书签一个也没有了，应该是之前没有选择同步? 接下来的计划： 1.每天至少2-3道题 2. 手写操作系统 3. 做一个完整的web服务器 4. 完成分布式课程 5. 完善技术栈，阅读源码诸如redis 刷题 12.6 今天收拾屋子然后把东西搬回学校，刷题先欠着，晚上整理了一下递归的思路 刷题 1- [ ] 刷题 12.7 刷了一道题 12.8 出去玩了一天 12.9 学习+学校作业，为啥总是忘记刷题，以后把刷题放到每天第一位 12.10 刷题 生产者消费者模型的阻塞队列 12.11 完成操作系统环境搭建 刷题 12.14 写学校的作业，前端，我直接使用v0 ai一个 刷题 今天6道把前两天的补上 12.15 今天出去玩了，回来写了作业 目前欠6道 12.16 刷题 12.17 刷题 12.18-19 完成课程油气田的前端 12.20-22 出去玩 20251月1.14 截至目前，经过漫长的期末考试准备，以其中一科60的成绩全部通过，但是不知道为啥最近一直头晕，去过医院也不知道什么原因，难受，不知道是不是颈椎或者脊椎的原因 现在恢复学习吧 1.15 感觉搁置那么久没有刷题之前积累的思路都没了 刷题 1道，整理完dfs思路 2月2.27 最近都没有写日志，寒假确实也啥也没做，就看了一点手写操作系统，目前没什么实用，投的字节的简历也没过，现在就先准备面试然后后面打算搞QT","categories":[{"name":"杂说","slug":"杂说","permalink":"http://example.com/categories/%E6%9D%82%E8%AF%B4/"}],"tags":[]},{"title":"LeetCode算法总结","slug":"source/刷题/LeetCode专题","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/刷题/LeetCode专题/","permalink":"http://example.com/2025/03/02/source/%E5%88%B7%E9%A2%98/LeetCode%E4%B8%93%E9%A2%98/","excerpt":"","text":"#链表 总结递归 链表方向转换+nullptr不断向前+尾节点成为头节点 123456789101112class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return newHead; &#125;&#125;; 栈(vector+rbegin+rend 或 stack) 其中变式题穿插双指针 反转链表###206 反转链表 第一遍自解 耗时0ms 123456789101112131415161718192021class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; //遍历两遍，第一遍依次取出节点的值然后放入栈中，第二遍从栈中拿出元素构建链表 int i=0; vector&lt;int&gt; tempList; ListNode * tempHead=head; while(tempHead!= nullptr)&#123;//注意这里不是tempHead-&gt;next tempList.push_back(tempHead-&gt;val); tempHead=tempHead-&gt;next; i++; &#125; tempHead=head;//这里犯错了，用tempHead来移动，不要用head for (auto it = tempList.rbegin(); it != tempList.rend(); ++it) &#123; tempHead-&gt;val=(*it); tempHead=tempHead-&gt;next; &#125; return head; &#125;&#125;; 这里使用satck是一样的效果 stack st; st.push(); while (!st.empty()) st.top(); st.pop(); ####递归实现 递归思路 递归到最深处再依次返回，递归到末尾然后指针指向的顺序调转 终止条件：递归到链表的末尾 递归到最深处返回的head(链表的尾节点)就是反转完的链表的头节点，作为newhead返回，递归回来的时候，指针方向不断反转，nullptr被不断往前移动，最终移动到反转前的头节点的下一位 12345678910111213class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; //终止条件 最后一个节点最先满足终止条件head-&gt;next == nullptr，返回最后一个节点 return head; &#125; // 递归反转子链 ListNode* newHead = reverseList(head-&gt;next); // head-&gt;next-&gt;next = head; //执行逻辑 最后一个节点触发return head;所以此时head是倒数第二个节点 head-&gt;next = nullptr; return newHead; &#125;&#125;; 终止条件只看一次，返回值返回后就不会变一直传递到最后 作为最终的返回 执行逻辑 最后一个节点触发终止条件返回，执行逻辑则从第四个节点开始到第一个节点 ####一个循环 也就是声明三个变量，当前遍历的节点，上一个和下一个节点? 123456789101112131415161718class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* pre = nullptr; auto cur = head; auto next = head-&gt;next; while(next) &#123; cur-&gt;next = pre; pre = cur; cur = next; next = next-&gt;next; &#125; cur-&gt;next = pre; return cur; &#125;&#125;; ###92 反转链表 给出头指针和两个位置，将两个位置之间的节点反转 第一遍自解 0ms 我的思路：找到区间起点记录指针到终点依次压栈然后再拿出来 123456789101112131415161718192021222324252627282930313233class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; if(head==nullptr)&#123; return head; &#125; stack&lt;int&gt; st; ListNode * tempHead = head; ListNode * leftNode; int index=1; int temp=0; while(tempHead!=nullptr)&#123; if(index==left)&#123; leftNode=tempHead; temp=1; &#125; if(temp==1)&#123; st.push(tempHead-&gt;val); &#125; if(index==right)&#123; break; &#125; tempHead=tempHead-&gt;next; index++; &#125; while(!st.empty())&#123; leftNode-&gt;val=st.top(); st.pop(); leftNode=leftNode-&gt;next; &#125; return head; &#125;&#125;; ####递归实现 双递归 思路：为了简化递归操作，反转a，b之间的节点修改为反转1到b-a+1之间的节点，对应递归起点后移多少位 12345678910111213141516171819202122class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; // 基本情况 if (left == 1) &#123; return reverseN(head, right); &#125; // 前进到反转起点 head-&gt;next = reverseBetween(head-&gt;next, left - 1, right - 1); return head; &#125; private: ListNode* successor = nullptr;//用于记录right的下一个节点 ListNode* reverseN(ListNode* head, int n) &#123; if (n == 1) &#123; successor = head-&gt;next; return head; &#125; ListNode* newHead = reverseN(head-&gt;next, n - 1); head-&gt;next-&gt;next = head; &#125;&#125;; ###25 k个一组翻转链表 自解 0ms 设置一个循环，终止条件是到达末尾，每次指针往后移动，对k取模，为0则传入当前指针和k进行反转(压栈)，反转时只对节点的值进行操作指针结构没有破坏 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; //判空 if(head==nullptr)&#123; return head; &#125; //移动，根据条件调用函数 auto temp = head; int count = 0; while(temp-&gt;next!=nullptr)&#123; //取余 调用函数-代表遍历了k个节点 if(count%k==0)&#123; //调用函数 reserve(temp,k); &#125; temp=temp-&gt;next; count++; &#125; return head; &#125; private: void reserve(ListNode* head,int k)&#123; auto temp = head; stack&lt;int&gt; st; int sum = k; while(sum)&#123; sum--; if(temp==nullptr)&#123; //当链表剩余不足k个直接返�? return; &#125; st.push(temp-&gt;val); temp=temp-&gt;next; &#125; temp = head; sum = k; while(sum)&#123; sum--; temp-&gt;val=(st.top()); st.pop(); temp=temp-&gt;next; &#125; &#125;&#125;; 一开始我用压栈的方式只是改变了值，但是定眼一看题目要求是改变指针的指向，那就要修改一下了 真正反转�? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (!head || k == 1) return head; // 创建虚拟头节�? ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; while (head) &#123; // 检查剩余节点是否足够k�? ListNode* tail = pre; for (int i = 0; i &lt; k; i++) &#123; tail = tail-&gt;next; if (!tail) &#123; return dummy-&gt;next; &#125; &#125; // 保存下一组的起始位置 ListNode* next = tail-&gt;next; // 反转k个节�? pair&lt;ListNode*, ListNode*&gt; result = reverseList(head, tail); head = result.first; tail = result.second; // 连接反转后的子链�? pre-&gt;next = head; tail-&gt;next = next; // 移动到下一�? pre = tail; head = next; &#125; ListNode* ret = dummy-&gt;next; delete dummy; return ret; &#125;private: // 反转链表，返回新的头和尾 pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, ListNode* tail) &#123; ListNode* prev = tail-&gt;next; ListNode* curr = head; while (prev != tail) &#123; ListNode* next = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = next; &#125; return &#123;tail, head&#125;; &#125;&#125;; ####递归 反转的递归思路 reverse传入 1-&gt;2-&gt;3-&gt;null 反转后 null&lt;-1&lt;-2&lt;-3 newhead移动到最后 null改为tail reverse传入 1(head)-&gt;2-&gt;3(cur)-&gt;tail tail&lt;-1(head)&lt;-2&lt;-3(cur) 3-&gt;2-&gt;1-&gt;tail 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; //判空 if(!head) return head; //cur是区间的最后一个节�? auto cur = head; for(int i = 0; i &lt; k-1; i++) &#123;//移动cur并判断剩余节点是否满足k个 if(!cur || !cur-&gt;next) return head; cur = cur-&gt;next; &#125; //next是区间最后一个节点的下一个节点 auto next = cur-&gt;next; reverse(head, next); //(head，null) head-&gt;next = reverseKGroup(next, k);//head节点经过反转已经变成最后一个节点 return cur;//返回的cur是第一个反转后的头或者没有经过反转的head &#125; ListNode* reverse(ListNode* head, ListNode* tail) &#123; if(head == tail || head-&gt;next == tail) return head; auto newHead = reverse(head-&gt;next, tail); head-&gt;next-&gt;next = head; head-&gt;next = tail; return newHead; &#125;&#125;; ###24 两两交换链表中的节点 &#x2F;&#x2F;这道题不就是k个一组把k换成了2吗 第一遍自解 0ms 递归 其实也可以不用swap函数，我只是为了与k个一组保持一致 返回的是当前区域的最后一个节点也就是反转之后的头节点，反转之后head变成了最后一个节点，所以head-&gt;next&#x3D;递归函数的返回值,不满足条件的都会在反转之前返回head 1234567891011121314151617181920212223class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; //判空 if(!head || !head-&gt;next) return head; //寻找当前区域的最后一个节点和尾节点 auto end=head-&gt;next; auto tail=end-&gt;next; swap(head,tail); head-&gt;next=swapPairs(tail); return end; &#125; ListNode* swap(ListNode*head,ListNode*tail)&#123; if(head==tail||head-&gt;next==tail)&#123; return head; &#125; auto temphead=swap(head-&gt;next,tail); head-&gt;next-&gt;next=head; head-&gt;next=tail; return temphead; &#125;&#125;; 删除链表元素###83 删除链表中的重复元素 常规遍历思路 12345678910111213141516171819202122class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return head; auto tempHead=head; int temp; while(tempHead-&gt;next)&#123; temp=tempHead-&gt;val; if(tempHead-&gt;next-&gt;val==temp)&#123; if(tempHead-&gt;next-&gt;next)&#123; tempHead-&gt;next=tempHead-&gt;next-&gt;next; //tempHead=tempHead-&gt;next; 如果下一个值与当前相同则还是在当前节点，避免连续相同 &#125;else&#123; tempHead-&gt;next=nullptr; &#125; &#125;else&#123; tempHead=tempHead-&gt;next; &#125; &#125; return head; &#125;&#125;; 可以用两个节点遍历不用辅助变量来减少代码量 82 删除排序链表中的重复元素 II第一遍自解 0ms 这里用的INT_MAX来避免与节点中的值重复，也可以换成循环中的临时变量，在判断有重复之后用一个while处理完所有重复 注意虚拟的节点用new 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* virtual_head = new ListNode(0); virtual_head-&gt;next=head; int tempnum=INT_MAX;//记录这个重复值 auto temphead=virtual_head;//用于遍历 while(temphead-&gt;next!=nullptr)&#123; if(temphead-&gt;next-&gt;next!=nullptr)&#123; if(temphead-&gt;next-&gt;val==temphead-&gt;next-&gt;next-&gt;val)&#123;//处理连续两个相同 tempnum=temphead-&gt;next-&gt;val; temphead-&gt;next=temphead-&gt;next-&gt;next-&gt;next; continue; &#125; &#125; if(temphead-&gt;next-&gt;val==tempnum)&#123;//处理连续三个相同 temphead-&gt;next=temphead-&gt;next-&gt;next; continue; &#125; temphead=temphead-&gt;next; &#125; return virtual_head-&gt;next; &#125;&#125;; 19 删除链表的倒数第N个节点遍历两遍，第一遍找出个数，第二便删除全部压栈，然后取出n+1个执行双指针(只用遍历一遍)：两个间隔为n，当前面的到头删除第一个指针的下一个节点 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 创建虚拟头节点 ListNode* dummy = new ListNode(0); dummy-&gt;next = head; // 定义快慢指针，都从虚拟头节点开始 ListNode* fast = dummy; ListNode* slow = dummy; // 快指针先移动n+1步 for(int i = 0; i &lt;= n; i++) &#123; if(fast == nullptr) return head; fast = fast-&gt;next; &#125; // 同时移动快慢指针，直到快指针到达末尾 while(fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; // 删除目标节点 slow-&gt;next = slow-&gt;next-&gt;next; // 获取新的头节点 ListNode* result = dummy-&gt;next; // 释放虚拟节点内存 delete dummy; return result; &#125;&#125;; 合并链表23 合并k个升序链表自解6ms 使用优先队列，最小值优先，这里是存储的节点值，可以直接改为存储节点 12345678910111213141516171819202122class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto tempHead=new ListNode(0); if(lists.empty()) return tempHead-&gt;next; //使用priority_queue的最小堆存储每一个节点 priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; proque; for(auto tempNode : lists)&#123; while(tempNode)&#123; proque.push(tempNode-&gt;val); tempNode=tempNode-&gt;next; &#125; &#125; auto temp=tempHead; while(!proque.empty())&#123; temp-&gt;next = new ListNode(proque.top()); proque.pop(); temp=temp-&gt;next; &#125; return tempHead-&gt;next; &#125;&#125;; 改为存储节点 3ms 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: struct CompareMyClass &#123; bool operator()(ListNode* lhs, ListNode* rhs) const &#123; return lhs-&gt;val &gt; rhs-&gt;val; &#125; &#125;; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto tempHead = new ListNode(0); if (lists.empty()) return tempHead-&gt;next; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, CompareMyClass&gt; proque; // 将所有链表的头节点入队 for (auto tempNode : lists) &#123; if (tempNode) proque.push(tempNode); &#125; auto temp = tempHead; while (!proque.empty()) &#123; auto current = proque.top(); proque.pop(); temp-&gt;next = current; // 拼接链表 temp = temp-&gt;next; if (current-&gt;next) &#123; proque.push(current-&gt;next); // 如果有后续节点，继续入队 &#125; &#125; return tempHead-&gt;next; &#125;&#125;; 树##前序遍历 144 二叉树的前序遍历看了思路后自解 关键是nums要声明在外面 123456789101112class Solution &#123;private: vector&lt;int&gt; nums;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(!root) return nums; nums.push_back(root-&gt;val); preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right); return nums; &#125;&#125;; 非递归实现根节点入栈-循环遍历栈-栈非空，取出节点-取出节点值-压入右节点-压入左节点 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(!root) return &#123;&#125;; stack&lt;TreeNode*&gt; q; // 栈 vector&lt;int&gt; ans; q.push(root); while(!q.empty()) &#123; auto front = q.top(); q.pop(); ans.push_back(front-&gt;val); if(front-&gt;right) q.push(front-&gt;right); if(front-&gt;left) q.push(front-&gt;left); &#125; return ans; &#125;&#125;; 112 路径总和难点：遍历的基础上回退的时候要撤销累加值 用两个栈，一个栈压入节点 另一个栈压入节点和 比如1 2 3 节点压入1 取出1 压入3，2 值压入1 取出1 压入1+3，1+2 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; //sum的值满足且没有左右孩子则返回true stack&lt;TreeNode*&gt; st; stack&lt;int&gt; sum; if(root)&#123; st.push(root); sum.push(root-&gt;val); &#125; while(!st.empty())&#123; auto tempNode=st.top(); st.pop(); int temp=sum.top(); sum.pop(); if(temp==targetSum &amp;&amp; !tempNode-&gt;left &amp;&amp; !tempNode-&gt;right) return true; if(tempNode-&gt;right)&#123; st.push(tempNode-&gt;right); sum.push(temp+tempNode-&gt;right-&gt;val); &#125; if(tempNode-&gt;left)&#123; st.push(tempNode-&gt;left); sum.push(temp+tempNode-&gt;left-&gt;val); &#125; &#125; return false; &#125;&#125;; 113 路径总和Ⅱ在上一题的基础上再加一个stack&lt;vector&gt; 与存储路径和的stack stnum;思路一致即可 17ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; vector&lt;vector&lt;int&gt;&gt; vv; if (!root) return vv; stack&lt;vector&lt;int&gt;&gt; v; v.push(vector&lt;int&gt;&#123;root-&gt;val&#125;); stack&lt;TreeNode*&gt; stnode; stnode.push(root); stack&lt;int&gt; stnum; stnum.push(root-&gt;val); while(!stnode.empty())&#123; auto tempNode=stnode.top(); stnode.pop(); int tempnum=stnum.top(); stnum.pop(); vector&lt;int&gt; currentPath = v.top(); v.pop(); if(!tempNode-&gt;left&amp;&amp;!tempNode-&gt;right)&#123; if(tempnum==targetSum) vv.push_back(currentPath); &#125; if(tempNode-&gt;right)&#123; stnode.push(tempNode-&gt;right); stnum.push(tempnum+tempNode-&gt;right-&gt;val); vector&lt;int&gt; rightPath = currentPath; rightPath.push_back(tempNode-&gt;right-&gt;val); v.push(rightPath); &#125; if(tempNode-&gt;left)&#123; stnode.push(tempNode-&gt;left); stnum.push(tempnum+tempNode-&gt;left-&gt;val); vector&lt;int&gt; leftPath = currentPath; leftPath.push_back(tempNode-&gt;left-&gt;val); v.push(leftPath); &#125; &#125; return vv; &#125;&#125;; 没有递归的效率高，优化：使用一个栈，减少赋值操作等 优化后的版本，仍然不是0ms，可见手动建栈效率不如递归栈的效率 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; tempPath; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (!root) return result; stack&lt;tuple&lt;TreeNode*, vector&lt;int&gt;, int&gt;&gt; stk; stk.push(&#123;root, &#123;root-&gt;val&#125;, root-&gt;val&#125;); while (!stk.empty()) &#123; auto [node, path, pathSum] = stk.top(); stk.pop(); if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; pathSum == targetSum) &#123; result.push_back(path); &#125; if (node-&gt;right) &#123; tempPath = path; tempPath.push_back(node-&gt;right-&gt;val); stk.push(&#123;node-&gt;right, tempPath, pathSum + node-&gt;right-&gt;val&#125;); &#125; if (node-&gt;left) &#123; tempPath = path; tempPath.push_back(node-&gt;left-&gt;val); stk.push(&#123;node-&gt;left, tempPath, pathSum + node-&gt;left-&gt;val&#125;); &#125; &#125; return result; &#125;&#125;; 递归123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; if(!root) return res; tmp.push_back(root-&gt;val); backtrack(root, targetSum-root-&gt;val); return res; &#125; void backtrack(TreeNode* root, int sum) &#123; if(sum == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123; res.push_back(tmp); return; &#125; if(root-&gt;left) &#123; tmp.push_back(root-&gt;left-&gt;val); backtrack(root-&gt;left, sum-root-&gt;left-&gt;val); tmp.pop_back(); &#125; if(root-&gt;right) &#123; tmp.push_back(root-&gt;right-&gt;val); backtrack(root-&gt;right, sum-root-&gt;right-&gt;val); tmp.pop_back(); &#125; &#125;&#125;; 更好理解的递归： accumulate函数计算vector的和 1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int targetSum, vector&lt;int&gt;&amp; currentPath, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123; if (!root) return; currentPath.push_back(root-&gt;val); // 加入当前节点到路径 // 如果到达叶节点并且路径和等于目标值 if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; accumulate(currentPath.begin(), currentPath.end(), 0) == targetSum) &#123; result.push_back(currentPath); &#125; // 递归访问左子树和右子树 dfs(root-&gt;left, targetSum, currentPath, result); dfs(root-&gt;right, targetSum, currentPath, result); // 回溯，移除当前节点 currentPath.pop_back(); &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; currentPath; dfs(root, targetSum, currentPath, result); return result; &#125;&#125;; ###437 路径总和 III 递归的时候使用减法可以减少一个变量的使用 开始的时候判空，则递归左右子树的时候无需判空 注意使用long long避免溢出 以每个节点为根节点分别遍历 12345678910111213141516class Solution &#123;public: int pathSum(TreeNode* root, int targetSum) &#123; if (!root) return 0; return dfs(root, (long long)targetSum) + pathSum(root-&gt;left, targetSum) + pathSum(root-&gt;right, targetSum); &#125; int dfs(TreeNode* root, long long targetSum) &#123; if (!root) return 0; int res = 0; if (root-&gt;val == targetSum) res++; res += dfs(root-&gt;left, targetSum - root-&gt;val); res += dfs(root-&gt;right, targetSum - root-&gt;val); return res; &#125;&#125;; 这样达不到0ms，因为有很多重复的遍历。所以使用前缀和 利用哈希表记录路径和的出现次数来避免重复计算 前缀和是从根节点到当前节点的路径和。用哈希表记录前缀和出现的次数，当当前节点的路径和减去targetSum的结果在哈希表中存在这个键则结果加上其对应的值 123456789101112131415161718192021class Solution &#123;public: unordered_map&lt;long long, int&gt; umap = &#123;&#123;0,1&#125;&#125;; //前缀和 出现的次数 int res = 0; void pathS(TreeNode* root, long long pre, int targetSum) &#123;//pre记录当前路径和 if (!root) return; pre += root-&gt;val; if (umap.count(pre-targetSum)) res += umap[pre-targetSum];//如果存在pre-targetSum=前缀和 umap[pre] ++; pathS(root-&gt;left, pre, targetSum); pathS(root-&gt;right, pre, targetSum); umap[pre] --;//一个节点的子节点都遍历完之后则在hashmap中移除这个前缀和 &#125; int pathSum(TreeNode* root, int targetSum) &#123; long long pre = 0; pathS(root, pre, targetSum); return res; &#125;&#125;; ###226 翻转二叉树 12345678910111213class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; //从底往上交换先交换1 3 6 9 再交换2 7 //所以使用递归从深处交换 if(!root) return root; if(!root-&gt;left&amp;&amp;!root-&gt;right) return root; invertTree(root-&gt;left); invertTree(root-&gt;right); swap(root-&gt;left,root-&gt;right); return root; &#125;&#125;; 257 二叉树的所有路径(就看这个)####递归版本 0ms 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt; result; string currentPath; void dfs(TreeNode* root, string&amp; currentPath, vector&lt;string&gt;&amp; result) &#123; if (!root) return; // 保存当前路径长度，用于回溯 int len = currentPath.length(); // 如果不是空路径，需要添加箭头 if (len &gt; 0) &#123; currentPath += &quot;-&gt;&quot;; &#125; currentPath += to_string(root-&gt;val); // 如果到达叶节点，将当前路径加入结果 if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; result.push_back(currentPath); &#125; // 递归访问左子树和右子树 dfs(root-&gt;left, currentPath, result); dfs(root-&gt;right, currentPath, result); // 回溯，将路径恢复到进入当前节点之前的状态 currentPath.resize(len); &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; dfs(root, currentPath, result); return result; &#125;&#125;; 使用全局的变量，减少递归时每次创建副本 从3ms优化到0ms 非递归版本0ms 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; result; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; if(!root) return result; stack&lt;pair&lt;TreeNode*, string &gt;&gt;stk; //存储节点(遍历) 路线 stk.push(&#123;root, &quot;&quot;&#125;); while (!stk.empty()) &#123; auto [node, path] = stk.top(); stk.pop(); if (!path.empty()) &#123; path += &quot;-&gt;&quot;; &#125; path += to_string(node-&gt;val); if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; result.push_back(path); &#125; if (node-&gt;right) &#123; stk.push(&#123;node-&gt;right, path&#125;); &#125; if (node-&gt;left) &#123; stk.push(&#123;node-&gt;left, path&#125;); &#125; &#125; return result; &#125;&#125;; 动态规划123456789101112131415# 自顶向下递归的动态规划def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result# 自底向上迭代的动态规划# 初始化 base casedp[0][0][...] = base case# 进行状态转移for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 64最小路径和状态转移方程 dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] 当前最小路径为&#x3D;以下两者的最小者：左边的最小路径加上当前值，上边的最小路径加上当前值 创建二维向量-&gt;初始化第一个元素-&gt;初始化第一行和第一列-&gt;公式推导 123456789101112131415161718192021222324class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size();//m行 int n = grid[0].size();//n列 vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = grid[0][0]; // 初始化第一行 for (int j = 1; j &lt; n; ++j) &#123; dp[0][j] = dp[0][j - 1] + grid[0][j]; &#125; // 初始化第一列 for (int i = 1; i &lt; m; ++i) &#123; dp[i][0] = dp[i - 1][0] + grid[i][0]; &#125; // 填充 dp 数组 for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; ##647回文子串 中心扩展法 遍历每个可能为中心的位置，一个为中心+两个为中心 1234567891011121314151617181920212223242526272829class Solution &#123;public: int countSubstrings(std::string s) &#123; int n = s.length(); int count = 0; // 遍历每个可能的中心位置 for (int i = 0; i &lt; n; ++i) &#123; // 以单个字符为中心扩展 int left = i, right = i; while (left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123; ++count; --left; ++right; &#125; // 以两个相邻字符为中心扩展 left = i; right = i + 1; while (left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123; ++count; --left; ++right; &#125; &#125; return count; &#125;&#125;; 动态规划 dp[i][j] 表示字符串从索引 i 到索引 j 的子串是否为回文串 分类讨论： i&#x3D;&#x3D;j 是 j-1&#x3D;i 如果s[i]&#x3D;&#x3D;s[j] j-1&gt;i s[i]&#x3D;=s[j] 且 dp[i+1][j-1]&#x3D;&#x3D;true 12345678910111213141516171819202122232425262728class Solution &#123;public: int countSubstrings(std::string s) &#123; int n = s.length(); std::vector&lt;std::vector&lt;bool&gt;&gt; dp(n, std::vector&lt;bool&gt;(n, false)); int count = 0; // 枚举子串的长度 for (int len = 0; len &lt; n; ++len) &#123; for (int i = 0; i &lt; n - len; ++i) &#123; int j = i + len; if (len == 0) &#123; dp[i][j] = true; &#125; else if (len == 1) &#123; dp[i][j] = (s[i] == s[j]); &#125; else &#123; dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]; &#125; if (dp[i][j]) &#123; ++count; &#125; &#125; &#125; return count; &#125;&#125;; ##518 零钱兑换Ⅱ valid[i]表示是否可以使用给定的硬币面额组合出金额 dp[i]表示凑齐i的组合数 初始化都为1 先检查是否能凑出目标金额，状态转移方程：valid[i] |&#x3D; valid[i - coin]; 计算组合数：dp[i] +&#x3D; dp[i - coin]; 123456789101112131415161718192021class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;int&gt; dp(amount + 1), valid(amount + 1); dp[0] = 1; valid[0] = 1; for (int&amp; coin : coins) &#123; for (int i = coin; i &lt;= amount; i++) &#123; valid[i] |= valid[i - coin]; &#125; &#125; if (!valid[amount]) return 0; for (int&amp; coin : coins) &#123; for (int i = coin; i &lt;= amount; i++) &#123; dp[i] += dp[i - coin]; &#125; &#125; return dp[amount]; &#125;&#125;; 12345678910111213class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;uint64_t&gt; dp(amount+1,0); dp[0]=1; for(int i=0;i&lt;coins.size();i++)&#123; for(int j=coins[i];j&lt;=amount;j++)&#123; dp[j]=dp[j]+dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125;; #二分查找 关键： int left &#x3D; 0, right &#x3D; nums.size() - 1; while(left &lt;&#x3D; right) mid &#x3D; left + (right - left) &#x2F; 2; left &#x3D; mid + 1; right &#x3D; mid - 1; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int binary_search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] == target) &#123; // 直接返回 return mid; &#125; &#125; // 直接返回 return -1;&#125;//找到 target 的最左侧索引int left_bound(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定左侧边界 right = mid - 1; &#125; &#125; // 判断 target 是否存在于 nums 中 // 此时 target 比所有数都大，返回 -1 if (left == nums.size()) return -1; // 判断一下 nums[left] 是不是 target return nums[left] == target ? left : -1;&#125;////找到 target 的最右侧侧索引int right_bound(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定右侧边界 left = mid + 1; &#125; &#125; // 此时 left - 1 索引越界 if (left - 1 &lt; 0) return -1; // 判断一下 nums[left] 是不是 target return nums[left - 1] == target ? (left - 1) : -1;&#125; 排除不在区间 1234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, target) &#123; int n = nums.size(); int l = 0, r = n - 1; while(l &lt; r) &#123; // 注意此时不能有等于了，因为我们这里是排除不可能区间 int mid = (l+r)/2; if(nums[mid] &lt; target) // 这里不能判断等于的情况，因为我们用的排除思维，只需要排除目标一定不在的元素区间 l = mid + 1; else r = mid; // 这是nums[mid] &gt;= target的情况，说明目标在mid及左边, 往左缩小 &#125; return nums[l] == target ? nums[l] : -1; // 退出循环，要么找到，要么没找到，如果找到的话，left和right都指向它了 &#125;&#125;; 回溯 DFS BFS695 岛屿的最大面积1234567891011121314151617181920212223242526class Solution &#123;public: int ans, cur; vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;//四个方向 int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(!grid[i][j]) continue; cur = 1; dfs(grid, i, j, m, n); ans = max(cur, ans); &#125; &#125; return ans; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int m, int n) &#123; grid[x][y] = 0;//遍历过的设为0 for(auto&amp; dir : dirs) &#123; int nx = dir[0]+x, ny = dir[1]+y;//周围四个方向坐标 if(nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || !grid[nx][ny]) continue;//满足任意情况会跳过这个循环 cur++; dfs(grid, nx, ny, m, n); &#125; &#125;&#125;;","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"QT","slug":"source/前端/Qt","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.388Z","comments":true,"path":"2025/03/02/source/前端/Qt/","permalink":"http://example.com/2025/03/02/source/%E5%89%8D%E7%AB%AF/Qt/","excerpt":"","text":"软件安装 下载安装包 https://download.qt.io/official_releases/online_installers/ windows版 换源安装 安装包拖进去-后面加https://mirrors.tuna.tsinghua.edu.cn/qt/ D:\\下载\\qt-unified-windows-x64-4.8.1-online.exe –mirror https://mirrors.tuna.tsinghua.edu.cn/qt/ –mirror https://mirror.nju.edu.cn/qt 上面那个源用不了了，我换了一个 安装指引 账号注册需要在邮箱中点击链接填写信息进行验证 不发送使用信息 按需选择插件 选择最后一个协议 后面需要安装插件时：根目录下会有一个维护程序，打开进行安装-同样需要换源 新建项目 Qt Widgets Application 项目名词 位置 构建系统-qmake Base class: QWidget 语言-无 减少警告 help - about plugins(关于插件) - c++ - 取消勾选clangcodemodel 运行项目(忽略) .pro文件是工程文件，qmake自动生成的用于生产makefile的配置文件 Qt的编译不能使用普通的make，先qmake预编译 工程目录下qmake -project创建.pro文件(比如hello.pro) .pro文件目录下使用qmake hello.pro (make)或qmake -tp vc hello.pro (nmake)生成makefile 然后调用make或nmake进行编译 我们使用的IDE所以不用手动操作了 使用技巧HTML解析QLabel *label = new QLabel(&quot;&lt;h2&gt;&lt;font color=&#39;red&#39;&gt;Hello&lt;/font&gt;, world!&lt;h2&gt;&quot;); GUI程序设计基础（暂时没整理）.pro文件是工程文件，qmake自动生成的用于生产makefile的配置文件 12345678910#include &lt;QApplication&gt; #include &lt;QLabel&gt; //头文件名也是类名int main(int argc, char *argv[]) &#123; QApplication app(argc, argv); //创建一个QApplication对象-管理应用程序级别的资源 QLabel *label = new QLabel(&quot;Hello, world!&quot;); //创建一个QLabel对象 label-&gt;show(); //使这个label可见，可以制定避免闪烁 return app.exec(); //将应用程序的控制权移交给Qt&#125; Qt的编译不能使用普通的make，先qmake预编译 工程目录下qmake -project 创建.pro文件(比如hello.pro) .pro文件目录下使用qmake hello.pro (make)或qmake -tp vc hello.pro (nmake) 生成makefile,然后调用make或nmake进行编译 我们使用的IDE所以不用手动操作了 修改一下 QLabel *label = new QLabel(&quot;&lt;h2&gt;&lt;font color=&#39;red&#39;&gt;Hello&lt;/font&gt;, world!&lt;h2&gt;&quot;); Qt也是支持HTML解析的 信号槽12345678910#include &lt;QtGui/QApplication&gt; #include &lt;QtGui/QPushButton&gt; int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QPushButton *button = new QPushButton(&quot;Quit&quot;); QObject::connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit())); button-&gt;show(); return a.exec(); &#125; #include &lt;QtWidgets&#x2F;QApplication&gt;#include &lt;QtWidgets&#x2F;QPushButton&gt; 替换开头的头文件才能用 QObject 是所有类的根。Qt 使用这个 QObject 实现了一个单根继承的 C++。它里面有一个 connect静态函数，用于连接信号槽。当一个按钮被点击时，它会发出一个 clicked 信号-&gt;执行实例a的quit函数 clicked()就是一个信号，而 quit()就是槽 组件布局这里使用了两个新的组件：QSpinBox 和 QSlider,以及一个新的顶级窗口 QWidget QSpinBox 是一个有上下箭头的微调器，QSlider 是一个滑动杆 123456789101112131415161718192021222324252627282930#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QWidget&gt;#include &lt;QtWidgets/QSpinBox&gt;#include &lt;QtWidgets/QSlider&gt;#include &lt;QtWidgets/QHBoxLayout&gt;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); QWidget *window = new QWidget; window-&gt;setWindowTitle(&quot;Enter your age&quot;);//设置窗口标题 QSpinBox *spinBox = new QSpinBox; QSlider *slider = new QSlider(Qt::Horizontal); spinBox-&gt;setRange(0, 130); //setRange函数设置值的范围 slider-&gt;setRange(0, 130); //信号槽链接 QObject::connect(slider, SIGNAL(valueChanged(int)), spinBox, SLOT(setValue(int))); QObject::connect(spinBox, SIGNAL(valueChanged(int)), slider, SLOT(setValue(int))); spinBox-&gt;setValue(35); QHBoxLayout *layout = new QHBoxLayout; //水平布局，按照从左到右的顺序进行添加? layout-&gt;addWidget(spinBox); //添加组件,链接的信号槽? layout-&gt;addWidget(slider); window-&gt;setLayout(layout);//设置layout成我们定义的那样 window-&gt;show(); return app.exec();&#125; Qt 一共有三种主要的 layout，分别是： QHBoxLayout- 按照水平方向从左到右布局； QVBoxLayout- 按照竖直方向从上到下布局； QGridLayout- 在一个网格中进行布局，类似于 HTML 的 table。 API文档的使用左侧问好help里面就可以查看文档 第一个是帮助的帮助；第二个是 Qt Designer 的帮助；第三个是 Qt Linguist 的帮助；第四个是 QMake 的帮助;最后一个是 Qt 的 API 文档，在 QtCreator 中默认打开的就是这部分。 创建一个对话框头文件 123456789101112131415161718192021222324252627282930313233#ifndef FINDDIALOG_H #define FINDDIALOG_H #include &lt;QtWidGets/QDialog&gt; //声明类以免c++找不到class QCheckBox; class QLabel; class QLineEdit; class QPushButton; //FindDialog，继承自 QDialog?class FindDialog : public QDialog &#123; Q_OBJECT //这是一个宏,凡是定义信号槽的类都必须声明这个宏public: //声明构造和析构函数 FindDialog(QWidget *parent = 0); ~FindDialog(); signals: //关键字,定义信号,两个信号 void findNext(const QString &amp;str, Qt::CaseSensitivity cs); void findPrevious(const QString &amp;str, Qt::CaseSensitivity cs); private slots: //私有的两个槽,可以接收信号 void findClicked();//为了slots的定义，我们需要访问FindDialog的组件，因此，我们把其中的组件定义为成员变量以便访问 void enableFindButton(const QString &amp;text); private: QLabel *label; QLineEdit *lineEdit; QCheckBox *caseCheckBox; QCheckBox *backwardCheckBox; QPushButton *findButton; QPushButton *closeButton; &#125;; #endif // FINDDIALOG_H 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;QtWidGets&gt; #include &quot;finddialog.h&quot; FindDialog::FindDialog(QWidget *parent) //构造函数有参数初始化列表，用来调用父类的构造函数? : QDialog(parent) //所有使用了Q_OBJECT宏的类都自动具有tr()函数&#123; label = new QLabel(tr(&quot;Find &amp;what:&quot;)); //tr()全称QObject::tr(),被它处理的字符串可以使用工具提取出来翻译成其他语言 lineEdit = new QLineEdit; //字符串中的&amp;代表快捷键,会生成Find字符串,当你按下Alt+W的时候，这个按钮就相当于被点击 label-&gt;setBuddy(lineEdit); //当label获得焦点时,它的焦点会自动传给它的buddy(伙伴):lineEdit caseCheckBox = new QCheckBox(tr(&quot;Match &amp;case&quot;)); backwardCheckBox = new QCheckBox(tr(&quot;Search &amp;backford&quot;)); findButton = new QPushButton(tr(&quot;&amp;Find&quot;)); // alt+f findButton-&gt;setDefault(true); findButton-&gt;setEnabled(false); //把默认的按钮设为findButton,把findButton设为不可用 closeButton = new QPushButton(tr(&quot;Close&quot;)); //连接信号槽 connect()函数也是QObject的 connect(lineEdit, SIGNAL(textChanged(const QString&amp;)), this, SLOT(enableFindButton(const QString&amp;))); connect(findButton, SIGNAL(clicked()), this, SLOT(findClicked())); connect(closeButton, SIGNAL(clicked()), this, SLOT(close())); QHBoxLayout *topLeftLayout = new QHBoxLayout; topLeftLayout-&gt;addWidget(label); topLeftLayout-&gt;addWidget(lineEdit); QVBoxLayout *leftLayout = new QVBoxLayout; leftLayout-&gt;addLayout(topLeftLayout); leftLayout-&gt;addWidget(caseCheckBox); leftLayout-&gt;addWidget(backwardCheckBox); QVBoxLayout *rightLayout = new QVBoxLayout; rightLayout-&gt;addWidget(findButton); rightLayout-&gt;addWidget(closeButton); rightLayout-&gt;addStretch(); QHBoxLayout *mainLayout = new QHBoxLayout; mainLayout-&gt;addLayout(leftLayout); mainLayout-&gt;addLayout(rightLayout); setLayout(mainLayout); setWindowTitle(tr(&quot;Find&quot;)); //标题 setFixedHeight(sizeHint().height()); //固定高度 sizeHint()返回“最理想”的大小，这里我们使用的是 height()函数去到“最理想”的高度。&#125; FindDialog::~FindDialog() &#123; &#125; //槽void FindDialog::findClicked() &#123; QString text = lineEdit-&gt;text(); //取出输入值 Qt::CaseSensitivity cs = caseCheckBox-&gt;isChecked() ? Qt::CaseInsensitive : Qt::CaseSensitive;//判断caseCheckBox是否选中,选中则返回Qt::CaseInsensitive，否则返回 Qt::CaseSensitive if(backwardCheckBox-&gt;isChecked()) &#123; //如果 backwardCheckBox被选中，就 emit(发出)信号 findPrevious()，否则 emit信号 findNext emit findPrevious(text, cs); &#125; else &#123; emit findNext(text, cs); &#125; &#125; //enableFindButton()则根据 lineEdit 的内容是不是变化——这是我们的 connect 连接的——来设置findButton 是不是可以使用void FindDialog::enableFindButton(const QString &amp;text) &#123; findButton-&gt;setEnabled(!text.isEmpty()); &#125; main.cpp 1234567891011#include &lt;QApplication&gt;#include &quot;widget.h&quot;int main(int argc, char *argv[])&#123; QApplication app(argc, argv); FindDialog *dialog = new FindDialog; dialog-&gt;show(); return app.exec();&#125; 开始（没整理）widget.cpp:窗口属性,添加控件写在这个文件的构造函数中 修改窗口标题: 乱码:工具-选项-文本编辑器-行为-默认编码-UTF-8 设置窗口大小:可以拉伸&#x2F;不可拉伸 this-&gt;setWindowTitle(&quot;OpenChatRoom&quot;); this-&gt;resize(800,600); this-&gt;setFixedSize(500,500); 按钮 #include 1234567891011QPushButton *button=new QPushButton;//button-&gt;show(); 会在外面,没有嵌进去//设置按钮的父对象为窗口button-&gt;setParent(this);//合在一起QPushButton *button2=new QPushButton(&quot;Log In&quot;,this);//设置属性button-&gt;setText(&quot;Log In&quot;);button-&gt;move(400,500);//位置button-&gt;setFixedSize(100,50);//大小 信号与槽 12345678910111213141516171819202122232425262728293031323334353637383940//信号发出者，信号，信号接收者，接收信号后执行的任务（槽函数）connect(button,&amp;QPushButton::clicked,this,&amp;Widget::close);//点击关闭，自带的关闭和点击函数signals://信号，返回值void，可以有参数，可以重载 void hungery();public slots：//槽函数，返回值void，可以写到其他地方，可以有参数，需要声明并实现，可以重载 void treat(); void Student::treat()&#123; qDebug()&lt;&lt;&quot;请吃饭&quot;; &#125;//打印#inlcude&lt;QDebug&gt; qDebug()&lt;&lt;&quot; &quot;; //实现 //widget.h Teacher *tea; Student *stu; void ClassOver(); //widget.cpp this-&gt;tea=new Teacher(this);//指定父对象,回收时自动释放 this-&gt;stu=new Student(this); connect(tea,&amp;Teacher::hungry,stu,&amp;student::treat); ClaseOver();//触发信号void Widget::ClassOver()&#123; emit teacher-&gt;hungry(); //发出信号&#125;//点击按钮触发信号connect(button,&amp;QPushButton::clicked,this,&amp;Widget::ClassOver);//或者connect(button,&amp;QPushButton::clicked,tea,&amp;Widget::hungury);//重载，需要函数指针指向函数地址void hungery(QString food);//treat也有参数void Widget::ClassOver()&#123; emit teacher-&gt;hungry(&quot;abc&quot;); //发出信号&#125;void(Teacher::*a)(QString)=&amp;Teacher::hungury;void(Student::*b)(QString)=&amp;Student::treat;connect(tea,a,stu,b);ClassOver();//Qstring输出带有&quot;&quot;转化为不带 &lt;&lt;str.toUtf8().data();有空格,qDebug().nospace()&lt;&lt; 没有 自定义信号与槽 新建类继承于QObejct(槽函数全局,lambda除外) 槽函数可以比信号少,与信号参数顺序也需要一致 一个信号对应两个槽-&gt;登录-成功-失败 lambda表达式 ()里面可以写参数,省去写函数的部分,节省时间 12345QPushButton * b1=new QPushButton (&quot;点击&quot;,this); connect(b1,&amp;QPushButton::clicked,this,[=]()&#123; qDebug()&lt;&lt;&quot;按钮被按下&quot;; &#125; ); 记事本部件 ##资源文件 ctrl+n Qt-Qt source file-前缀&#x2F;-添加图片 可以起别名 12345QPixmap pix=QPixmap(&quot;:/image/d2.png&quot;).scaled(this-&gt;size());//设置大小 //pix.load(&quot;:/image/d2.png&quot;);//没有设置大小 QPalette palette; palette.setBrush(QPalette::Window,QBrush(pix));//QPalette::Background this-&gt;setPalette(palette); 给菜单项增加图片 增加背景图片 QMainWindow .ui ui 状态栏显示发送成功 对话框 123456789 QDialog dialog; dialog.setWindowTitle(tr(&quot;Hello&quot;)); dialog.exec();//模态对话框（只能操作对话框） dialog.show();//非模态对话框（不会阻塞） 一闪而过，这是在栈上创建的//在堆上创建 QDialog *dialog=new QDialog; dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);//自动销毁，不占用内存 dialog-&gt;setWindowTitle(tr(&quot;Hello&quot;)); dialog-&gt;show(); 标准对话框（内置） 12345QColorDialog 选择颜色QFileDialog 选择文件/目录QFontDialog 选择字体QInputDialog 允许用户输入一个值，并且返回QMessageBox 模态对话框，用于显示信息，询问问题等 按钮pushbutton plain text edit 文本编辑器 12345678//选择文件，并且输出文件地址void MainWindow::on_pushButton_clicked()&#123; QString fileName=QFileDialog::getOpenFileName(this,tr(&quot;打开文件&quot;),&quot;./&quot;,tr(&quot;Images(*.png *.xpm *.jpg);;Text(*.txt)&quot;)); if(!fileName.isEmpty())&#123; ui-&gt;plainTextEdit-&gt;appendPlainText(fileName); &#125;&#125; 选择多个文件p43 颜色对话框 12345678910void MainWindow::on_pushButton_2_clicked()&#123; QPalette pal=ui-&gt;plainTextEdit-&gt;palette();//获取现有palette QColor iniColor = pal.color(QPalette::Text);//现有文字颜色 QColor color= QColorDialog::getColor(iniColor,this,&quot;选择颜色&quot;); if(color.isValid())&#123; pal.setColor(QPalette::Text,color); ui-&gt;plainTextEdit-&gt;setPalette(pal);//设置编辑器文字颜色 &#125;&#125; 选择字体对话框 消息对话框 输入对话框 布局管理器绝对定位：需要提供组件长高，坐标 如果改变窗口大小，其位置大小不变-需要设置固定大小 布局定位：需要指定使用哪种布局 使用上方widget的布局 标签Label Line Edit 增加弹簧，并且水平布局 解除布局后可以进行调整 ##切换主界面 添加-Qt-Qt 设计师类-父类选择widget，就增加了一个ui #include “login.h” LogIn l;l.show(); 一下子展示两个页面 wiget.h中包含新界面的头文件 private中新建 LogIn *new_window; 12345this-&gt;new_window=new LogIn(); connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,[=]()&#123; this-&gt;hide(); this-&gt;new_window-&gt;show();//想要登录后释放之前的界面？ &#125;); 新界面返回主界面 12345678910//LogIn.hsignals: void back(void);//LogIn.cppconnect(ui-&gt;pushButton,SIGNAL(clicked(bool)),this,SIGNAL(back()));//wiget.cppconnect(this-&gt;new_window,&amp;LogIn::back,this,[=]()&#123; this-&gt;new_window-&gt;hide(); this-&gt;show(); &#125;); ##标签 #include 12QLabel *l=new QLabel(this);l-&gt;setText(&quot;这是OpenChatroom&quot;); 123456789101112131415#include &lt;QLineEdit&gt; QLineEdit *e=new QLineEdit(this); e-&gt;setText(&quot;请输入6位数字&quot;); //获取ui编辑框内的内容 QString str=ui-&gt;lineEdit-&gt;text; qDebug()&lt;&lt;str; //获取代码创建框内的内容 QString str=e-&gt;text(); qDebug()&lt;&lt;str;//设置输出模式 e-&gt;setEchoMode(QLineEdit::Password);//显示圆点 NoEcho//不显示 PasswordEchoEdit//正在输入时显示，输完不显示//设置输出左，上，右，下的距离 e-&gt;setTextMargins(0,0,0,0); 自定义控件-经常用到的页面进行展示 栈容器：点击一个菜单显示一个界面 事件鼠标按下，释放，移动 点击标签，做出动作deng 打包项目开发中用debug，但是发布时用release，会对项目进行优化 前提：配置qt环境变量D:\\App\\Qt\\6.2.4\\mingw_64\\bin 编译release版本，生成包-后缀为Release 打开Release文件-release-复制.exe文件到桌面一个新的文件夹里面 利用qt bin文件夹下的工具”D:\\App\\Qt\\6.2.4\\mingw_64\\bin\\windeployqt.exe”来找出程序需要的所有动态库 在新文件夹里面打开终端 D:\\App\\Qt\\6.2.4\\mingw_64\\bin\\windeployqt.exe .\\OpenChatRoom.exe 得到绿色版 下载打包工具Inno Setuphttp://www.jrsoftware.org/isdl.php#stable ok next-安装目录 打包程序的文件-next-next-next-next 安装包所在目录 安装包名称 图标位置(安装包的图标) 不要配置qt的环境变量,配置了在自己机器上面可运行,别的机器不能运行,找不到动态库：看缺哪些,去qt文件夹里面去搜索,把缺少的手动复制到需要打包的文件夹里面 不配置环境-&gt;桌面文件夹找全动态库-&gt;再打包安装包 如果没有找全就打包,可找全后直接打开保留的.iss文件运行一遍即可","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"}]},{"title":"TinyWebServer","slug":"source/后端/TinyWebServer","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/后端/TinyWebServer/","permalink":"http://example.com/2025/03/02/source/%E5%90%8E%E7%AB%AF/TinyWebServer/","excerpt":"","text":"git clone https://github.com/qinguoyi/TinyWebServer.git 准备mysql数据库 目前是在docker 容器mysql8 root 123456 1234567create database tynywebserver;USE tynywebserver;CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;INSERT INTO user(username, passwd) VALUES(&#x27;name&#x27;, &#x27;passwd&#x27;); sudo yum install mysql-devel sh build.sh 这里我连不上数据库因为它没有提供修改数据库端口的地方 -lmysqlclient","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[]},{"title":"Linux命令","slug":"source/Linux/Linux","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.386Z","comments":true,"path":"2025/03/02/source/Linux/Linux/","permalink":"http://example.com/2025/03/02/source/Linux/Linux/","excerpt":"","text":"命令 防火墙 查看防火墙状态 firewall-cmd –state 关闭防火墙 systemctl stop firewalld 查看端口信息 ss -tuln 查看所有端口 -t 表示TCP端口 -u 表示UDP端口 -l 表示仅显示监听状态的端口 -n 表示以数字形式显示地址和端口号，不尝试解析域名、服务名等 查看具体某个端口状态 ss -tuln | grep :80 显示当前目录123456ls -a 查看包括隐藏文件mkdir 新建文件夹 touch 新建文件rm 删除 rm -rf 删除文件夹 -rhistory 查看历史命令 mv a b a重命名为b或移动reboot 重启 系统编程shell编程使用#include 的system()函数 调用成功返回0 123456789101112#include &lt;cstdlib&gt; #include &lt;iostream&gt; using namespace std;int main() &#123; int result = system(&quot;ls -l&quot;); if (result == -1) &#123; cerr &lt;&lt; &quot;Failed to execute command\\n&quot;; &#125;else&#123; cout&lt;&lt;result&lt;&lt;endl; &#125; return 0; &#125; #include c的用法FILE结构体类型 123456789101112131415#include &lt;cstdio&gt; #include &lt;iostream&gt; int main() &#123; FILE *fp = popen(&quot;ls -l&quot;, &quot;r&quot;); if (fp == NULL) &#123; std::cerr &lt;&lt; &quot;Failed to run command\\n&quot;; return 1; &#125; char buffer[128]; while (fgets(buffer, 128, fp) != NULL) &#123; std::cout &lt;&lt; buffer; &#125; pclose(fp); return 0; &#125; 文件编程文件模式 同时读写模式时 先读后写，写会失败 不知道原因？？？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; //写文件int main() &#123; std::ofstream outFile(&quot;example.txt&quot;); // 创建并打开文件用于写入 if (!outFile) &#123; std::cerr &lt;&lt; &quot;Unable to open file for writing\\n&quot;; return 1; &#125; outFile &lt;&lt; &quot;Hello, fstream!\\n&quot;; // 写入字符串到文件 outFile.close(); // 关闭文件（虽然当ofstream对象被销毁时会自动关闭，但显式关闭是一个好习惯） return 0; &#125;//读文件int main() &#123; std::ifstream inFile(&quot;example.txt&quot;); // 打开文件用于读取 if (!inFile) &#123; std::cerr &lt;&lt; &quot;Unable to open file for reading\\n&quot;; return 1; &#125; std::string line; while (getline(inFile, line)) &#123; // 逐行读取文件 std::cout &lt;&lt; line &lt;&lt; &#x27;\\n&#x27;; &#125; inFile.close(); // 关闭文件 return 0; &#125;//同时读写int main() &#123; std::fstream file(&quot;example.txt&quot;, std::ios::in | std::ios::out | std::ios::app); // 打开文件，用于读写，并追加到文件末尾 if (!file) &#123; std::cerr &lt;&lt; &quot;Unable to open file\\n&quot;; return 1; &#125; // 读取文件内容（注意：如果文件很大，这可能不是最佳做法） std::string line; while (getline(file, line)) &#123; std::cout &lt;&lt; line &lt;&lt; &#x27;\\n&#x27;; &#125; // 回到文件末尾以追加内容 file.seekp(0, std::ios::end); file &lt;&lt; &quot;This is appended text.\\n&quot;; file.close(); // 关闭文件 return 0; &#125; 进程编程 创建 fork()函数来创建新进程 Unix&#x2F;Linux系统中用于创建进程的唯一方法 POSIX标准的一部分 原型 pid_t fork(void); 父进程得到子进程的PID 子进程得到0 失败得到一个负值 新进程是原进程的副本 子进程将复制父进程的内存空间(包括代码、数据、堆和栈等)、打开的文件描述符、环境变量等资源。 需要小心处理资源释放、文件描述符等问题，以避免资源泄露和竞态条件。 子进程与父进程共享代码段，但在进程空间中有自己的数据段和堆栈段。 &#x3D;&#x3D;pid_t pid &#x3D; fork();&#x3D;&#x3D; 父子进程都有pid这个变量，只是他们的值不一样 根据这个值控制他们的操作 父子进程关系： 子进程是父进程的副本，但在很多方面又是独立的。父子进程之间通常是异步执行的，它们的执行顺序不确定。 父子进程会同时执行下去，但操作系统会保证父进程先于子进程结束，以避免僵尸进程的产生。 典型应用场景： 服务器编程：常用于创建子进程处理客户端请求，父进程监听新的连接。 并行编程：通过fork()可以创建多个进程并行执行任务，实现并行计算。 123456789101112131415161718#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;iostream&gt; int main() &#123; pid_t pid = fork(); if (pid == -1) &#123; // 错误处理 std::cerr &lt;&lt; &quot;Fork failed&quot; &lt;&lt; std::endl; return 1; &#125; else if (pid == 0) &#123; // 子进程代码 std::cout &lt;&lt; &quot;I am the child process, PID: &quot; &lt;&lt; getpid() &lt;&lt; std::endl; &#125; else &#123; // 父进程代码 std::cout &lt;&lt; &quot;I am the parent process, PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot; Child PID: &quot; &lt;&lt; pid &lt;&lt; std::endl; &#125; return 0; &#125; 进程间通信IPC进程间通信（IPC）可以通过多种方式实现，包括管道（pipe）、命名管道（FIFO）、消息队列、信号量、共享内存以及套接字（sockets）等。 ####管道 父进程首先创建了一个管道，并通过fork()创建了一个子进程。然后，父进程关闭了管道的读端（fd[0]），而子进程关闭了管道的写端（fd[1]）。父进程通过管道的写端向子进程发送了一条消息，而子进程通过管道的读端接收这条消息。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; // 用于memset int main() &#123; int fd[2]; if (pipe(fd) == -1) &#123; std::cerr &lt;&lt; &quot;Pipe failed&quot; &lt;&lt; std::endl; return 1; &#125; pid_t pid = fork(); if (pid == -1) &#123; // fork失败 std::cerr &lt;&lt; &quot;Fork failed&quot; &lt;&lt; std::endl; close(fd[0]); close(fd[1]); return 1; &#125; else if (pid == 0) &#123; // 子进程 close(fd[1]); // 关闭写端 char buf[100]; ssize_t num_read = read(fd[0], buf, sizeof(buf) - 1); if (num_read &gt; 0) &#123; buf[num_read] = &#x27;\\0&#x27;; // 确保字符串以null终止 std::cout &lt;&lt; &quot;Child received: &quot; &lt;&lt; buf &lt;&lt; std::endl; &#125; close(fd[0]); &#125; else &#123; // 父进程 close(fd[0]); // 关闭读端 const char *message = &quot;Hello from parent!&quot;; write(fd[1], message, strlen(message) + 1); // 发送消息，包括结尾的null字符 close(fd[1]); wait(NULL); // 等待子进程结束 &#125; return 0; &#125; 进程同步进程同步通常用于控制多个进程之间的执行顺序，以避免竞争条件和数据不一致。可以使用信号量（semaphores）、互斥锁（mutexes）、条件变量（condition variables）等机制来实现同步。 进程的终止进程的终止可以通过多种方式实现，包括正常退出（通过return或exit()）、异常退出（如接收到信号）、父进程请求终止（如kill()函数）等。 kill(pid, SIGKILL); 放在上述父进程中可以杀死子进程，子进程就收不到消息了 进程等待父进程可以通过wait()或waitpid()函数等待子进程结束。这有助于父进程回收子进程的资源和状态信息。 多线程编程一个进程有多个线程 线程适合高并发和共享资源如 数据库操作，web服务 进程 独立 健壮 ###c++ 11 thread pthread听说很难用，我就不管了 g++ test.cpp -lpthread 在使用std::thread时，编译器需要将pthread库链接到可执行文件中。 ####构造函数 默认构造函数 thread() noexcept; 创建一个空的对象，不会抛出异常 初始化构造函数 template &lt;class Fn, class… Args&gt;explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args); class Fn：这是函数的类型参数，可以是函数指针、成员函数指针、函数对象（如std::function、lambda表达式、或任何重载了operator()的对象）等。 class… Args：这是一个可变参数模板，表示Fn函数所需的参数类型列表。…是C++11中引入的参数包扩展语法，允许函数模板接受任意数量和类型的参数。 thread线程会调用fn函数并将参数传递给这个函数 移动构造函数 thread(thread&amp;&amp; x) noexcept; 移动后x不代表任何执行对象 std::thread t4(std::move(t3)); thread t([]() &#123; cout &lt;&lt; &quot;Hello from lambda thread!&quot; &lt;&lt; endl; &#125;); t.join(); 123456789101112131415161718192021222324252627282930313233343536*注意：可被joinable的std::thread对象必须在他们销毁之前被主线程join或者将其设置为detached 空对象和被移动的对象不用*~~~c++#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;#include &lt;atomic&gt;void f1(int n)&#123; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; n &lt;&lt; &quot; executing\\n&quot;; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125;&#125;void f2(int&amp; n)&#123; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; &quot;Thread 2 executing\\n&quot;; ++n; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125;&#125;int main()&#123; int n = 0; std::thread t1; // t1 is not a thread std::thread t2(f1, n + 1); // pass by value std::thread t3(f2, std::ref(n)); // pass by reference std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread t2.join(); t4.join(); std::cout &lt;&lt; &quot;Final value of n is &quot; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;;&#125; thread执行带有引用参数的函数 thread传递参数以右值传递 如何传递左值？ std::ref 可以包装按引用传递的值。std::cref 可以包装按const引用传递的值。 赋值thread&amp; operator&#x3D;(thread&amp;&amp; rhs) noexcept; 当前对象不可 joinable，需要传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则会调用 terminate() 报错。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;chrono&gt; // std::chrono::seconds#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::sleep_forvoid thread_task(int n) &#123; std::this_thread::sleep_for(std::chrono::seconds(n)); std::cout &lt;&lt; &quot;hello thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; paused &quot; &lt;&lt; n &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;&#125;int main(int argc, const char *argv[])&#123; std::thread threads[5]; std::cout &lt;&lt; &quot;Spawning 5 threads...\\n&quot;; for (int i = 0; i &lt; 5; i++) &#123; threads[i] = std::thread(thread_task, i + 1); &#125; std::cout &lt;&lt; &quot;Done spawning threads! Now wait for them to join\\n&quot;; for (auto&amp; t: threads) &#123; t.join(); &#125; std::cout &lt;&lt; &quot;All threads joined.\\n&quot;; return EXIT_SUCCESS;&#125; 其他成员函数 join 阻塞当前线程，直到由 *this 所标示的线程执行完毕 join 才返回 get_id 线程ID 12std::thread t1(foo);std::thread::id t1_id = t1.get_id(); joinable 检查是否能被join t.joinable() 能返回1 不能返回0 默认构造的线程不能被join 某个线程 已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，因此也是可以被 join 的？？？ detach 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放 失去对这个线程的仍和控制权，也无法访问到 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;void independentThread() &#123; std::cout &lt;&lt; &quot;Starting concurrent thread.\\n&quot;; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout &lt;&lt; &quot;Exiting concurrent thread.\\n&quot;;&#125;void threadCaller() &#123; std::cout &lt;&lt; &quot;Starting thread caller.\\n&quot;; std::thread t(independentThread); t.detach(); std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout &lt;&lt; &quot;Exiting thread caller.\\n&quot;;&#125;int main() &#123; threadCaller(); std::this_thread::sleep_for(std::chrono::seconds(5));&#125; 上面这段函数如果没有t.detach(); 当threadCaller函数结束之后会销毁t，但是这个线程还在运行，所以要等待运行完成使用t.join() swap 交换两个线程的底层句柄 std::swap(t1, t2);t1.swap(t2); native_handle 返回 native handle 线程句柄，这个句柄允许直接访问和操作 操作系统底层的线程对象 thread是包装过的，这里返回后可以使用怕pthread库中的函数，如改变线程优先级，设置线程属性等 12345678910111213141516171819202122232425262728#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;cstring&gt;#include &lt;pthread.h&gt;std::mutex iomutex;void f(int num)&#123; std::this_thread::sleep_for(std::chrono::seconds(1)); sched_param sch; int policy; pthread_getschedparam(pthread_self(), &amp;policy, &amp;sch); std::lock_guard&lt;std::mutex&gt; lk(iomutex); std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; num &lt;&lt; &quot; is executing at priority &quot; &lt;&lt; sch.sched_priority &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123; std::thread t1(f, 1), t2(f, 2); sched_param sch; int policy; pthread_getschedparam(t1.native_handle(), &amp;policy, &amp;sch); sch.sched_priority = 20; if(pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &amp;sch)) &#123; std::cout &lt;&lt; &quot;Failed to setschedparam: &quot; &lt;&lt; std::strerror(errno) &lt;&lt; &#x27;\\n&#x27;; &#125; t1.join(); t2.join();&#125; std::this_thread 命名空间中相关辅助函数 get_id: 获取线程 ID。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;mutex&gt;std::mutex g_display_mutex;void foo()&#123; std::thread::id this_id = std::this_thread::get_id(); g_display_mutex.lock(); std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; this_id &lt;&lt; &quot; sleeping...\\n&quot;; g_display_mutex.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1));&#125;int main()&#123; std::thread t1(foo); std::thread t2(foo); t1.join(); t2.join();&#125; yield: 当前线程放弃执行，操作系统调度另一线程继续执行。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;// &quot;busy sleep&quot; while suggesting that other threads run // for a small amount of timevoid little_sleep(std::chrono::microseconds us)&#123; auto start = std::chrono::high_resolution_clock::now(); auto end = start + us; do &#123; std::this_thread::yield(); &#125; while (std::chrono::high_resolution_clock::now() &lt; end);&#125;int main()&#123; auto start = std::chrono::high_resolution_clock::now(); little_sleep(std::chrono::microseconds(100)); auto elapsed = std::chrono::high_resolution_clock::now() - start; std::cout &lt;&lt; &quot;waited for &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count() &lt;&lt; &quot; microseconds\\n&quot;;&#125; sleep_until: 线程休眠至某个指定的时刻(time point)，该线程才被重新唤醒。 template&lt; class Clock, class Duration &gt;void sleep_until( const std::chrono::time_point&lt;Clock,Duration&gt;&amp; sleep_time ); sleep_for: 线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能比 sleep_duration 所表示的时间片更长。 123456789#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;int main()&#123; std::cout &lt;&lt; &quot;Hello waiter&quot; &lt;&lt; std::endl; std::chrono::milliseconds dura( 2000 ); std::this_thread::sleep_for( dura ); std::cout &lt;&lt; &quot;Waited 2000 ms\\n&quot;;&#125; ####多个线程操作同一变量 std::atomic和std::mutex 123456789101112131415161718#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int n = 0;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) n++;&#125;int main() &#123; thread th[100]; // 这里偷了一下懒，用了c++11的foreach结构 for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 这里我输出989816，理论上应该是1000000，因为多个线程同时访问n 一个线程将mutex锁住时，其它的线程就不能操作mutex，直到这个线程将mutex解锁 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;int n = 0;mutex mtx;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) &#123; mtx.lock(); n++; mtx.unlock(); &#125;&#125;int main() &#123; thread th[100]; for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; mutex还有一个函数bool try_lock() 尝试上锁，没有被锁则锁返回true，否则false mutex固然可以解决问题，但是会浪费很多时间 std::atomic 只需要把int n&#x3D;0改为atomic_int n &#x3D; 0;或atomic n &#x3D; 0; 原子操作是最小的且不可并行化的操作。 ###std::async thread可以快速、方便地创建线程，但在async面前，就是小巫见大巫了。async可以根据情况选择同步执行或创建新线程来异步执行，当然也可以手动选择。对于async的返回值操作也比thread更加方便。 async是一个函数 1234567891011#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;using namespace std;int main() &#123; async(launch::async, [](const char *message)&#123; cout &lt;&lt; message &lt;&lt; flush; &#125;, &quot;Hello, &quot;); cout &lt;&lt; &quot;World!&quot; &lt;&lt; endl; return 0;&#125; template &lt;class Fn, class… Args&gt;future&lt;typename result_of&lt;Fn(Args…)&gt;::type&gt;async (Fn&amp;&amp; fn, Args&amp;&amp;… args) 或 async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;… args); 同样地，传递引用参数需要std::ref或std::cref std::launch有2个枚举值和1个特殊值 枚举值：launch::async 0x1（1） 异步启动枚举值：launch::deferred 0x2（2） 在调用future::get、future::wait时同步启动（std::future见后文）特殊值：launch::async | launch::defereed 0x3（3） 同步或异步，根据操作系统而定 ####使用std::future获取线程的返回值 123456789101112131415#include &lt;iostream&gt;#include &lt;future&gt; // std::async std::futureusing namespace std;template&lt;class ... Args&gt; decltype(auto) sum(Args&amp;&amp;... args) &#123; // C++17折叠表达式 // &quot;0 +&quot;避免空参数包错误 return (0 + ... + args);&#125;int main() &#123; // 注：这里不能只写函数名sum，必须带模板参数 future&lt;int&gt; val = async(launch::async, sum&lt;int, int, int&gt;, 1, 10, 100); // future::get() 阻塞等待线程结束并获得返回值 cout &lt;&lt; val.get() &lt;&lt; endl; return 0;&#125; linux下报错，win下可以运行 我们定义了一个函数sum，它可以计算多个数字的和，之后我们又定义了一个对象val，它的类型是std::future，这里的int代表这个函数的返回值是int类型。在创建线程后，我们使用了future::get()来阻塞等待线程结束并获取其返回值。至于sum函数中的折叠表达式（fold expression），不是我们这篇文章的重点。 成员函数 一般：T get() 阻塞等待线程结束并获取返回值当类型为引用：R&amp; future&lt;R&amp;&gt;::get()当类型为void：void future::get() 若类型为void，则与future::wait()相同。只能调用一次。 void wait() const 阻塞等待线程结束 template &lt;class Rep, class Period&gt; future_status wait_for(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time) const; 等待rel_time 若在这段时间内线程结束则返回future_status::ready若没结束则返回future_status::timeout若async是以launch::deferred启动的，则不会阻塞并立即返回future_status::deferred 12345678910111213141516#include &lt;iostream&gt;#include &lt;future&gt;using namespace std;void count_big_number() &#123; // C++14标准中，可以在数字中间加上单引号 &#x27; 来分隔数字，使其可读性更强 for (int i = 0; i &lt;= 10&#x27;0000&#x27;0000; i++);&#125;int main() &#123; future&lt;void&gt; fut = async(launch::async, count_big_number); cout &lt;&lt; &quot;Please wait&quot; &lt;&lt; flush; // 每次等待1秒 while (fut.wait_for(chrono::seconds(1)) != future_status::ready) cout &lt;&lt; &#x27;.&#x27; &lt;&lt; flush; cout &lt;&lt; endl &lt;&lt; &quot;Finished!&quot; &lt;&lt; endl; return 0;&#125; 搞懂这个就知道软件的加载画面怎么实现的了 std::promisec++ 11 获得thread的返回值 在一个线程中通过promise获取另一个线程的值 引用传递返回值 promise实际上是std::future的一个包装，在讲解future时，我们并没有牵扯到改变future值的问题，但是如果使用thread以引用传递返回值的话，就必须要改变future的值，那么该怎么办呢？实际上，future的值不能被改变，但你可以通过promise来创建一个拥有特定值的future。 future的值不能改变，promise的值可以改变。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt; // std::promise std::futureusing namespace std;template&lt;class ... Args&gt; decltype(auto) sum(Args&amp;&amp;... args) &#123; return (0 + ... + args);&#125;template&lt;class ... Args&gt; void sum_thread(promise&lt;long long&gt; &amp;val, Args&amp;&amp;... args) &#123; val.set_value(sum(args...));//通过调用promise对象的set_value()或set_exception()方法来设置值或异常&#125;int main() &#123; promise&lt;long long&gt; sum_value; thread get_sum(sum_thread&lt;int, int, int&gt;, ref(sum_value), 1, 10, 100); cout &lt;&lt; sum_value.get_future().get() &lt;&lt; endl;//通过调用promise对象的get_future()方法来获取一个future 对象 get_sum.join(); //调用future对象的get()方法来获取设置的值。如果promise设置了异常，get()方法将重新抛出该异常。 return 0;&#125;//111 使用 std::promise 和 std::future 时，应确保在调用 get() 方法之前，set_value() 或 set_exception() 已经被调用，否则 get() 方法将阻塞等待值的到来。 ###std::this_thread c++11 的一个命名空间 实现线程对自己的控制 函数 std::thread::id get_id() noexcept 获取当前线程id template&lt;class Rep, class Period&gt;void sleep_for( const std::chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration ) 等待sleep_duration 一段时间 void yield() noexcept 暂时放弃线程的执行，将主动权交给其他线程 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;atomic_bool ready = 0;// uintmax_t ==&gt; unsigned long longvoid sleep(uintmax_t ms) &#123; this_thread::sleep_for(chrono::milliseconds(ms));&#125;void count() &#123; while (!ready) this_thread::yield(); for (int i = 0; i &lt;= 20&#x27;0000&#x27;0000; i++); cout &lt;&lt; &quot;Thread &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot; finished!&quot; &lt;&lt; endl; return;&#125;int main() &#123; thread th[10]; for (int i = 0; i &lt; 10; i++) th[i] = thread(::count); sleep(5000); ready = true; cout &lt;&lt; &quot;Start!&quot; &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) th[i].join(); return 0;&#125; c++20 std::jthread ###线程同步 避免竞态条件（Race Condition）和数据访问冲突等问题。常见的线程同步机制包括互斥锁（Mutex）、条件变量（Condition Variable）、信号量（Semaphore）、读写锁（Read-Write Lock）等 ####原子 常用于实现锁、信号量、计数器等线程同步机制 std::atomic、std::atomic_flag等。 std::atomic atomicCounter(0); 无锁编程 需要注意避免一些常见的陷阱和错误，如ABA问题、内存重排等。 #####ABA问题 具体来说，ABA问题的发生可以分为以下步骤： 初始时刻，共享变量的值为A。 线程T1读取共享变量的值A，并进行一些操作。 在此过程中，另一个线程T2将共享变量的值从A修改为B，然后又将其修改回A，此时共享变量的值又变成了A。 线程T1继续执行，根据共享变量值是否为A做出判断，认为共享变量的值没有被修改，继续执行操作。 在这个过程中，虽然共享变量的值在T1执行期间被修改了，但T1并没有察觉到这一变化，因为它只关心共享变量的当前值是否为A。这种情况下，T1可能会基于错误的假设继续执行，导致程序出现逻辑错误或安全问题。 为了解决ABA问题，通常需要使用一些技术手段，如版本号、时间戳等，来辅助判断共享变量的值是否发生了变化。另外，一些数据结构，如无锁队列、无锁栈等，也会使用类似的技术来避免ABA问题的发生。 #####内存重排 内存重排包括两种类型的重排： 编译器重排：编译器可能会对代码进行优化，改变指令的执行顺序，但不会改变代码的语义。例如，编译器可能会将一些独立的指令重排以提高局部性或减少分支预测失败的可能性。 处理器重排：处理器在执行指令时，为了提高性能，可能会对指令进行乱序执行或者延迟执行。处理器会根据指令之间的数据依赖关系和相关性进行重排，以尽可能地利用处理器的各种功能单元，提高指令执行效率。 内存重排的存在使得在多线程编程中保证程序的正确性变得更加困难。为了避免内存重排导致的问题，通常需要使用同步原语（如互斥锁、原子操作、内存栅栏等）来保证指令的顺序一致性，以及使用volatile关键字来告诉编译器不要对指令进行重排。 ####条件变量 条件变量（Condition Variable）是一种线程同步机制，用于在线程间进行通信和同步。它允许一个线程在某个条件不满足时等待（阻塞），而另一个线程在满足条件时通知等待线程继续执行。条件变量通常与互斥锁（Mutex）一起使用，以确保线程之间的安全访问共享资源。 下面是条件变量的一般用法： 创建条件变量和互斥锁： 12std::condition_variable condVar; // 条件变量std::mutex mtx; // 互斥锁 等待条件： 等待线程在进入临界区之前先锁定互斥锁，然后调用wait方法等待条件变量满足： 12std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁condVar.wait(lock, []()&#123; return condition; &#125;); // 等待条件满足 唤醒等待线程： 唤醒线程在进入临界区之前先锁定互斥锁，然后调用notify_one或notify_all方法通知等待线程： 123std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁condition = true; // 修改条件condVar.notify_one(); // 唤醒等待线程 条件变量的使用可以帮助线程之间进行高效的同步和通信，避免了轮询等低效的等待方式。它常用于生产者-消费者模型、读者-写者模型等多线程编程场景中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;std::queue&lt;int&gt; dataQueue; // 共享数据队列std::mutex mtx; // 互斥锁std::condition_variable condVar; // 条件变量void producer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁 // 生产数据并放入队列 dataQueue.push(i); std::cout &lt;&lt; &quot;Produced data: &quot; &lt;&lt; i &lt;&lt; std::endl; &#125; // 在解锁前释放互斥锁 // 唤醒等待的消费者线程 condVar.notify_one(); // 模拟生产数据的间隔 std::this_thread::sleep_for(std::chrono::milliseconds(100)); &#125;&#125;void consumer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); // 锁定互斥锁 // 等待条件变量满足 condVar.wait(lock, []()&#123; return !dataQueue.empty(); &#125;); // 从队列中获取数据并消费 int data = dataQueue.front(); dataQueue.pop(); std::cout &lt;&lt; &quot;Consumed data: &quot; &lt;&lt; data &lt;&lt; std::endl; // 模拟消费数据的处理时间 std::this_thread::sleep_for(std::chrono::milliseconds(250)); &#125;&#125;int main() &#123; // 创建生产者线程和消费者线程 std::thread producerThread(producer); std::thread consumerThread(consumer); // 等待生产者线程和消费者线程结束 producerThread.join(); consumerThread.join(); return 0;&#125; ####信号量 在这个示例中，使用了 Semaphore 类来实现信号量的功能。Semaphore 类包含了 notify() 和 wait() 方法，用于通知和等待信号量。 生产者线程在每次生产数据后，调用 semProducer.wait() 等待生产者信号量，然后将数据放入队列并通知消费者信号量。消费者线程在每次消费数据前，调用 semConsumer.wait() 等待消费者信号量，然后从队列中取出数据并通知生产者信号量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;chrono&gt;class Semaphore &#123;public: Semaphore(int count = 0) : count_(count) &#123;&#125; void notify() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); ++count_; condition_.notify_one(); &#125; void wait() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); while (count_ == 0) &#123; condition_.wait(lock); &#125; --count_; &#125;private: std::mutex mutex_; std::condition_variable condition_; int count_;&#125;;std::queue&lt;int&gt; dataQueue; // 共享数据队列Semaphore semProducer(1), semConsumer(0); // 生产者和消费者信号量void producer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; semProducer.wait(); // 等待生产者信号量 dataQueue.push(i); // 生产数据 std::cout &lt;&lt; &quot;Produced data: &quot; &lt;&lt; i &lt;&lt; std::endl; semConsumer.notify(); // 通知消费者信号量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟生产数据的间隔 &#125;&#125;void consumer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; semConsumer.wait(); // 等待消费者信号量 int data = dataQueue.front(); // 消费数据 dataQueue.pop(); std::cout &lt;&lt; &quot;Consumed data: &quot; &lt;&lt; data &lt;&lt; std::endl; semProducer.notify(); // 通知生产者信号量 std::this_thread::sleep_for(std::chrono::milliseconds(250)); // 模拟消费数据的处理时间 &#125;&#125;int main() &#123; // 创建生产者线程和消费者线程 std::thread producerThread(producer); std::thread consumerThread(consumer); // 等待生产者线程和消费者线程结束 producerThread.join(); consumerThread.join(); return 0;&#125; ####读写锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;chrono&gt;#include &lt;vector&gt;class RWLock &#123;public: RWLock() : readerCount(0), writerCount(0) &#123;&#125; void lockRead() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); while (writerCount &gt; 0) &#123; condition_.wait(lock); &#125; ++readerCount; &#125; void unlockRead() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); --readerCount; if (readerCount == 0) &#123; condition_.notify_one(); &#125; &#125; void lockWrite() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); ++writerCount; while (readerCount &gt; 0 || writerCount &gt; 1) &#123; condition_.wait(lock); &#125; &#125; void unlockWrite() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); --writerCount; condition_.notify_all(); &#125;private: std::mutex mutex_; std::condition_variable condition_; int readerCount; int writerCount;&#125;;int data = 0; // 共享数据RWLock rwLock; // 读写锁void reader() &#123; for (int i = 0; i &lt; 10; ++i) &#123; rwLock.lockRead(); // 加读锁 std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; reads data: &quot; &lt;&lt; data &lt;&lt; std::endl; rwLock.unlockRead(); // 解读锁 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟读操作的间隔 &#125;&#125;void writer() &#123; for (int i = 0; i &lt; 5; ++i) &#123; rwLock.lockWrite(); // 加写锁 data++; // 修改数据 std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; writes data: &quot; &lt;&lt; data &lt;&lt; std::endl; rwLock.unlockWrite(); // 解写锁 std::this_thread::sleep_for(std::chrono::milliseconds(250)); // 模拟写操作的间隔 &#125;&#125;int main() &#123; // 创建多个读者线程和写者线程 std::vector&lt;std::thread&gt; readers, writers; for (int i = 0; i &lt; 3; ++i) &#123; readers.emplace_back(reader); &#125; for (int i = 0; i &lt; 2; ++i) &#123; writers.emplace_back(writer); &#125; // 等待所有线程结束 for (auto&amp; readerThread : readers) &#123; readerThread.join(); &#125; for (auto&amp; writerThread : writers) &#123; writerThread.join(); &#125; return 0;&#125; 在这个示例中，使用了 RWLock 类来实现读写锁的功能。RWLock 类包含了 lockRead()、unlockRead()、lockWrite() 和 unlockWrite() 方法，分别用于读锁的加锁、读锁的解锁、写锁的加锁和写锁的解锁。 读者线程在每次读取数据前，调用 rwLock.lockRead() 加读锁，读取数据后调用 rwLock.unlockRead() 解读锁。写者线程在每次修改数据前，调用 rwLock.lockWrite() 加写锁，修改数据后调用 rwLock.unlockWrite() 解写锁。 通过使用读写锁，实现了读者-写者模型中的线程同步和并发控制，提高了读操作的并发性能。 ####线程局部存储TLS 线程局部存储（Thread-Local Storage，TLS）是一种线程特定数据（Thread-Specific Data，TSD）的存储机制 允许每个线程都拥有自己独立的数据副本。这意味着每个线程都可以独立地访问和修改自己的数据副本，而不会影响其他线程的数据。 但是自C++11起，标准库提供了一个名为std::thread_local的关键字，可以轻松实现线程局部存储。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;// 定义线程局部变量thread_local int tls_variable = 0;void threadFunction() &#123; // 每个线程都有自己的tls_variable副本 tls_variable++; std::cout &lt;&lt; &quot;Thread ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;, TLS variable: &quot; &lt;&lt; tls_variable &lt;&lt; std::endl;&#125;int main() &#123; std::thread t1(threadFunction); std::thread t2(threadFunction); t1.join(); t2.join(); return 0;&#125; tls_variable是一个线程局部变量，每个线程都有自己独立的副本。在threadFunction()函数中，每个线程都会递增自己的tls_variable副本，并打印出当前线程的ID和TLS变量的值。因为每个线程都有自己的副本，所以输出的结果会显示不同的线程ID和不同的TLS变量值。 网络IO&lt;内存分为内核缓冲区和用户缓冲区&gt; 用户不能直接操作内核缓存区 而 IO 操作、网络请求加载到内存的数据一开始是放在内核缓冲区的 五种网络IO模型 BIO-阻塞模式I&#x2F;O 用户发起请求(系统调用)，如果有(内核缓存区),从内核缓存区拷贝到用户缓存区,如果没有用户进行阻塞等待 进行IO操作将数据拿到内核缓存区 NIO-非阻塞模式 用户进程发起请求，如果数据没有准备好，直接返回错误；可以选择轮询访问或者做点其他事再来访问,直到被告知数据准备完毕，可以开始接收为止； 数据会由用户进程完成拷贝 整个过程 轮询(轮询消耗资源,影响性能)+等待(内核缓冲区到用户缓存区) 同一个线程，同一时刻只能监听一个socket，造成浪费，引入io多路复用，同时监听读个socket IO多路复用 使用select、poll或epoll等系统调用监听多个IO事件。这些系统调用可以让应用程序同时监视多个IO操作，并在某个IO操作就绪时通知应用程序 数据会由用户进程完成拷贝 适用同时处理多个连接如网络服务器 单个连接效率低 信号驱动IO模型 应用程序通过系统调用请求系统在IO完成时向应用程序发送一个信号。当IO操作完成时，操作系统会向应用程序发送一个信号，应用程序在&#x3D;&#x3D;信号处理函数&#x3D;&#x3D;中处理IO完成事件。 适用于多个IO事件 设计复杂,过多连接导致消耗大 AIO 异步I&#x2F;O模型 应用程序发起IO操作后，可以立即返回并继续执行其他操作。当IO操作完成时，操作系统会通知应用程序，并在&#x3D;&#x3D;回调函数中&#x3D;&#x3D;处理IO完成事件。 发起请求立刻得到回复，不用挂起等待； 数据会由内核进程主动完成拷贝 高并发高性能,大规模并行计算和网络服务 C&#x2F;C++ Linux 服务器开发高级架构学习视频点击https://ke.qq.com/course/417774?flowToken=1013189 选择哪个框架取决于你的具体需求和项目背景。如果你需要一个跨平台的解决方案，Boost.Asio可能是最佳选择；如果你需要一个功能齐全且易于使用的库，Poco是一个好选择；而如果你正在构建高性能的Linux服务器应用，MUDuo则非常合适。 《unix环境高级编程》 《unix网络编程》 如果你要写一个WebServer，入门的书籍当然最好是游双的《Linux高性能服务器编程》(读书笔记:https://github.com/HiganFish/Notes-HighPerformanceLinuxServerProgramming)了，当这本内容基本都掌握后，如果有能力还可以再去看一下陈硕大佬的《Linux多线程服务器编程》使用muduo C++网络库，去阅读源码，自制一个属于自己的网络库，相信对你的coding能力是一个很大的提升。 祖师爷GitHub - qinguoyi&#x2F;TinyWebServer: :fire: Linux下C++轻量级WebServer服务器 师叔GitHub - markparticle&#x2F;WebServer: C++ Linux WebServer服务器 师哥https://love6.blog.csdn.net/article/details/123754194 源码https://github.com/Cooi-Boi/High-Performance-WebServer 师弟https://blog.csdn.net/weixin_51322383/article/details/130464403 源码https://github.com/JehanRio/TinyWebServer?tab=readme-ov-file c++网络编程三大框架对比https://zhuanlan.zhihu.com/p/714229209","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux系统安装","slug":"source/Linux/Linux系统安装","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-11T14:51:50.711Z","comments":true,"path":"2025/03/02/source/Linux/Linux系统安装/","permalink":"http://example.com/2025/03/02/source/Linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","excerpt":"","text":"安装虚拟机前置准备 bios里修改设置：开启虚拟化设备支持 【上网搜索（系统默认开启）】 管理员运行VMware安装包 可以看到两个cpu-16核，我们分配两个cpu-每个4核 AnolisAnolis8.6 GA 下载地址：https://mirrors.openanolis.cn/anolis/8.6/isos/GA/x86_64/ 下载minimal.iso 虚拟机选择centos 8 64位 CentOS7下载地址：https://mirrors.aliyun.com/centos/7/isos/x86_64/ CentOS-7-x86_64-Minimal-2009.iso Ubuntu安装g++sudo apt update sudo apt install build-essential gdb 同时安装gcc g++ gdp apt install net-tools 安装arp等网络工具 ##Anolis安装g++ yum update yum install gcc yum install gcc-c++ libstdc++-devel yum install gdb 编译器 yum install cmake yum install tree 一般跳转到要查看的目录下tree . 手动如何安装？？?配置环境&#x3D;&#x3D;？？？&#x3D;&#x3D; 使用gcc编译c语言文件 g++编译c++ vscode也是使用gcc ##编译过程 预处理 g++ -E test.cpp -o test.i -E 头文件，宏等处理 编译 g++ -S test.i -o test.s -S 生成汇编文件 汇编 g++ -C test.s -o test.o -C 仅把源代码编译为机器语言（二进制）的目标代码 链接 g++ test.o -o test -o指定产生的文件名 生成bin文件 使用这一步会自动完成前面三步 链接是将编译后生成的目标文件以及程序中可能需要的库文件合并成一个可执行文件的过程。在链接阶段，链接器（Linker）会处理目标文件之间的依赖关系，并解决任何符号引用（比如函数或变量的调用）。 .&#x2F;test 运行当前路径下的可执行文件test ###g++编译参数 -g 产生带可调试信息的可执行文件 -O[n] 优化代码 -O&#x3D;-O1 -O0不做优化 一般到-O2就可以了 最多-O3 time .&#x2F; test 可以看到执行时间 -l usr&#x2F;local&#x2F;lib usr&#x2F;lib lib 这三个目录下的库这样使用 g++ -lglog test.cpp 链接glog库 -L 其他目录 g++ -L&#x2F;home&#x2F;tutu -lmytest test.cpp 链接mytest库 -I 头文件不在&#x2F;usr&#x2F;include g++ -I&#x2F;myincldue test.cpp -Wall 打印警告信息 -w关闭警告信息 -std&#x3D;c++11 使用c++11标准 -o指定输出名字 没有会生成a.out -D使用宏 命令行编译 如果有这样一个目录结构 直接编译 g++ main.cpp src&#x2F;swap.cpp -Iinclude 如果head.h和head.cpp在一个文件下则不需要-Iinclude .&#x2F;a.out 执行 增加编译参数 g++ main.cpp src&#x2F;swap.cpp -Iinclude -Wall -std&#x3D;c++11 -o b.out 生成库文件并编译 链接静态库生成可执行文件 cd src g++ swap.cpp -c -I..&#x2F;include 生成swap.o ar rs libswap.a swap.o 把swap.o归档为libswap.a的静态库文件 cd .. g++ main.cpp -lswap -Lsrc -Iinclude -o static_main .&#x2F;static_main 链接动态库生成可执行文件 cd src g++ swap.cpp -I..&#x2F;inlcude -fpic -shared -o libswap.so -fpic于路径无关 -shared生成动态库 .so动态库后缀 cd .. g++ main.cpp -Iinclude -lswap -Lsrc -o dyna_main .&#x2F;dyna_main 运行不了 动态生成的文件是在src里面 静态在外面（嵌到main.cpp中） 区别&#x3D;&#x3D;？？？&#x3D;&#x3D; LD_LIBRARY_PATH&#x3D;src .&#x2F;dyna_main 在指定文件中搜索 ###GDB调试器 1234567891011121314151617181920212223242526## 以下命令后括号内为命令的简化使用，比如run（r），直接输入命令 r 就代表命令run$(gdb)help(h) # 查看命令帮助，具体命令查询在gdb中输入help + 命令 $(gdb)run(r) # 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）$(gdb)start # 单步执行，运行程序，停在第一行执行语句$(gdb)list(l) # 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）$(gdb)set # 设置变量的值$(gdb)next(n) # 单步调试（逐过程，函数直接执行）$(gdb)step(s) # 单步调试（逐语句：跳入自定义函数内部执行）$(gdb)backtrace(bt) # 查看函数的调用的栈帧和层级关系$(gdb)frame(f) # 切换函数的栈帧$(gdb)info(i) # 查看函数内部局部变量的数值$(gdb)finish # 结束当前函数，返回到函数调用点$(gdb)continue(c) # 继续运行$(gdb)print(p) # 打印值及地址$(gdb)quit(q) # 退出gdb$(gdb)break+num(b) # 在第num行设置断点$(gdb)info breakpoints # 查看当前设置的所有断点$(gdb)delete breakpoints num(d) # 删除第num个断点$(gdb)display # 追踪查看具体变量值$(gdb)undisplay # 取消追踪观察变量$(gdb)watch # 被设置观察点的变量发生修改时，打印显示$(gdb)i watch # 显示观察点$(gdb)enable breakpoints # 启用断点$(gdb)disable breakpoints # 禁用断点$(gdb)x # 查看内存x/20xw 显示20个单元，16进制，4字节每单元$(gdb)run argv[1] argv[2] # 调试时命令行传参$(gdb)set follow-fork-mode child # Makefile项目管理：选择跟踪父子进程（fork()） 编译程序时需要加上-g，之后才能用gdb进行调试：gcc -g main.c -o main 回车键：重复上一命令 gdb main cmakecmake windows(不用看)软件构建(build)：cmake 全自动完成代码编译，链接，打包 跨平台 vs:MSbuild 不同编译器使用的工具不同 cmake可以支配所有 cmake：不用手动配置makefile 首先vscode安装插件cmake cmaketools 编译运行单个文件 123cmake_minimum_required(VERSION 3.10) //要求cmake的最低版本project(Example) //指定工程名字，也是生成的可执行文件的名字add_executable(Example test.cpp) //表示我们需要构建一个可执行文件由test.cpp编译而成 #####配置(configure) 根据这个cmakelists文件生成目标平台的原生工程–配置(configure) 命令面板ctrl+shift+p 输入&gt;cmake configure 选择 命令行指令 cmake -S . -B build 之后保存会自动配置 #####构建(build) F7或者&gt;cmake build 命令行指令 cmake –build build 运行复制粘贴构建后最后一行的路径 C:\\Users\\Tutu\\Desktop\\cmake\\build\\Debug\\Example.exe BV1rR4y1E7n9 入门-代码解释 https://subingwen.cn/cmake/CMake-primer/ 详细文档 BV14s4y1g7Zj 视频解析 1234567891011121314151617181920212223cmake_minimum_required(VERSION 3.10) project(Example)#find_package(easyx REQUIRED) file(GLOB &quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.h&quot; &quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;)add_executable($&#123;CMAKE_PROJECT_NAME&#125; $&#123;SRC_FLIES&#125;)#target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE easyx)target_compile_features($&#123;CMAKE_PROJECT_NAME&#125; PRIVATE cxx_std_17)add_custom_command( target $&#123;CMAKE_PROJECT_NAME&#125; POST_BUILD COMMAND $&#123;CMAKE_PROJECT_NAME&#125; -E copy_directoy &quot;$&#123;PROJECT_SOURCE_DIR&#125;/assets&quot; &quot;$&lt;PROJECT_FILE_DIR:$&#123;CMAKE_PROJECT_NAME&#125;&gt;/assets&quot;) 运行多文件 12345678cmake_minimum_required(VERSION 3.10) project(CALC)set(CMAKE_CXX_STANDARD 11) #使用c++ 11set(HOME /home/robin/Linux/calc)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)include_directories($&#123;PROJECT_SOURCE_DIR&#125;) #包含头文件 不要也可以（有时出错？）file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp) #文件下的源文件/str/*.cppadd_executable(app $&#123;SRC_LIST&#125;) cmake linuxcrlf \\r\\n lf \\n &#x3D;&#x3D;???&#x3D;&#x3D; 需要插件：c&#x2F;c++ cmake cmaketools 在anolis中安装vscode 可以考虑，但是没必要 安装插件 点这个没用 https://marketplace.visualstudio.com/vscode下载对应版本的插件-linux平台 跳转到对应目录，会提示安装成功重启vscode 会提示已经安好的插件 ###cmake语法 格式 指令(参数1 参数2) 参数间用分号或空格 指令和大小写无关 参数和变量有关 变量使用${} IF控制语句中直接使用 重要指令和常用变量 中括号为可选项，可无 指定CMake的最小版本要求 12CMake最小版本要求为2.8.3cmake_minimum_required(VERSION 2.8.3) 语法：cmake_minimum_required(VERSION versionNumber [FATAL_ERROR]) project - 定义工程名称，并可指定工程支持的语言 12指定工程名为HELLOWORLDproject(HELLOWORLD) 语法：project(projectname [CXX] [C] [Java]) set - 显式的定义变量 12定义SRC变量，其值为main.cpp hello.cppset(SRC sayhello.cpp hello.cpp) 语法：set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) include_directories - 向工程添加多个特定的头文件搜索路径 —&gt;相当于指定g++编译器的-I参数 12将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径include_directories(/usr/include/myincludefolder ./include) 语法：include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …) link_directories - 向工程添加多个特定的库文件搜索路径 —&gt;相当于指定g++编译器的-L参数 12将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径link_directories(/usr/lib/mylibfolder ./lib) 语法：link_directories(dir1 dir2 …) add_library - 生成库文件 12通过变量 SRC 生成 libhello.so 共享库add_library(hello SHARED $&#123;SRC&#125;) 语法：add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN) SHARED动态库 STATIC静态库 add_compile_options - 添加编译参数 12添加编译参数 -Wall -std=c++11add_compile_options(-Wall -std=c++11 -O2) 语法：add_compile_options( add_executable - 生成可执行文件 12编译main.cpp生成可执行文件mainadd_executable(main main.cpp) 语法：add_executable(exename source1 source2 … sourceN) target_link_libraries - 为 target 添加需要链接的共享库 —&gt;相同于指定g++编译器-l参数 12将hello动态库文件链接到可执行文件maintarget_link_libraries(main hello) 语法：target_link_libraries(target library1library2…) add_subdirectory - 向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置 12添加src子目录，src中需有一个CMakeLists.txtadd_subdirectory(src) 语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) aux_source_directory - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表 1234定义SRC变量，其值为当前目录下所有的源代码文件aux_source_directory(. SRC)编译SRC变量所代表的源代码文件，生成main可执行文件add_executable(main $&#123;SRC&#125;) 语法：aux_source_directory(dir VARIABLE) CMake常用变量 CMAKE_C_FLAGS gcc编译选项 CMAKE_CXX_FLAGS g++编译选项 12在CMAKE_CXX_FLAGS编译选项后追加-std=c++11set( CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;) CMAKE_BUILD_TYPE 编译类型(Debug, Release) 1234设定编译类型为debug，调试时需要选择debugset(CMAKE_BUILD_TYPE Debug) 设定编译类型为release，发布时需要选择releaseset(CMAKE_BUILD_TYPE Release) CMAKE_BINARY_DIR PROJECT_BINARY_DIR __BINARY_DIR 这三个变量指代的内容是一致的。 如果是 in source build，指的就是工程顶层目录。 如果是 out-of-source 编译,指的是工程编译发生的目录。 PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR__SOURCE_DIR 这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。 也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。 PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。 CMAKE_C_COMPILER：指定C编译器 CMAKE_CXX_COMPILER：指定C++编译器 EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径 LIBRARY_OUTPUT_PATH：库文件输出的存放路径 CMake编译工程CMake目录结构：项目主目录存在一个CMakeLists.txt文件 编译流程 手动编写 CmakeLists.txt。 执行命令 cmake PATH生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的路径 )。 执行命令make 进行编译。 important tips . # 表示当前目录 ./ # 表示当前目录 .. # 表示上级目录 ../ # 表示上级目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#### 两种构建方式CMakeList在外面 外部构建只是进入build文件夹执行cmake使生成的文件放到build文件夹中- **内部构建(in-source build)**：不推荐使用 内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。 ``` 内部构建 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件 cmake . 执行make命令，生成target make ``` - **外部构建(out-of-source build)**：==推荐使用== 将编译输出文件存放到单独的build文件夹中 ``` # 外部构建 1. 在当前目录下，创建build文件夹 mkdir build 2. 进入到build文件夹 cd build 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件 cmake .. 4. 执行make命令，生成target make ```####单文件直接使用g++指令更方便\\#include&lt;include/head.h&gt; cmake可不加include实例&lt;img src=&quot;./images/Linux系统安装.assets/image-20230913214219685-1740971902830-272.png&quot; alt=&quot;image-20230913214219685&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;img src=&quot;./images/Linux系统安装.assets/image-20230913214324629-1740971902830-274.png&quot; alt=&quot;image-20230913214324629&quot; style=&quot;zoom:33%;&quot; /&gt;目录结构&lt;img src=&quot;./images/Linux系统安装.assets/image-20230914093743079-1740971902830-276.png&quot; alt=&quot;image-20230914093743079&quot; style=&quot;zoom:50%;&quot; /&gt;g++ main.cpp scr/Gun.cpp scr/Solier.cpp -Iinclude [-o main] -wall -g -O2如果头文件和源文件放到同一个目录下则不需要-Iinclude~~~cmakecmake_minimum_required(VERSION 3.0)project(Solidefire)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2 -Wall&quot;) //设置g++编译选项include_directories(include)add_executable(main_cmake main.cpp src/Gun.cpp src/Soldier.cpp) include_directories(include) 可以写成 include_directories($&#123;CMAKE_SOURCE_DIR&#125;/include) 变量CMAKE_SOURCE_DIR是cmakelists所在文件夹路径 修改源代码之后只需要make不需要cmake .. cmake只针对cmakelists文件 **所有文件放到一个目录里面** ![image-20230914091740384](./images/Linux系统安装.assets/image-20230914091740384.png) aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125; SRC) #PROJECT_SOURCE_DIR cmake .. 执行cmake后面跟随的路径 或者file(GLOB SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp) 再 add_executable(main_cmake $&#123;SRC&#125;) **放到不同目录里面** 目录结构 &lt;img src=&quot;./images/Linux系统安装.assets/image-20230914093743079-1740971902830-276.png&quot; alt=&quot;image-20230914093743079&quot; style=&quot;zoom:50%;&quot; /&gt; 一样是进入build文件夹 cmake .. make ./mian_cmake 1234567891011121314151617cmake_minimum_required(VERSION 3.0)project(Solidefire)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2 -Wall&quot;)include_directories(include)set(SRC main_cmake main.cpp src/Gun.cpp src/Soldier.cpp)#aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125; SRC) #PROJECT_SOURCE_DIR cmake .. 执行cmake后面跟随的路径file(GLOB SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp) #CMAKE_CURRENT_SOURCE_DIR对应makelists所在路径include_directories(%&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)#set(EXECUTABLE_OUTPUT_PATH /opt/demo/build) #指定输出路径set(CMAKE_CXX_STANDARD 11) #使用c++11标准 或cmake .. -DCMAKE_CXX_STANDARD=11add_executable(main_cmake $&#123;SRC&#125;) 后续链接库等看BV14s4y1g7Zj?p 调试看BV1fy4y1b7TC?p 配置json等 调试 选择creat a launch.json file再选择c++(GDB) 如果没用在右下角选择第一个 .json文件如下 123456789101112131415161718192021222324252627282930313233343536&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) 启动&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/demo/build/main_cmake&quot;, //要调试的可执行文件的绝对路径 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,//workspaceFolder顶层目录，json文件所在 &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, // &#123; // &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, // &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, // &quot;ignoreFailures&quot;: true // &#125; ], //&quot;preLaunchTask&quot;: &quot;build&quot;, //调试之前做一个task引号是名字 &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; &#125; ]&#125; cmakelist中加set(CMAKE_BUILD_TYPE Debug) #生成可调试文件，避免冲突 f5进入调试 f10单步 f11进入 f5结束 打开 &#x2F;&#x2F;“preLaunchTask”: “C&#x2F;C++:g++ build active file”, &#x2F;&#x2F;调试之前做一个task引号是名字 配置tasks.json文件 随便点击一个 123456789101112131415161718192021222324252627282930313233&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot; //进入build文件夹 &#125;, &quot;tasks&quot;: [ //包含了三个task &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;cmake&quot;, //task名字 &quot;command&quot;: &quot;cmake&quot;, //命令 &quot;args&quot;: [ //参数 &quot;..&quot; ] &#125;, &#123; &quot;label&quot;: &quot;make&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;command&quot;: &quot;make&quot;, //执行make，没用参数 &quot;args&quot;: [] &#125;, &#123; &quot;label&quot;: &quot;build&quot;, &quot;dependsOrder&quot;: &quot;sequence&quot;, &quot;dependsOn&quot;: [ //依赖于上面两个，做cmake .. make 两件事 &quot;cmake&quot;, &quot;make&quot; ] &#125; ],&#125; 这样直接f5就可以调试了运行了，不用再cmake和make了 遇到问题yum install 时遇到问题 ###failed to set locale defaulting to C.UTF-8 我是网络问题，下面都没用的意思 先ping www.baidu.com 看能不能通 不能一般是网络问题（我是没有设置dns） locale -a查看已经安装的语言包 镜像网站下载rpm包 指令安装 sudo yum install epel-release sudo yum install langpacks-en 无法使用指令镜像网站 镜像网站：Welcome to the RPM repository on fr2.rpmfind.net 搜索epel-release langpacks-en找对应版本进行安装rpm包 rpm -i example.rpm -i表示安装，example.rpm是要安装的RPM包的名称。 可视化显示使用-v 使用-h选项来显示安装进度。 rpm -ivh example.rpm 镜像网站：Welcome to the RPM repository on fr2.rpmfind.net 搜索名字安装rpm包 重命名后使用xftp传输到&#x2F;home&#x2F;tutu 进入目录 分别rpm -ivh epel-release.rpm 然后 生成语言环境 先install再sudo localedef -v -c -i en_US -f UTF-8 en_US.UTF-8 sudo nano &#x2F;etc&#x2F;default&#x2F;locale LANG&#x3D;en_US.UTF-8 LC_ALL&#x3D;en_US.UTF-8 sudo yum install langpacks-en sudo localedef -v -c -i en_US -f UTF-8 en_US.UTF-8 生成语言环境 安装库文件##安装pthread库 yum install -y glibc-devel rpm -q glibc-devel 检查 编译 g++ communicationV2.0.cpp -lpthread 安装Ubuntu官网 https://cn.ubuntu.com/desktop 我下载的是ubuntu-24.04-desktop-amd64.iso 完成 编辑虚拟机设置 这里选择这个会使用之前配置的网络自动分配一个ip，后面不用配置了 确定-开启虚拟机 不知道为什么我图形化界面进去在安装的位置一直卡住 后面直接安装非图形化的 前面步骤一样，后面安好之后要重新启动一次，启动的时候把镜像文件改为自动检测，我改了以后不知道是我卡还是等的时间不够，后面我又把镜像安上之后或者取消重复开了好几次，去吃个饭回来就进入命名界面了，意外之喜 镜像文件下载地址：https://mirrors.aliyun.com/ubuntu-releases/ 进入之后只有一个自己建的用户，没有root用户 导致输入命令很多都要 +sudo sudo passwd root 设置root密码 su - root 切换到root #配置静态局域网 虚拟机默认是NAT模式 每个虚拟机一个DHCP都是10.0.2.2 主机10.0.2.15 每个虚拟机都一样 所以虚拟机不能互通 虚拟机可以ping主机NAT的私有地址，主机不能访问虚拟机 只出不进 NAT网络 教程：https://cnxiaobai.com/articles/2021/04/21/1619011285612.html 一开始ip a查看不到ip地址，需要编辑网卡信息 首先进入root账户 普通账户尝试过不行 cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ls 显示网卡名称 ifcfg-ens160 vi ifcfg-ens160 进入编辑模式&#x2F;vi 按 i 进入编辑 TYPE=Ethernet #网络类型:Ethernet以太网 PROXY_METHOD=none #代理方式：关闭状态 BROWSER_ONLY=no # 只是浏览器：否 BOOTPROTO=static #引导协议：static静态、dhcp动态获取、none不指定 改 DEFROUTE=yes #启动默认路由 IPV4_FAILURE_FATAL=no #不启用IPV4错误检测功能 IPV6INIT=yes #启用IPV6协议 IPV6_AUTOCONF=yes #自动配置IPV6地址 IPV6_DEFROUTE=yes #启用IPV6默认路由 IPV6_FAILURE_FATAL=no #不启用IPV6错误检测功能 NAME=ens160 # 网卡设备的别名 UUID=985f89ca-ada3-4dfd-9dd2-c97f680a8ed1 #网卡设备的UUID,通用唯一识别码 DEVICE=ens160 # 网卡的设备名称 ONBOOT=yes #开机自动启动网卡 改 //加 IPADDR=192.168.6.208 248.3 NETMASK=255.255.255.0 GATEWAY=192.168.6.2 248.2 PREFIX=24 DNS1=114.114.114.114 DNS2=8.8.8.8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657586. 编写完成后按esc进入选择模式7. : 进入底线模式 输入==w保存 q退出== 后加！强制执行8. nmcli c reload # 重新加载配置文件 nmcli c up ens160 # 重启ens33网卡 service NetworkManager restart 重置网卡？？9. 重新启动客户机sudo nmtui 进入网络设置&lt;img src=&quot;./images/Linux系统安装.assets/image-20240831165217770-1740971902830-313.png&quot; alt=&quot;image-20240831165217770&quot; style=&quot;zoom:50%;&quot; /&gt;为啥网关设置成.2呢### 虚拟机网络设置编辑-虚拟网络编辑器-更改设置-VMnet8&lt;img src=&quot;./images/Linux系统安装.assets/image-20230829172834973-1740971902830-315.png&quot; alt=&quot;image-20230829172834973&quot; style=&quot;zoom: 67%;&quot; /&gt;NAT设置&lt;img src=&quot;./images/Linux系统安装.assets/image-20230829172924050-1740971902830-317.png&quot; alt=&quot;image-20230829172924050&quot; style=&quot;zoom:50%;&quot; /&gt;规则192.168不变 6随便（224以下） DHCP设置&lt;img src=&quot;./images/Linux系统安装.assets/image-20230829173012318-1740971902830-319.png&quot; alt=&quot;image-20230829173012318&quot; style=&quot;zoom:50%;&quot; /&gt;ip要在这个范围里面ping www.baidu.com ping不通代表有问题 ctrl+c结束ping#SSH###windowsssh tutu@192.168.6.208linux：systemctl status sshd 查看是否启动sshsystemctl start sshd 启用###vscode配置config文件 Host 192.168.6.208 //主机ip HostName 192.168.6.208 User tutu 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162ssh tutu@192.168.6.208 tutussh root@192.168.6.208 123避免每次连接需要输入密码cmd:ssh-keygen -t rsa -b 4096 四个回车生成密钥 ==？？？==##免密登录* code /etc/ssh/sshd_config 日志：code /var/log/secure* sudo systemctl restart sshd* windows上运行ssh-keygen 三个回车看到生成的公钥和私钥的位置C:\\Users\\Tutu\\.ssh\\id_rsa* 修改config配置文件Host 192.168.6.208 HostName 192.168.6.208 User root IdentityFile C:\\Users\\Tutu\\.ssh\\id_rsa* 将id_rsa.pub复制到服务器的~/.ssh文件夹中* 修改文件/etc/ssh/ssh_configPasswordAuthentication noPubkeyAuthentication yessystemctl restart sshd* 可能需要权限chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys## ssh慢修改/etc/ssh/sshd_config文件UseDNS noGSSAPIAuthentication no创建实例并初始化 Open StartAccept 创建TcpClientPtr HandleAccept StartRead407 行 pClient-&gt;GetBuffer(0); max,0 HandleRead RecvData GetMessage TcpClientPtr构造 m_maxBufSize &#x3D; 8 * 1024 * 1024; m_offset &#x3D; 0;&#x2F;&#x2F;总消息长度 m_parseOffset &#x3D; 0;&#x2F;&#x2F;上一条消息的末尾 m_pBuf &#x3D; NULL;&#x2F;&#x2F;堆上分配8MB内存，m_pBuf指向第一个字节 m_state &#x3D; 1; m_bReadClose &#x3D; false; m_nSendHeartBeatCount &#x3D; 10; m_nRecvHeartBeatCount &#x3D; 0; Init(m_maxBufSize); m_prp2dbspcPkt.pktLen &#x3D; sizeof(PRP_DBSPC_RULE_PKT); m_prp2dbspcPkt.flag &#x3D; DBAGENT_FLAG; m_prp2dbspcPkt.pktType &#x3D; EU_AGENT_PKT_TYPE_RULE; m_pBuf &#x3D; new uint8_t[m_maxBufSize];&#x2F;&#x2F;maxGetBuffer(0)&#x2F;&#x2F;获得缓冲区的第一个地址 uint8_t* pBuf &#x3D; m_pBuf + m_offset;&#x2F;&#x2F;+0 bufSize &#x3D; m_maxBufSize - m_offset;&#x2F;&#x2F;-0 if max&lt;&#x3D;0 return null return pbuf 返回地址RecvData(readSize) m_offset+&#x3D;readSizeHaveMessage msgLen&#x3D;*m_pBuf&#x2F;&#x2F; if(m_offset &lt; msgLen) return fasle m_parseOffset&#x3D;0GetMessage（0） pBuf&#x3D; msgSize 数据部分长度经过减去头部数据4 123# 配置静态网络 cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;vi ifcfg-ens33 (替换成对应网卡名称) 1 TYPE&#x3D;EthernetPROXY_METHOD&#x3D;noneBROWSER_ONLY&#x3D;noBOOTPROTO&#x3D;static &#x2F;&#x2F;改DEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;noIPV6INIT&#x3D;yesIPV6_AUTOCONF&#x3D;yesIPV6_DEFROUTE&#x3D;yesIPV6_FAILURE_FATAL&#x3D;noIPV6_ADDR_GEN_MODE&#x3D;stable-privacyNAME&#x3D;ens33UUID&#x3D;1647aabe-3d39-4811-b698-b958ac9169f4DEVICE&#x3D;ens33ONBOOT&#x3D;yes &#x2F;&#x2F;从这往下，改，ip根据自己配置的VMnet8更改IPADDR&#x3D;192.168.248.3NETMASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.248.2PREFIX&#x3D;24DNS1&#x3D;114.114.114.114DNS2&#x3D;8.8.8.8 1 nmcli c reloadnmcli c up ens160 1233. 配置yum源 备份cp &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backupvi &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo 1 CentOS-Base.repoThe mirror system uses the connecting IP address of the client and theupdate status of each mirror to pick mirrors that are updated to andgeographically close to the client. You should use this for CentOS updatesunless you are manually picking other mirrors.If the mirrorlist&#x3D; does not work for you, as a fall back you can try theremarked out baseurl&#x3D; line instead.[os]name&#x3D;Qcloud centos os - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/os/$basearch/enabled&#x3D;1gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 [updates]name&#x3D;Qcloud centos updates - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/updates/$basearch/enabled&#x3D;1gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 [centosplus]name&#x3D;Qcloud centosplus - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/centosplus/$basearch/enabled&#x3D;0gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 [cr]name&#x3D;Qcloud centos cr - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/cr/$basearch/enabled&#x3D;0gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 [extras]name&#x3D;Qcloud centos extras - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/extras/$basearch/enabled&#x3D;1gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 [fasttrack]name&#x3D;Qcloud centos fasttrack - $basearchbaseurl&#x3D;http://mirrors.cloud.tencent.com/centos/$releasever/fasttrack/$basearch/enabled&#x3D;0gpgcheck&#x3D;1gpgkey&#x3D;http://mirrors.cloud.tencent.com/centos/RPM-GPG-KEY-CentOS-7 1 yum clean allyum makecache","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux高性能服务器编程","slug":"source/Linux/Linux高性能服务器编程","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.386Z","comments":true,"path":"2025/03/02/source/Linux/Linux高性能服务器编程/","permalink":"http://example.com/2025/03/02/source/Linux/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/","excerpt":"","text":"深入解析高性能服务器编程Linux网络编程基础API socket地址API。socket最开始的含义是一个IP地址和端口对（ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。 socket基础API。socket的主要API都定义在sys&#x2F;socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。 网络信息API。Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。 ###socket地址API 先要理解主机字节序和网络字节序 主机字节序和网络字节序现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位机），即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。 大端字节序是指一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7 bit）存储在内存的高地址处。小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 判断机器字节序 1234567891011121314151617181920212223#include&lt;stdio.h&gt;void byteorder()&#123; union&#123; short value; //short占两字节 char union_bytes[sizeof(short)]; &#125;test; test.value=0x0102; //01一个字节 02一个字节 //union的成员共享一个内存，虽然是给short value赋值的，两个成员的内存都是一样的，只是用short类型解释是十六进制的0102，用char数组解释时，恰好是两个成员，每个1字节，都是十进制的第一个是01第二个是02 if((test.union_bytes[0]==1)&amp;&amp;(test.union_bytes[1]==2))&#123; printf(&quot;big endian\\n&quot;); &#125; else if((test.union_bytes[0]==2)&amp;&amp;(test.union_bytes[1]==1)) &#123; printf(&quot;little endian\\n&quot;); &#125; else&#123; printf(&quot;unknown...\\n&quot;); &#125;&#125;int main()&#123; byteorder(); return 0;&#125; 我在linux上运行是little endian 我们可以调试查看内存的表示，也是符合逻辑的 &#x3D;&#x3D;小端字节序又被称为主机字节序&#x3D;&#x3D; 现代PC大多采用小端字节序 &#x3D;&#x3D;大端字节序也称为网络字节序&#x3D;&#x3D; 发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换） 即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（JAVA虚拟机采用大端字节序）。 Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换 12345#include＜netinet/in.h＞unsigned long int htonl(unsigned long int hostlong); //无符号长整型 主机-&gt;网络unsigned short int htons(unsigned short int hostshort);//无符号短整型unsigned long int ntohl(unsigned long int netlong); //网络-&gt;主机unsigned short int ntohs(unsigned short int netshort); 长整型（32 bit）常用来转换IP地址，短整型(16位)用来转换端口号 这里的类型都是可以换的，比如我转换一个short类型为大端序 1234567891011#include&lt;netinet/in.h&gt;#include &lt;stdio.h&gt; #include &lt;iostream&gt;using namespace std;int main() &#123; unsigned short int host_short = 0x1234; unsigned short int net_short = htons(host_short); printf(&quot;Network byte order short: 0x%X\\n&quot;, net_short); //3412 cout &lt;&lt; net_short &lt;&lt; endl; //13330的十六进制3421 return 0;&#125; 通用socket地址socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下 12345#include＜bits/socket.h＞struct sockaddr&#123; sa_family_t sa_family; //地址族类型 char sa_data[14];&#125; 地址族类型通常与协议族类型对应 常见的协议族（protocol family，也称domain) 宏PF_*和AF_*都定义在bits&#x2F;socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。 sa_data成员用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度 可见14的大小完全不够，linux定义了新的结构 123456#include＜bits/socket.h＞struct sockaddr_storage&#123; sa_family_t sa_family; unsigned long int__ss_align; char__ss_padding[128-sizeof(__ss_align)];&#125; __ss_align成员使内存对齐 专用socket地址上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体 UNIX本地域协议族 12345#include＜sys/un.h＞struct sockaddr_un&#123; sa_family_t sin_family;/*地址族：AF_UNIX*/ char sun_path[108];/*文件路径名*/&#125;; TCP&#x2F;IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6： 12345678910111213141516171819struct sockaddr_in&#123; sa_family_t sin_family;/*地址族：AF_INET*/ u_int16_t sin_port;/*端口号，要用网络字节序表示*/ struct in_addr sin_addr;/*IPv4地址结构体，见下面*/&#125;;struct in_addr&#123; u_int32_t s_addr;/*IPv4地址，要用网络字节序表示*/&#125;;struct sockaddr_in6&#123; sa_family_t sin6_family;/*地址族：AF_INET6*/ u_int16_t sin6_port;/*端口号，要用网络字节序表示*/ u_int32_t sin6_flowinfo;/*流信息，应设置为0*/ struct in6_addr sin6_addr;/*IPv6地址结构体，见下面*/ u_int32_t sin6_scope_id;/*scope ID，尚处于实验阶段*/&#125;;struct in6_addr&#123; unsigned char sa_addr[16];/*IPv6地址，要用网络字节序表示*/&#125;; 所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。 IP地址转换函数通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。 编程中我们需要先把它们转化为整数（二进制数）方能使用。 记录日志时，我们要把整数表示的IP地址转化为可读的字符串。 下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换： 1234#include＜arpa/inet.h＞in_addr_t inet_addr(const char*strptr);int inet_aton(const char*cp,struct in_addr*inp);char*inet_ntoa(struct in_addr in); inet_addr IPv4地址转化为用网络字节序它 失败时返回INADDR_NONE。 inet_aton IPv4地址转化为用网络字节序，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。 inet_ntoa 网络字节序转化为用点分十进制 但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。(意思是连续调用两个这个函数 后一个的结果会把前一个覆盖) 123#include＜arpa/inet.h＞int inet_pton(int af,const char*src,void*dst);const char*inet_ntop(int af,const void*src,char*dst,socklen_tcnt); 适用于ipv4和ipv6 inet_pton IP地址src转换成用网络字节序 并把转换结果存储于dst指向的内存中。其中，af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno[1]。 inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小（分别用于IPv4和IPv6）： inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。 #include＜netinet&#x2F;in.h＞ #define INET_ADDRSTRLEN 16 #define INET6_ADDRSTRLEN 46 使用示例 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; #include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;//ip地址转换using namespace std;int main() &#123; //函数1 const char* ip=&quot;192.168.6.208&quot;; in_addr_t ipAddr = inet_addr(ip); cout&lt;&lt;ipAddr&lt;&lt;endl; cout&lt;&lt;inet_addr(&quot;192.168.6.208&quot;)&lt;&lt;endl; //3490097344 返回in_addr_t(unsigned long) //函数2 //使用最多 //获取端口号的网络字节 unsigned short int port=5005; unsigned short int new_port=htons(port); //建立ipv4专用socket地址 struct sockaddr_in ip_addr;//专用socket结构体 ip_addr.sin_family=AF_INET;//指定地址族ipv4 ip_addr.sin_port=new_port;//指定网络端口号 if(inet_aton(ip,&amp;ip_addr.sin_addr)==1)&#123; //ip转化为网络地址 cout&lt;&lt;ip_addr.sin_addr.s_addr&lt;&lt;endl; &#125; cout&lt;&lt;ip_addr.sin_port&lt;&lt;endl;//网络端口36115 //专用地址强制转化为通用地址 const struct sockaddr*addr=(sockaddr*)&amp;ip_addr; //函数3 char* ip2=inet_ntoa(ip_addr.sin_addr); cout&lt;&lt;ip2&lt;&lt;endl;&#125; 创建socketUNIX&#x2F;Linux的一个哲学是：所有东西都是文件。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket： 123#include＜sys/types.h＞#include＜sys/socket.h＞int socket(int domain,int type,int protocol); domain参数告诉系统使用哪个底层协议族。PF_INET（Protocol Family of Internet，用于IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。 type参数指定服务类型。服务类型主要有SOCK_STREAM服务（流服务）和SOCK_UGRAM（数据报）服务。对TCP&#x2F;IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。 值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值：SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。 protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。 socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno 命名socket将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下： 123#include＜sys/types.h＞#include＜sys/socket.h＞int bind(int sockfd,const struct sockaddr*my_addr,socklen_t addrlen); bind将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是： EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023）上时，bind将返回EACCES错误 EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。 监听socketsocket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接： 12#include＜sys/socket.h＞int listen(int sockfd,int backlog); sockfd参数指定被监听的socket。 backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。 listen成功时返回0，失败则返回-1并设置errno 研究backlog参数对listen系统调用的实际影响 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;//assert宏#include &lt;stdio.h&gt;#include &lt;string.h&gt;//bzero//#include &lt;libgen.h&gt;static bool stop = false;/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/static void handle_term(int sig)&#123; stop = true;&#125;int main(int argc, char *argv[])&#123; signal(SIGTERM, handle_term);//设置SIGTERM信号的处理函数为handle_term SIGTERM是一个常用的终止程序运行的信号 if (argc &lt;= 3)//检查命令行参数是否满足要求 &#123; printf(&quot;usage:%s ip_address port_numberbacklog\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int backlog = atoi(argv[3]); int sock = socket(PF_INET, SOCK_STREAM, 0);//创建socket assert(sock &gt;= 0); //使用 assert 宏来验证 sock 的值是否大于或等于0。 不满足则退出程序 /*创建一个IPv4 socket地址*/ struct sockaddr_in address; bzero(&amp;address, sizeof(address));//bzero 将内存块清空 现在更多使用memset(&amp;address, 0, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr);//绑定ip 网络字节序 address.sin_port = htons(port);//绑定ip int ret = bind(sock, (struct sockaddr *)&amp;address, sizeof(address));//命名 assert(ret != -1); ret = listen(sock, backlog);//监听 assert(ret != -1); /*循环等待连接，直到有SIGTERM信号将它中断*/ while (!stop) &#123; sleep(1); &#125; /*关闭socket，见后文*/ close(sock); return 0;&#125; 我写的： 123456789101112131415161718192021222324252627282930313233#include&lt;netinet/in.h&gt;//转换大端小端#include &lt;stdio.h&gt; #include &lt;iostream&gt;#include &lt;bits/socket.h&gt;#include &lt;arpa/inet.h&gt;//ip地址转换#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;assert.h&gt;using namespace std;int main() &#123; //源ip port const char* ip=&quot;192.168.6.208&quot;; unsigned short int port=5005; //专用socket结构体 sockaddr_in addr; addr.sin_family=AF_INET;//绑定地址族 addr.sin_port = htons(port);//绑定端口 网络字节序 if(inet_aton(ip,&amp;addr.sin_addr)==1)&#123;//绑定ip 网络字节序 cout&lt;&lt;addr.sin_addr.s_addr&lt;&lt;endl; &#125; //专用结构体转化为通用结构体 //const struct sockaddr*new_addr=(sockaddr*)&amp;addr; //创建socket int pre_name_socket; pre_name_socket=socket(PF_INET,SOCK_STREAM,0);//ipv4 tcp SOCK_NONBLOCK 输出3 //命名socket int ret=bind(pre_name_socket,(sockaddr*)&amp;addr,sizeof(addr)); assert(ret != -1); cout&lt;&lt;&quot;bind success&quot;&lt;&lt;endl; //监听 ret = listen(pre_name_socket, 5);//监听 return 0;&#125; 该服务器程序（名为testlisten）接收3个参数：IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernestlaptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下： 123$./testlisten 192.168.1.109 12345 5 #运行代码 监听12345端口，给backlog传递典型值5$telnet 192.168.1.109 12345#多次执行之$netstat-nt|grep 12345#多次执行之 是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。 123456789101112Proto Recv-Q Send-Q Local Address Foreign Address Statetcptcp 0 0 192.168.1.109:12345 192.168.1.108:2240 SYN_RECVtcp 0 0 192.168.1.109:12345 192.168.1.108:2228 SYN_RECV[1]tcp 0 0 192.168.1.109:12345 192.168.1.108:2230 SYN_RECVtcp 0 0 192.168.1.109:12345 192.168.1.108:2238 SYN_RECVtcp 0 0 192.168.1.109:12345 192.168.1.108:2236 SYN_RECVtcp 0 0 192.168.1.109:12345 192.168.1.108:2217 ESTABLISHEDtcp 0 0 192.168.1.109:12345 192.168.1.108:2226 ESTABLISHEDtcp 0 0 192.168.1.109:12345 192.168.1.108:2224 ESTABLISHEDtcp 0 0 192.168.1.109:12345 192.168.1.108:2212 ESTABLISHEDtcp 0 0 192.168.1.109:12345 192.168.1.108:2220 ESTABLISHEDtcp 0 0 192.168.1.109:12345 192.168.1.108:2222 ESTABLISHED 可见，在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态(TCP状态转移)。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。 所以服务器可以 接受多个连接，能建立连接的个数取决于backlog值，不能连接的就处于监听状态？？？ 接受连接123#include＜sys/types.h＞#include＜sys/socket.h＞int accept(int sockfd,struct sockaddr*addr,socklen_t*addrlen); sockfd参数是执行过listen系统调用的监听socket。 addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出。 accept成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。 accept失败时返回-1并设置errno。 现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成功？我们编写一个简单的服务器程序来测试之 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;//用于inet_ntop函数使用宏#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int sock = socket(PF_INET, SOCK_STREAM, 0); assert(sock &gt;= 0); int ret = bind(sock, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(sock, 5); assert(ret != -1); /*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/ sleep(20); //建立新的地址 struct sockaddr_in client; socklen_t client_addrlength = sizeof(client); //接受连接 int connfd = accept(sock, (struct sockaddr *)&amp;client, &amp;client_addrlength); if (connfd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); &#125; else &#123; /*接受连接成功则打印出客户端的IP地址和端口号*/ char remote[INET_ADDRSTRLEN];//宏 用于inet_ntop接收大小 printf(&quot;connected with ip:%s and port:%d\\n&quot;, inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port)); close(connfd);//关闭这个连接socket &#125; close(sock);//关闭服务器监听socket return 0;&#125; $.&#x2F;testaccept 192.168.1.109 54321#监听54321端口 $telnet 192.168.1.109 54321 另一个机器上运行 启动telnet客户端程序后，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下： connected with ip:192.168.1.108 and port:38545 在服务器上运行netstat命令以查看accept返回的连接socket的状态 $netstat-nt|grep 54321 tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。 下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，在服务器上运行netstat命令以查看accept返回的连接socket的状态也正常 由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化 我们把执行过listen调用、处于LISTEN状态的socket称为监听socket，而所有处于ESTABLISHED状态的socket则称为连接socket。 发起连接如果说服务器通过listen调用来被动接受连接，那么客户端需要通过如下系统调用来主动与服务器建立连接 123#include＜sys/types.h＞#include＜sys/socket.h＞int connect(int sockfd,const struct sockaddr*serv_addr,socklen_t addrlen); sockfd参数由socket系统调用返回一个socket。serv_addr参数是服务器监听的socket地址，addrlen参数则指定这个地址的长度 connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和ETIMEDOUT，它们的含义如下： ECONNREFUSED，目标端口不存在，连接被拒绝 ETIMEDOUT，连接超时 关闭连接关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成 12#include＜unistd.h＞int close(int fd); fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1。只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。 如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的） 12#include＜sys/socket.h＞int shutdown(int sockfd,int howto); sockfd参数是待关闭的socket。howto参数决定了shutdown的行为，它可取表的某个值 由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。 shutdown成功时返回0，失败则返回-1并设置errno。 数据读写TCP数据读写对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是： 1234#include＜sys/types.h＞#include＜sys/socket.h＞ssize_t recv(int sockfd,void*buf,size_t len,int flags);ssize_t send(int sockfd,const void*buf,size_t len,int flags); recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。 send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置errno flags参数为数据收发提供了额外的控制 我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序提供了发送和接收带外数据的方法 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); //socket地址 struct sockaddr_in server_address; bzero(&amp;server_address, sizeof(server_address)); server_address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;server_address.sin_addr); server_address.sin_port = htons(port); //创建socket int sockfd = socket(PF_INET, SOCK_STREAM, 0); assert(sockfd &gt;= 0); //不用命名和监听直接连接-始终只有一个socket if (connect(sockfd, (struct sockaddr *)&amp;server_address, sizeof(server_address)) &lt; 0) &#123; printf(&quot;connection failed\\n&quot;); &#125; else &#123; const char *oob_data = &quot;abc&quot;; const char *normal_data = &quot;123&quot;; send(sockfd, normal_data, strlen(normal_data), 0); send(sockfd, oob_data, strlen(oob_data), MSG_OOB); send(sockfd, normal_data, strlen(normal_data), 0); &#125; close(sockfd); return 0;&#125; 服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define BUF_SIZE 1024int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); //地址 struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); //创建 int sock = socket(PF_INET, SOCK_STREAM, 0); assert(sock &gt;= 0); //命名 int ret = bind(sock, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); //监听 ret = listen(sock, 5); assert(ret != -1); //连接地址 struct sockaddr_in client; socklen_t client_addrlength = sizeof(client); //接受连接 int connfd = accept(sock, (struct sockaddr *)&amp;client, &amp;client_addrlength); if (connfd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); &#125; else &#123; char buffer[BUF_SIZE]; memset(buffer, &#x27;\\0&#x27;, BUF_SIZE); //使用监听socket接受消息 ret = recv(connfd, buffer, BUF_SIZE - 1, 0); printf(&quot;got%d bytes of normal data&#x27;%s&#x27;\\n&quot;, ret, buffer); memset(buffer, &#x27;\\0&#x27;, BUF_SIZE); ret = recv(connfd, buffer, BUF_SIZE - 1, MSG_OOB); printf(&quot;got%d bytes of oob data&#x27;%s&#x27;\\n&quot;, ret, buffer); memset(buffer, &#x27;\\0&#x27;, BUF_SIZE); ret = recv(connfd, buffer, BUF_SIZE - 1, 0); printf(&quot;got%d bytes of normal data&#x27;%s&#x27;\\n&quot;, ret, buffer); close(connfd); &#125; close(sock); return 0;&#125; 运行并tcpdump抓取这一过程中客户端和服务器交换的TCP报文段 123$./testoobrecv 192.168.1.109 54321 #在Kongming20上执行服务器程序，监听54321端口$./testoobsend 192.168.1.109 54321 #在ernest-laptop上执行客户端程序$sudo tcpdump-ntx-i eth0 port 54321 服务器输出 got 5 bytes of normal data’123ab’ got 1 bytes of oob data’c’ got 3 bytes of normal data’123’ 由此可见，客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。 含带外数据的TCP报文段 12IP 192.168.1.108.60460＞192.168.1.109.54321:Flags[P.U],seq 4:7,ack 1,win 92,urg 3,options[nop,nop,TS val 102794322 ecr154703423],length 3 这里我们第一次看到tcpdump输出标志U，这表示该TCP报文段的头部被设置了紧急标志。 “urg 3”是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7（3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移）。 因此，带外数据是字节流中的第6字节，即字符“c” 值得一提的是，flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。 UDP数据读写1234#include＜sys/types.h＞#include＜sys/socket.h＞ssize_t recvfrom(int sockfd,void*buf,size_t len,int flags,struct sockaddr*src_addr,socklen_t*addrlen);ssize_t sendto(int sockfd,const void*buf,size_t len,int flags,const struct sockaddr*dest_addr,socklen_t addrlen); recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度 sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。 值得一提的是，recvfrom&#x2F;sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端&#x2F;接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。 通用数据读写函数适用tcp和udp 123#include＜sys/socket.h＞ssize_t recvmsg(int sockfd,struct msghdr*msg,int flags);ssize_t sendmsg(int sockfd,struct msghdr*msg,int flags); sockfd参数指定被操作的目标socket。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下： 12345678910struct msghdr&#123; void*msg_name;/*socket地址*/ socklen_t msg_namelen;/*socket地址的长度*/ struct iovec*msg_iov;/*分散的内存块，见后文*/ int msg_iovlen;/*分散内存块的数量*/ void*msg_control;/*指向辅助数据的起始位置*/ socklen_t msg_controllen;/*辅助数据的大小*/ int msg_flags;/*复制函数中的flags参数，并在调用过程中更新*/&#125;; msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。msg_namelen成员则指定了msg_name所指socket地址的长度。msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下 12345struct iovec&#123;void*iov_base;/*内存起始地址*/size_t iov_len;/*这块内存的长度*/&#125;; 由上可见，iovec结构体封装了一块内存的起始位置和长度。msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为集中写（gather write） msg_control和msg_controllen成员用于辅助数据的传送。我们不详细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件描述符。 msg_flags成员无须设定，它会复制recvmsg&#x2F;sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。 recvmsg&#x2F;sendmsg的flags参数以及返回值的含义均与send&#x2F;recv的flags参数及返回值相同。 由于socket连接是全双工的，这里的“读端”是针对通信对方而言的 实现自己的简单的tcp通信带外标记紧急标志 ###地址信息函数 获取一个连接socket的本端socket地址，以及远端的socket地址 socket选项专门用来读取和设置socket文件描述符属性 网络信息APIipv4转移到ipv6不便扩展，使用主机名访问机器，避免直接使用ip 高级I&#x2F;O函数-不常用，但是特定和场景下性能优秀 用于创建文件描述符的函数，包括pipe、dup&#x2F;dup2函数 文件描述符的读写数据，包括readv&#x2F;writev、sendfile、mmap&#x2F;munmap、splice和tee函数 用于控制I&#x2F;O行为和属性的函数，包括fcntl函数 pipe函数创建管道 进程间通信 dup函数和dup2函数dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。 readv函数和writev函数readv函数将数据从文件描述符读到分散的内存块中，即分散读； writev函数则将多块分散的内存数据一并写入文件描述符中 Linux服务器程序规范 Linux服务器程序一般以后台进程形式运行。后台进程又称守护进程（daemon）。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程（PID为1的进程）。 Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在&#x2F;var&#x2F;log目录下拥有自己的日志目录。 Linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、apache和syslog Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在&#x2F;etc目录下。比如第4章讨论的squid服务器的配置文件是&#x2F;etc&#x2F;squid3&#x2F;squid.conf。 Linux服务器进程通常会在启动的时候生成一个PID文件并存入&#x2F;var&#x2F;run目录中，以记录该后台进程的PID。比如syslogd的PID文件是&#x2F;var&#x2F;run&#x2F;syslogd.pid Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等 日志####Linux系统日志 工欲善其事，必先利其器。 作用 服务器的调试和维护都需要一个专业的日志系统。 原理 Linux提供一个守护进程来处理系统日志——syslogd的升级版rsyslogd。rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。 接收用户进程输出的日志 用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件&#x2F;dev&#x2F;log中，rsyslogd则监听该文件以获取用户进程的输出。 接收内核日志 内核日志在老的系统上是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到&#x2F;proc&#x2F;kmsg文件中。rsyslogd则通过读取该文件获得内核日志rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存至&#x2F;var&#x2F;log&#x2F;debug文件，普通信息保存至&#x2F;var&#x2F;log&#x2F;messages文件，内核消息则保存至&#x2F;var&#x2F;log&#x2F;kern.log文件。 配置文件 日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd的主配置文件是&#x2F;etc&#x2F;rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见&#x2F;etc&#x2F;services文件），是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件（比如&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf）。rsyslogd的子配置文件则指定各类日志的目标存储文件 syslog函数#include＜syslog.h＞ void syslog(int priority,const char*message,…) 该函数采用可变参数（第二个参数message和第三个参数…）来结构化输出。priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日志级别有如下几个： 123456789#include＜syslog.h＞#define LOG_EMERG 0/*系统不可用*/#define LOG_ALERT 1/*报警，需要立即采取动作*/#define LOG_CRIT 2/*非常严重的情况*/#define LOG_ERR 3/*错误*/#define LOG_WARNING 4/*警告*/#define LOG_NOTICE 5/*通知*/#define LOG_INFO 6/*信息*/#define LOG_DEBUG 7/*调试*/ 下面这个函数可以改变syslog的默认输出方式，进一步结构化日志内容： #include＜syslog.h＞ void openlog(const char*ident,int logopt,int facility) ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或： 1234#define LOG_PID 0x01/*在日志消息中包含程序PID*/#define LOG_CONS 0x02/*如果消息不能记录到日志文件，则打印至终端*/#define LOG_ODELAY 0x04/*延迟打开日志功能直到第一次调用syslog*/#define LOG_NDELAY 0x08/*不延迟打开日志功能*/ facility参数可用来修改syslog函数中的默认设施值。 此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码（因为日后可能还需要用到），而是简单地设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。下面这个函数用于设置syslog的日志掩码： #include＜syslog.h＞ int setlogmask(int maskpri); maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。最后，不要忘了使用如下函数关闭日志功能： #include＜syslog.h＞ void closelog(); 高性能服务器程序框架 I&#x2F;O处理单元。本章将介绍I&#x2F;O处理单元的四种I&#x2F;O模型和两种高效事件处理模式 逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机 存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关 服务器模型C&#x2F;S模型 服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。 服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。 由于客户连接请求是随机到达的异步事件，服务器需要使用某种I&#x2F;O模型来监听这一事件。I&#x2F;O模型有多种，图8-2中，服务器使用的是I&#x2F;O复用技术之一的select系统调用。当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他。图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。 服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了图8-2中，服务器同时监听多个客户请求是通过select系统调用实现的。 C&#x2F;S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。下面讨论的P2P模型解决了这个问题 ####P2P模型 P2P（Peer to Peer，点对点）模型比C&#x2F;S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。 P2P模型如图8-3a所示。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。云计算机群可以看作P2P模型的一个典范。但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重。 图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图8-3b所示。这个发现服务器通常还提供查找服务（甚至还可以提供内容服务），使每个客户都能尽快地找到自己需要的资源。 从编程角度来讲，P2P模型可以看作C&#x2F;S模型的扩展：每台主机既是客户端，又是服务器。因此，我们仍然采用C&#x2F;S模型来讨论网络编程 服务器编程框架 该图既能用来描述一台服务器，也能用来描述一个服务器机群 模块 单个服务器 服务器集群 I&#x2F;O处理单元 处理客户端连接，读写网络数据 作为接入服务器，实现负载均衡 逻辑单元 业务进程，线程 逻辑服务器 网络存储单元 本地数据库，文件，缓存 数据库服务器 请求队列 各单元之间通信方式 各服务器之间永久tcp连接 负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。 服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。 网络存储单元不是必须的，比如ssh、telnet等登录服务就不需要这个单元 请求队列是各单元之间的通信方式的抽象。I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。 I&#x2F;O模型socket在创建的时候默认是阻塞的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。我们称阻塞的文件描述符为阻塞I&#x2F;O，称非阻塞的文件描述符为非阻塞I&#x2F;O。 针对阻塞I&#x2F;O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。 针对非阻塞I&#x2F;O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。很显然，我们只有在事件已经发生的情况下操作非阻塞I&#x2F;O（读、写等），才能提高程序的效率。因此，非阻塞I&#x2F;O通常要和其他I&#x2F;O通知机制一起使用，比如I&#x2F;O复用和SIGIO信号。 I&#x2F;O复用是最常使用的I&#x2F;O通知机制。它指的是，应用程序通过I&#x2F;O复用函数向内核注册一组事件，内核通过I&#x2F;O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I&#x2F;O复用函数是select、poll和epoll_wait。需要指出的是，I&#x2F;O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I&#x2F;O事件的能力。 SIGIO信号也可以用来报告I&#x2F;O事件。我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I&#x2F;O操作了。 从理论上说，阻塞I&#x2F;O、I&#x2F;O复用和信号驱动I&#x2F;O都是同步I&#x2F;O模型。因为在这三种I&#x2F;O模型中，I&#x2F;O的读写操作，都是在I&#x2F;O事件发生之后，由应用程序来完成的。而POSIX规范所定义的异步I&#x2F;O模型则不同。对异步I&#x2F;O而言，用户可以直接对I&#x2F;O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I&#x2F;O操作完成之后内核通知应用程序的方式。异步I&#x2F;O的读写操作总是立即返回，而不论I&#x2F;O是否是阻塞的，因为真正的读写操作已经由内核接管。也就是说，同步I&#x2F;O模型要求用户代码自行执行I&#x2F;O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I&#x2F;O机制则由内核来执行I&#x2F;O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。你可以这样认为，同步I&#x2F;O向应用程序通知的是I&#x2F;O就绪事件，而异步I&#x2F;O向应用程序通知的是I&#x2F;O完成事件。Linux环境下，aio.h头文件中定义的函数提供了对异步I&#x2F;O的支持。不过这部分内容不是本书的重点，所以只做简单的讨论 两种高效的事件处理模式服务器程序通常需要处理三类事件：I&#x2F;O事件、信号及定时事件。 两种高效的事件处理模式：Reactor和Proactor。 同步I&#x2F;O模型通常用于实现Reactor模式，异步I&#x2F;O模型则用于实现Proactor模式。 Reactor模式主线程（I&#x2F;O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。 使用同步I&#x2F;O模型（以epoll_wait为例）实现的Reactor模式的工作流程是： 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 2）主线程调用epoll_wait等待socket上有数据可读。 3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。 4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 5）主线程调用epoll_wait等待socket可写。 6）当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果 工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它：对于可读事件，执行读数据和处理请求的操作；对于可写事件，执行写数据的操作。因此，所示的Reactor模式中，没必要区分所谓的“读工作线程”和“写工作线程”。 Proactor模式与Reactor模式不同，Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。Proactor模式更符合服务器编程框架。 使用异步I&#x2F;O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是： 1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册）。 2）主线程继续处理其他逻辑。 3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。 5）主线程继续处理其他逻辑。 6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 连接socket上的读写事件是通过aio_read&#x2F;aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件。 模拟Proactor模式使用同步I&#x2F;O方式模拟出Proactor模式的一种方法。其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 使用同步I&#x2F;O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程如下： 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 2）主线程调用epoll_wait等待socket上有数据可读。 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。 5）主线程调用epoll_wait等待socket可写。 6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 两种高效的并发模式并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 但如果程序是I&#x2F;O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I&#x2F;O操作的速度远没有CPU的计算速度快，所以让程序阻塞于I&#x2F;O操作将浪费大量的CPU时间。 并发编程主要有多进程和多线程两种方式，这一节先讨论并发模式。 服务器主要有两种并发编程模式：半同步&#x2F;半异步（half-sync&#x2F;halfasync）模式和领导者&#x2F;追随者（Leader&#x2F;Followers）模式。 半同步&#x2F;半异步模式在I&#x2F;O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I&#x2F;O事件（是就绪事件还是完成事件），以及该由谁来完成I&#x2F;O读写（是应用程序还是内核）。 在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。 按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且不适合于大量的并发。而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步&#x2F;半异步模式来实现。 半同步&#x2F;半异步模式中，同步线程用于处理客户逻辑；异步线程用于处理I&#x2F;O事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量或信号量来随机地选择一个工作线程。 在服务器程序中，如果结合考虑两种事件处理模式和几种I&#x2F;O模型，则半同步&#x2F;半异步模式就存在多种变体。其中有一种变体称为半同步&#x2F;半反应堆（half-sync&#x2F;half-reactive）模式 异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。 主线程插入请求队列中的任务是就绪的连接socket。这说明该图所示的半同步&#x2F;半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。实际上，半同步&#x2F;半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其（或者指向该任务对象的一个指针）插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。我们将在第15章给出一个用半同步&#x2F;半反应堆模式实现的简单Web服务器的代码。 半同步&#x2F;半反应堆模式存在如下缺点： 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间。 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU时间。 一种高效的半同步&#x2F;半异步模式 每个工作线程都能同时处理多个客户连接。 主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I&#x2F;O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。 每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步&#x2F;半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步&#x2F;半异步模式。 领导者&#x2F;追随者模式领导者&#x2F;追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听I&#x2F;O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I&#x2F;O事件，首先要从线程池中推选出新的领导者线程，然后处理I&#x2F;O事件。此时，新的领导者等待新的I&#x2F;O事件，而原来的领导者则处理I&#x2F;O事件，二者实现了并发。 领导者&#x2F;追随者模式包含如下几个组件：句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。 有限状态机有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑 1234567891011STATE_MACHINE(Package_pack)&#123; PackageType_type=_pack.GetType(); switch(_type)&#123; case type_A: process_package_A(_pack); break; case type_B: process_package_B(_pack); break; &#125;&#125; 该状态机的每个状态都是相互独立的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动的 12345678910111213141516STATE_MACHINE()&#123; State cur_State=type_A; while(cur_State!=type_C)&#123; Package_pack=getNewPackage(); switch(cur_State)&#123; case type_A: process_package_state_A(_pack); cur_State=type_B; break; case type_B: process_package_state_B(_pack); cur_State=type_C; break; &#125; &#125;&#125; 该状态机包含三种状态：type_A、type_B和type_C，其中type_A是状态机的开始状态，type_C是状态机的结束状态。状态机的当前状态记录在cur_State变量中。在一趟循环过程中，状态机先通过getNewPackage方法获得一个新的数据包，然后根据cur_State变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。 下面我们考虑有限状态机应用的一个实例：HTTP请求的读取和分析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。但HTTP协议并未提供这样的头部长度字段，并且其头部长度变化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， 我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回车换行符（＜CR＞＜LF＞）。如果一次读操作没有读入HTTP请求的整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP请求头部的分析（记住，空行前面还有请求行和头部域），以提高解析HTTP请求的效率。代码清单8-3使用主、从两个有限状态机实现了最简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称HTTP请求的一行（包括请求行和头部字段）为行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#define BUFFER_SIZE 4096 /*读缓冲区大小*//*主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段*/enum CHECK_STATE&#123; CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER&#125;;/*从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整*/enum LINE_STATUS&#123; LINE_OK = 0, LINE_BAD, LINE_OPEN&#125;;/*服务器处理HTTP请求的结果：NO_REQUEST表示请求不完整，需要继续读取客户数据；GET_REQUEST表示获得了一个完整的客户请求；BAD_REQUEST表示客户请求有语法错误；FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；INTERNAL_ERROR表示服务器内部错误；CLOSED_CONNECTION表示客户端已经关闭连接了*/enum HTTP_CODE&#123; NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION&#125;;/*为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息*/static const char *szret[] = &#123;&quot;I get a correct result\\n&quot;, &quot;Something wrong\\n &quot;&#125;;/*从状态机，用于解析出一行内容*/LINE_STATUS parse_line(char *buffer, int &amp;checked_index, int &amp;read_index)&#123; char temp; /*checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节， read_index指向buffer中客户数据的尾部的下一字节。buffer中第0～checked_index 字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨个分析*/ for (; checked_index &lt; read_index; ++checked_index) &#123; /*获得当前要分析的字节*/ temp = buffer[checked_index]; /*如果当前的字节是“\\r”，即回车符，则说明可能读取到一个完整的行*/ if (temp == &#x27;\\r&#x27;) &#123; /*如果“\\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据，那么这次分 析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分 析*/ if ((checked_index + 1) == read_index) &#123; return LINE_OPEN; &#125; /*如果下一个字符是“\\n”，则说明我们成功读取到一个完整的行*/ else if (buffer[checked_index + 1] == &#x27;\\n&#x27;) &#123; buffer[checked_index++] = &#x27;\\0&#x27;; buffer[checked_index++] = &#x27;\\0&#x27;; return LINE_OK; &#125; /*否则的话，说明客户发送的HTTP请求存在语法问题*/ return LINE_BAD; &#125; /*如果当前的字节是“\\n”，即换行符，则也说明可能读取到一个完整的行*/ else if (temp == &#x27;\\n&#x27;) &#123; if ((checked_index &gt; 1) &amp;&amp; buffer[checked_index - 1] == &#x27;\\r&#x27;) &#123; buffer[checked_index - 1] = &#x27;\\0&#x27;; buffer[checked_index++] = &#x27;\\0&#x27;; return LINE_OK; &#125; return LINE_BAD; &#125; &#125; /*如果所有内容都分析完毕也没遇到“\\r”字符，则返回LINE_OPEN，表示还需要继续读 取客户数据才能进一步分析*/ return LINE_OPEN;&#125;/*分析请求行*/HTTP_CODE parse_requestline(char *temp, CHECK_STATE &amp;checkstate)&#123; char *url = strpbrk(temp, &quot;\\t&quot;); /*如果请求行中没有空白字符或“\\t”字符，则HTTP请求必有问题*/ if (!url) &#123; return BAD_REQUEST; &#125; *url++ = &#x27;\\0&#x27;; char *method = temp; if (strcasecmp(method, &quot;GET&quot;) == 0) /*仅支持GET方法*/ &#123; printf(&quot;The request method is GET\\n&quot;); &#125; else &#123; return BAD_REQUEST; &#125; url += strspn(url, &quot;\\t&quot;); char *version = strpbrk(url, &quot;\\t&quot;); if (!version) &#123; return BAD_REQUEST; &#125; *version++ = &#x27;\\0&#x27;; version += strspn(version, &quot;\\t&quot;); /*仅支持HTTP/1.1*/ if (strcasecmp(version, &quot;HTTP/1.1&quot;) != 0) &#123; return BAD_REQUEST; &#125; /*检查URL是否合法*/ if (strncasecmp(url, &quot;http://&quot;, 7) == 0) &#123; url += 7; url = strchr(url, &#x27;/&#x27;); &#125; if (!url || url[0] != &#x27;/&#x27;) &#123; return BAD_REQUEST; &#125; printf(&quot;The request URL is:%s\\n&quot;, url); /*HTTP请求行处理完毕，状态转移到头部字段的分析*/ checkstate = CHECK_STATE_HEADER; return NO_REQUEST;&#125;/*分析头部字段*/HTTP_CODE parse_headers(char *temp)&#123; /*遇到一个空行，说明我们得到了一个正确的HTTP请求*/ if (temp[0] == &#x27;\\0&#x27;) &#123; return GET_REQUEST; &#125; else if (strncasecmp(temp, &quot;Host:&quot;, 5) == 0) /*处理“HOST”头部字段*/ &#123; temp += 5; temp += strspn(temp, &quot;\\t&quot;); printf(&quot;the request host is:%s\\n&quot;, temp); &#125; else /*其他头部字段都不处理*/ &#123; printf(&quot;I can not handle this header\\n&quot;); &#125; return NO_REQUEST;&#125;/*分析HTTP请求的入口函数*/HTTP_CODE parse_content(char *buffer, int &amp;checked_index, CHECK_STATE &amp;checkstate, int &amp;read_index, int &amp;start_line)&#123; LINE_STATUS linestatus = LINE_OK; /*记录当前行的读取状态*/ HTTP_CODE retcode = NO_REQUEST; /*记录HTTP请求的处理结果*/ /*主状态机，用于从buffer中取出所有完整的行*/ while ((linestatus = parse_line(buffer, checked_index, read_index)) == LINE_OK) &#123; char *temp = buffer + start_line; /*start_line是行在buffer中的起始位置*/ start_line = checked_index; /*记录下一行的起始位置*/ /*checkstate记录主状态机当前的状态*/ switch (checkstate) &#123; case CHECK_STATE_REQUESTLINE: /*第一个状态，分析请求行*/ &#123; retcode = parse_requestline(temp, checkstate); if (retcode == BAD_REQUEST) &#123; return BAD_REQUEST; &#125; break; &#125; case CHECK_STATE_HEADER: /*第二个状态，分析头部字段*/ &#123; retcode = parse_headers(temp); if (retcode == BAD_REQUEST) &#123; return BAD_REQUEST; &#125; else if (retcode == GET_REQUEST) &#123; return GET_REQUEST; &#125; break; &#125; default: &#123; return INTERNAL_ERROR; &#125; &#125; &#125; /*若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析*/ if (linestatus == LINE_OPEN) &#123; return NO_REQUEST; &#125; else &#123; return BAD_REQUEST; &#125;&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(listenfd &gt;= 0); int ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(listenfd, 5); assert(ret != -1); struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int fd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (fd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); &#125; else &#123; char buffer[BUFFER_SIZE]; /*读缓冲区*/ memset(buffer, &#x27;\\0&#x27;, BUFFER_SIZE); int data_read = 0; int read_index = 0; /*当前已经读取了多少字节的客户数据*/ int checked_index = 0; /*当前已经分析完了多少字节的客户数据*/ int start_line = 0; /*行在buffer中的起始位置*/ /*设置主状态机的初始状态*/ CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE; while (1) /*循环读取客户数据并分析之*/ &#123; data_read = recv(fd, buffer + read_index, BUFFER_SIZE - read_index, 0); if (data_read == -1) &#123; printf(&quot;reading failed\\n&quot;); break; &#125; else if (data_read == 0) &#123; printf(&quot;remote client has closed the connection\\n&quot;); break; &#125; read_index += data_read; /*分析目前已经获得的所有客户数据*/ HTTP_CODE result = parse_content(buffer, checked_index, checkstate, read_index, start_line); if (result == NO_REQUEST) /*尚未得到一个完整的HTTP请求*/ &#123; continue; &#125; else if (result == GET_REQUEST) /*得到一个完整的、正确的HTTP请求*/ &#123; send(fd, szret[0], strlen(szret[0]), 0); break; &#125; else /*其他情况表示发生错误*/ &#123; send(fd, szret[1], strlen(szret[1]), 0); break; &#125; &#125; close(fd); &#125; close(listenfd); return 0;&#125; 我们将代码清单中的两个有限状态机分别称为主状态机和从状态机，这体现了它们之间的关系：主状态机在内部调用从状态机。下面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图8-15描述了其可能的状态及状态转移过程 提高服务器性能的其他建议池既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，这就是池（pool）的概念。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。 不过，既然池中的资源是预先静态分配的，我们就无法预期应该分配多少资源。这个问题又该如何解决呢？ 最简单的解决方案就是分配“足够多”的资源 这通常会导致资源的浪费 还有一种解决方案是预先分配一定的资源，此后如果发现资源不够用，就再动态分配一些并加入池中。 根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。 内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。 进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程。 连接池通常用于服务器或服务器机群的内部永久连接。每个逻辑单元可能都需要频繁地访问本地的某个数据库。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。 数据复制高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心这些数据的内容，不需要对它们做任何分析。比如ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发送给客户端。 此外，用户代码内部（不访问内核）的数据复制也是应该避免的。举例来说， 当两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递 我们用指针（start_line）来指出每个行在buffer中的起始位置，以便随后对行内容进行访问，而不是把行的内容复制到另外一个缓冲区中来使用，因为这样既浪费空间，又效率低下。 上下文切换和锁并发程序必须考虑上下文切换（context switch）的问题，即进程切换或线程切换导致的的系统开销。即使是I&#x2F;O密集型的服务器，也不应该使用过多的工作线程（或工作进程，下同），否则线程间的切换将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的比重就显得不足了。因此，为每个客户连接都创建一个工作线程的服务器模型是不可取的。图8-11所描述的半同步&#x2F;半异步模式是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。当线程的数量不大于CPU的数目时，上下文的切换就不是问题了。 并发程序需要考虑的另外一个问题是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就应该避免使用锁。显然，图8-11所描述的半同步&#x2F;半异步模式就比图8-10所描述的半同步&#x2F;半反应堆模式的效率高。如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存时，系统才必须去锁住这块区域 I&#x2F;O复用I&#x2F;O复用允许单个线程或进程同时处理多个I&#x2F;O操作,而不需要为每个I&#x2F;O操作创建一个新的线程或进程 当内核发现进程指定的一个或多个I&#x2F;O条件就绪时（如输入数据已准备好被读取，或输出缓冲区有空间接收数据），它会给进程一个通知。这种功能主要通过select、poll和epoll等系统调用实现。 I&#x2F;O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要 客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞connect技术 客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序 TCP服务器要同时处理监听socket和连接socket。这是I&#x2F;O复用使用最多的场合。 服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的回射服务器 服务器要同时监听多个端口，或者处理多种服务。比如本章将要讨论的xinetd服务器 I&#x2F;O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。 ###select系统调用 select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。 select API12#include＜sys/select.h＞int select(int nfds,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval*timeout); nfds参数指定被监听的文件描述符的总数。它通常被设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的 readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。应用程序调用select函数时，通过这3个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。 fd_set结构体 12345678910111213141516#include＜typesizes.h＞#define__FD_SETSIZE 1024#include＜sys/select.h＞#define FD_SETSIZE__FD_SETSIZEtypedef long int__fd_mask;#undef__NFDBITS#define__NFDBITS(8*(int)sizeof(__fd_mask))typedef struct&#123;#ifdef__USE_XOPEN__fd_mask fds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-＞fds_bits)#else__fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-＞__fds_bits)#endif&#125;fd_set; 由以上定义可见，fd_set结构体仅包含一个整型数组，该数组的每个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量。 由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set结构体中的位： 12345#include＜sys/select.h＞FD_ZERO(fd_set*fdset);/*清除fdset的所有位*/FD_SET(int fd,fd_set*fdset);/*设置fdset的位fd*/FD_CLR(int fd,fd_set*fdset);/*清除fdset的位fd*/int FD_ISSET(int fd,fd_set*fdset);/*测试fdset的位fd是否被设置*/ timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序select等待了多久。不过我们不能完全信任select调用返回后的timeout值，比如调用失败时timeout值是不确定的。timeval结构体的定义如下： 1234struct timeval&#123;long tv_sec;/*秒数*/long tv_usec;/*微秒数*/&#125;; 由以上定义可见，select给我们提供了一个微秒级的定时方式。如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。select成功时返回就绪（可读、可写和异常）文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR 文件描述符就绪条件哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。 下列情况下socket可读： socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。 socket通信的对方关闭连接。此时对该socket的读操作将返回0。 监听socket上有新的连接请求。 socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。 下列情况下socket可写： socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。 socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。 socket使用非阻塞connect连接成功或者失败（超时）之后。 socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。 网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据 处理带外数据socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。代码清单9-1描述了select是如何同时处理二者的。 同时接收普通数据和带外数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(listenfd &gt;= 0); ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(listenfd, 5); assert(ret != -1); struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (connfd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); close(listenfd); &#125; char buf[1024]; fd_set read_fds;//声明文件描述符 fd_set exception_fds; FD_ZERO(&amp;read_fds); FD_ZERO(&amp;exception_fds);//清除所有位 while (1) &#123; memset(buf, &#x27;\\0&#x27;, sizeof(buf)); /*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生之后，文件描述符集合将被内核修改*/ FD_SET(connfd, &amp;read_fds);//设置位 FD_SET(connfd, &amp;exception_fds); ret = select(connfd + 1, &amp;read_fds, NULL, &amp;exception_fds, NULL); if (ret &lt; 0) &#123; printf(&quot;selection failure\\n&quot;); break; &#125; /*对于可读事件，采用普通的recv函数读取数据*/ if (FD_ISSET(connfd, &amp;read_fds))//如果位被设置 &#123; ret = recv(connfd, buf, sizeof(buf) - 1, 0); if (ret &lt;= 0) &#123; break; &#125; printf(&quot;get%d bytes of normal data:%s\\n&quot;, ret, buf); &#125; /*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/ else if (FD_ISSET(connfd, &amp;exception_fds)) &#123; ret = recv(connfd, buf, sizeof(buf) - 1, MSG_OOB); if (ret &lt;= 0) &#123; break; &#125; printf(&quot;get%d bytes of oob data:%s\\n&quot;, ret, buf); &#125; &#125; close(connfd); close(listenfd); return 0;&#125; poll系统调用poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者 12#include＜poll.h＞int poll(struct pollfd*fds,nfds_t nfds,int timeout); fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义如下： 12345struct pollfd&#123; int fd;/*文件描述符*/ short events;/*注册的事件*/ //告诉poll监听哪些事件 short revents;/*实际发生的事件，由内核填充*/&#125;; 使用POLLRDHUP事件时，我们需要在代码最开始处定义_GNU_SOURCE nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义 typedef unsigned long int nfds_t; timeout参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。 返回值与select返回值含义相同 如果在超时时间内没有任何文件描述符就绪，返回0。失败时返回-1并设置errno。如果在等待期间，程序接收到信号，则立即返回-1，并设置errno为EINTR epoll系列系统调用内核事件表epoll是Linux特有的I&#x2F;O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建： 12#include＜sys/epoll.h＞int epoll_create(int size) size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。 下面的函数用来操作epoll的内核事件表： int epoll_ctl(int epfd,int op,int fd,struct epoll_event*event) fd参数是要操作的文件描述符 op参数则指定操作类型。操作类型有如下3种： EPOLL_CTL_ADD，往事件表中注册fd上的事件 EPOLL_CTL_MOD，修改fd上的注册事件 EPOLL_CTL_DEL，删除fd上的注册事件 event参数指定事件，它是epoll_event结构指针类型。epoll_event的定义如下 struct epoll_event&#123; __uint32_t events;/*epoll事件*/ epoll_data_t data;/*用户数据*/ &#125;; 123456789101112* 其中events成员描述事件类型。epoll支持的事件类型和poll基本相同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的数据可读事件是EPOLLIN。但epoll有两个额外的事件类型——EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键* data成员用于存储用户数据，其类型epoll_data_t的定义如下：* * ~~~c typedef union epoll_data&#123; void*ptr; int fd; uint32_t u32; uint64_t u64; &#125;epoll_data_t; * epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数据。但由于epoll_data_t是一个联合体，我们不能同时使用其ptr成员和fd成员，因此，如果要将文件描述符和用户数据关联起来（正如8.5.2小节讨论的将句柄和事件处理器绑定一样），以实现快速的数据访问，只能使用其他手段，比如放弃使用epoll_data_t的fd成员，而在ptr指向的用户数据中包含fd。 * epoll_ctl成功时返回0，失败则返回-1并设置errno。 ####epoll_wait函数 epoll系列系统调用，它在一段超时时间内等待一组文件描述符上的事件 12#include＜sys/epoll.h＞int epoll_wait(int epfd,struct epoll_event*events,int maxevents,int timeout); 该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。 timeout参数的含义与poll接口的timeout参数相同。 maxevents参数指定最多监听多少个事件，它必须大于0。 epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。 poll和epoll在使用上的差别 12345678910111213141516/*如何索引poll返回的就绪文件描述符*/int ret=poll(fds,MAX_EVENT_NUMBER,-1);/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/for(int i=0;i＜MAX_EVENT_NUMBER;++i)&#123; if(fds[i].revents＆POLLIN)&#123; /*判断第i个文件描述符是否就绪*/ int sockfd=fds[i].fd; /*处理sockfd*/ &#125;&#125;/*如何索引epoll返回的就绪文件描述符*/int ret=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1);/*仅遍历就绪的ret个文件描述符*/for(int i=0;i＜ret;i++)&#123; int sockfd=events[i].data.fd;/*sockfd肯定就绪，直接处理*/&#125; LT和ET模式epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。 对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。 LT和ET模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#define MAX_EVENT_NUMBER 1024#define BUFFER_SIZE 10/*将文件描述符设置成非阻塞的*/int setnonblocking(int fd)&#123; int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option;&#125;/*将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式*/void addfd(int epollfd, int fd, bool enable_et)&#123; epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if (enable_et) &#123; event.events |= EPOLLET; &#125; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event); setnonblocking(fd);&#125;/*LT模式的工作流程*/void lt(epoll_event *events, int number, int epollfd, int listenfd)&#123; char buf[BUFFER_SIZE]; for (int i = 0; i &lt; number; i++) &#123; int sockfd = events[i].data.fd; if (sockfd == listenfd) &#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); addfd(epollfd, connfd, false); /*对connfd禁用ET模式*/ &#125; else if (events[i].events &amp; EPOLLIN) &#123; /*只要socket读缓存中还有未读出的数据，这段代码就被触发*/ printf(&quot;event trigger once\\n&quot;); memset(buf, &#x27;\\0&#x27;, BUFFER_SIZE); int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0); if (ret &lt;= 0) &#123; close(sockfd); continue; &#125; printf(&quot;get%d bytes of content:%s\\n&quot;, ret, buf); &#125; else &#123; printf(&quot;something else happened\\n&quot;); &#125; &#125;&#125;/*ET模式的工作流程*/void et(epoll_event *events, int number, int epollfd, int listenfd)&#123; char buf[BUFFER_SIZE]; for (int i = 0; i &lt; number; i++) &#123; int sockfd = events[i].data.fd; if (sockfd == listenfd) &#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); addfd(epollfd, connfd, true); /*对connfd开启ET模式*/ &#125; else if (events[i].events &amp; EPOLLIN) &#123; /*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所 有数据读出*/ printf(&quot;event trigger once\\n&quot;); while (1) &#123; memset(buf, &#x27;\\0&#x27;, BUFFER_SIZE); int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0); if (ret &lt; 0) &#123; /*对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。此后，epoll就能再次 触发sockfd上的EPOLLIN事件，以驱动下一次读操作*/ if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123; printf(&quot;read later\\n&quot;); break; &#125; close(sockfd); break; &#125; else if (ret == 0) &#123; close(sockfd); &#125; else &#123; printf(&quot;get%d bytes of content:%s\\n&quot;, ret, buf); &#125; &#125; &#125; else &#123; printf(&quot;something else happened\\n&quot;); &#125; &#125;&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(listenfd &gt;= 0); ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(listenfd, 5); assert(ret != -1); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd != -1); addfd(epollfd, listenfd, true); while (1) &#123; int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); if (ret &lt; 0) &#123; printf(&quot;epoll failure\\n&quot;); break; &#125; lt(events, ret, epollfd, listenfd); /*使用LT模式*/ // et(events,ret,epollfd,listenfd);/*使用ET模式*/ &#125; close(listenfd); return 0;&#125; 运行一下这段代码，然后telnet到这个服务器程序上并一次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发的次数要比LT模式下少很多 每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。 EPOLLONESHOT事件即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。这当然不是我们期望的。我们期望的是一个socket连接在任一时刻都只被一个线程处理。这一点可以使用epoll的EPOLLONESHOT事件实现。 对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;pthread.h&gt;#define MAX_EVENT_NUMBER 1024#define BUFFER_SIZE 1024struct fds&#123; int epollfd; int sockfd;&#125;;int setnonblocking(int fd)&#123; int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option;&#125;/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参数oneshot指定是否注册fd上的EPOLLONESHOT事件*/void addfd(int epollfd, int fd, bool oneshot)&#123; epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; if (oneshot) &#123; event.events |= EPOLLONESHOT; &#125; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event); setnonblocking(fd);&#125;/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/void reset_oneshot(int epollfd, int fd)&#123; epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);&#125;/*工作线程*/void *worker(void *arg)&#123; int sockfd = ((fds *)arg)-&gt;sockfd; int epollfd = ((fds *)arg)-&gt;epollfd; printf(&quot;start new thread to receive data on fd:%d\\n&quot;, sockfd); char buf[BUFFER_SIZE]; memset(buf, &#x27;\\0&#x27;, BUFFER_SIZE); /*循环读取sockfd上的数据，直到遇到EAGAIN错误*/ while (1) &#123; int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0); if (ret == 0) &#123; close(sockfd); printf(&quot;foreiner closed the connection\\n&quot;); break; &#125; else if (ret &lt; 0) &#123; if (errno == EAGAIN) &#123; reset_oneshot(epollfd, sockfd); printf(&quot;read later\\n&quot;); break; &#125; &#125; else &#123; printf(&quot;get content:%s\\n&quot;, buf); /*休眠5s，模拟数据处理过程*/ sleep(5); &#125; &#125; printf(&quot;end thread receiving data on fd:%d\\n&quot;, sockfd);&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(listenfd &gt;= 0); ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(listenfd, 5); assert(ret != -1); epoll_event events[MAX_EVENT_NUMBER]; int epollfd = epoll_create(5); assert(epollfd != -1); /*注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序 只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件 */ addfd(epollfd, listenfd, false); while (1) &#123; int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1); if (ret &lt; 0) &#123; printf(&quot;epoll failure\\n&quot;); break; &#125; for (int i = 0; i &lt; ret; i++) &#123; int sockfd = events[i].data.fd; if (sockfd == listenfd) &#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); /*对每个非监听文件描述符都注册EPOLLONESHOT事件*/ addfd(epollfd, connfd, true); &#125; else if (events[i].events &amp; EPOLLIN) &#123; pthread_t thread; fds fds_for_new_worker; fds_for_new_worker.epollfd = epollfd; fds_for_new_worker.sockfd = sockfd; /*新启动一个工作线程为sockfd服务*/ pthread_create(&amp;thread, NULL, worker, (void *)&amp;fds_for_new_worker); &#125; else &#123; printf(&quot;something else happened\\n&quot;); &#125; &#125; &#125; close(listenfd); return 0;&#125; 从工作线程函数worker来看，如果一个工作线程处理完某个socket上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时，它调用reset_oneshot函数来重置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的EPOLLIN事件，进而使得其他线程有机会为该socket服务。 由此看来，尽管一个socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。 三组I&#x2F;O复用函数的比较直接看最后 这3组系统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返回值是就绪的文件描述符的数量。返回0表示没有事件发生。现在我们从事件集、最大支持文件描述符数、工作模式和具体实现等四个方面 这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。 select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。内核对fd_set集合的在线修改，应用程序下次调用select前不得不重置这3个fd_set集合。 poll的参数类型pollfd则多少“聪明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。 由于每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程序索引就绪文件描述符的时间复杂度为O（n）。 epoll则采用与select和poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度达到O（1）。 poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能达到系统允许打开的最大文件描述符数目，即65 535（cat&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max）。而select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果 select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。 select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O（n）。epoll_wait则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O（1）。但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发得过于频繁。所以epoll_wait适用于连接数量多，但活动连接较少的情况。 其他情况用poll，select没啥好处 I&#x2F;O复用的高级应用一：非阻塞connect这段话描述了connect出错时的一种errno值：EINPROGRESS。这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时。根据man文档的解释，在这种情况下，我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码是0，表示连接成功建立，否则连接失败。 通过上面描述的非阻塞connect方式，我们就能同时发起多个连接并一起等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#define BUFFER_SIZE 1023int setnonblocking(int fd)&#123; int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option;&#125;/*超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。函数成功时返回已经处于连接状态的socket，失败则返回-1*/int unblock_connect(const char *ip, int port, int time)&#123; int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int sockfd = socket(PF_INET, SOCK_STREAM, 0); int fdopt = setnonblocking(sockfd); ret = connect(sockfd, (struct sockaddr *)&amp;address, sizeof(address)); if (ret == 0) &#123; /*如果连接成功，则恢复sockfd的属性，并立即返回之*/ printf(&quot;connect with server immediately\\n&quot;); fcntl(sockfd, F_SETFL, fdopt); return sockfd; &#125; else if (errno != EINPROGRESS) &#123; /*如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进 行，否则出错返回*/ printf(&quot;unblock connect not support\\n&quot;); return -1; &#125; fd_set readfds; fd_set writefds; struct timeval timeout; FD_ZERO(&amp;readfds); FD_SET(sockfd, &amp;writefds); timeout.tv_sec = time; timeout.tv_usec = 0; ret = select(sockfd + 1, NULL, &amp;writefds, NULL, &amp;timeout); if (ret &lt;= 0) &#123; /*select超时或者出错，立即返回*/ printf(&quot;connection time out\\n&quot;); close(sockfd); return -1; &#125; if (!FD_ISSET(sockfd, &amp;writefds)) &#123; printf(&quot;no events on sockfd found\\n&quot;); close(sockfd); return -1; &#125; int error = 0; socklen_t length = sizeof(error); /*调用getsockopt来获取并清除sockfd上的错误*/ if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; 0) &#123; printf(&quot;get socket option failed\\n&quot;); close(sockfd); return -1; &#125; /*错误号不为0表示连接出错*/ if (error != 0) &#123; printf(&quot;connection failed after select with the error:%d\\n&quot;, error); close(sockfd); return -1; &#125; /*连接成功*/ printf(&quot;connection ready after select with the socket:%d\\n&quot;, sockfd); fcntl(sockfd, F_SETFL, fdopt); return sockfd;&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int sockfd = unblock_connect(ip, port, 10); if (sockfd &lt; 0) &#123; return 1; &#125; close(sockfd); return 0;&#125; 但遗憾的是，这种方法存在几处移植性问题。首先，非阻塞的socket可能导致connect始终失败。其次，select对处于EINPROGRESS状态下的socket可能不起作用。最后，对于出错的socket，getsockopt在有些系统（比如Linux）上返回-1（正如代码清单9-5所期望的），而在有些系统（比如源自伯克利的UNIX）上则返回0。这些问题没有一个统一的解决方法 I&#x2F;O复用的高级应用二：聊天室程序像ssh这样的登录服务通常要同时处理网络连接和用户输入，这也可以使用I&#x2F;O复用来实现。 我们以poll为例实现一个简单的聊天室程序，以阐述如何使用I&#x2F;O复用技术来同时处理网络连接和用户输入。该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。 其中客户端程序有两个功能：一是从标准输入终端读入用户数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器发送给它的数据。 服务器的功能是接收客户数据，并把客户数据发送给每一个登录到该服务器上的客户端（数据发送者除外）。 客户端客户端程序使用poll同时监听用户输入和网络连接，并利用splice函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据零拷贝，提高了程序执行效率。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _GNU_SOURCE 1 //为了使用POLLRDHUP事件#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;poll.h&gt;#include &lt;fcntl.h&gt;#define BUFFER_SIZE 64int main(int argc, char *argv[])&#123; //socket地址 创建 连接 if (argc &lt;= 2)&#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); struct sockaddr_in server_address; bzero(&amp;server_address, sizeof(server_address)); server_address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;server_address.sin_addr); server_address.sin_port = htons(port); int sockfd = socket(PF_INET, SOCK_STREAM, 0); assert(sockfd &gt;= 0); if (connect(sockfd, (struct sockaddr *)&amp;server_address, sizeof(server_address)) &lt; 0) &#123; printf(&quot;connection failed\\n&quot;); close(sockfd); return 1; &#125; pollfd fds[2];//poll轮询函数的第一个参数/*注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件*/ fds[0].fd = 0;//文件描述符 fds[0].events = POLLIN;//监听事件：数据可读 fds[0].revents = 0;//实际事件，内核填充 fds[1].fd = sockfd;//文件描述符为 连接socket fds[1].events = POLLIN | POLLRDHUP; //poll监听：数据可读 或 tcp被对方关闭或对方关闭了写操作 fds[1].revents = 0; char read_buf[BUFFER_SIZE]; int pipefd[2]; int ret = pipe(pipefd);//pipefd创建文件描述符 assert(ret != -1); while (1) &#123; //第二个参数是被监听事件集合fds的大小 ret = poll(fds, 2, -1);//轮询文件描述符，看是否有就绪者 -1：永远阻塞。直到监听的事件发生 if (ret &lt; 0)//失败返回-1 &#123; printf(&quot;poll failure\\n&quot;); break; &#125; if (fds[1].revents &amp; POLLRDHUP) &#123; printf(&quot;server close the connection\\n&quot;); break; &#125; else if (fds[1].revents &amp; POLLIN) &#123; memset(read_buf, &#x27;\\0&#x27;, BUFFER_SIZE); recv(fds[1].fd, read_buf, BUFFER_SIZE - 1, 0); printf(&quot;%s\\n&quot;, read_buf); &#125; if (fds[0].revents &amp; POLLIN)//？？？为啥不是POLLOUT &#123; /*使用splice将用户输入的数据直接写到sockfd上（零拷贝）*/ ret = splice(0, NULL, pipefd[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE); ret = splice(pipefd[0], NULL, sockfd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE); &#125; &#125; close(sockfd); return 0;&#125; 哪里写数据？？？ 服务器使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取时间的策略来提高服务器性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#define _GNU_SOURCE 1#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;poll.h&gt;#define USER_LIMIT 5 /*最大用户数量*/#define BUFFER_SIZE 64 /*读缓冲区的大小*/#define FD_LIMIT 65535 /*文件描述符数量限制*//*客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据*/struct client_data&#123; sockaddr_in address; char *write_buf; char buf[BUFFER_SIZE];&#125;;int setnonblocking(int fd)&#123; int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option;&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(listenfd &gt;= 0); ret = bind(listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(listenfd, 5); assert(ret != -1); /*创建users数组，分配FD_LIMIT个client_data对象。可以预期：每个可能的 socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的 下标）socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高 效的方式*/ client_data *users = new client_data[FD_LIMIT]; /*尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量*/ pollfd fds[USER_LIMIT + 1]; int user_counter = 0; for (int i = 1; i &lt;= USER_LIMIT; ++i) &#123; fds[i].fd = -1; fds[i].events = 0; &#125; fds[0].fd = listenfd; fds[0].events = POLLIN | POLLERR; fds[0].revents = 0; while (1) &#123; ret = poll(fds, user_counter + 1, -1); if (ret &lt; 0) &#123; printf(&quot;poll failure\\n&quot;); break; &#125; for (int i = 0; i &lt; user_counter + 1; ++i) &#123; if ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (connfd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); continue; &#125; /*如果请求太多，则关闭新到的连接*/ if (user_counter &gt;= USER_LIMIT) &#123; const char *info = &quot;too many users\\n&quot;; printf(&quot;%s&quot;, info); send(connfd, info, strlen(info), 0); close(connfd); continue; &#125; /*对于新的连接，同时修改fds和users数组。前文已经提到，users[connfd]对应 于新连接文件描述符connfd的客户数据*/ user_counter++; users[connfd].address = client_address; setnonblocking(connfd); fds[user_counter].fd = connfd; fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR; fds[user_counter].revents = 0; printf(&quot;comes a new user,now have%d users\\n&quot;, user_counter); &#125; else if (fds[i].revents &amp; POLLERR) &#123; printf(&quot;get an error from%d\\n&quot;, fds[i].fd); char errors[100]; memset(errors, &#x27;\\0&#x27;, 100); socklen_t length = sizeof(errors); if (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors, &amp;length) &lt; 0) &#123; printf(&quot;get socket option failed\\n&quot;); &#125; continue; &#125; else if (fds[i].revents &amp; POLLRDHUP) &#123; /*如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1*/ users[fds[i].fd] = users[fds[user_counter].fd]; close(fds[i].fd); fds[i] = fds[user_counter]; i--; user_counter--; printf(&quot;a client left\\n&quot;); &#125; else if (fds[i].revents &amp; POLLIN) &#123; int connfd = fds[i].fd; memset(users[connfd].buf, &#x27;\\0&#x27;, BUFFER_SIZE); ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - 1, 0); printf(&quot;get%d bytes of client data%sfrom%d\\n&quot;, ret, users[connfd].buf, connfd); if (ret &lt; 0) &#123; /*如果读操作出错，则关闭连接*/ if (errno != EAGAIN) &#123; close(connfd); users[fds[i].fd] = users[fds[user_counter].fd]; fds[i] = fds[user_counter]; i--; user_counter--; &#125; &#125; else if (ret == 0) &#123; &#125; else &#123; /*如果接收到客户数据，则通知其他socket连接准备写数据*/ for (int j = 1; j &lt;= user_counter; ++j) &#123; if (fds[j].fd == connfd) &#123; continue; &#125; fds[j].events |= ~POLLIN; fds[j].events |= POLLOUT; users[fds[j].fd].write_buf = users[connfd].buf; &#125; &#125; &#125; else if (fds[i].revents &amp; POLLOUT) &#123; int connfd = fds[i].fd; if (!users[connfd].write_buf) &#123; continue; &#125; ret = send(connfd, users[connfd].write_buf, strlen(users[connfd].write_buf), 0); users[connfd].write_buf = NULL; /*写完数据后需要重新注册fds[i]上的可读事件*/ fds[i].events |= ~POLLOUT; fds[i].events |= POLLIN; &#125; &#125; &#125; delete[] users; close(listenfd); return 0;&#125; ###I&#x2F;O复用的高级应用三：同时处理TCP和UDP服务 超级服务xinetd信号信号是由用户、系统或者进程 发送给 目标进程 的信息，以通知目标进程某个状态的改变或系统异常 对于前台进程，比如输入Ctrl+C通常会给进程发送一个中断信号 系统异常。比如浮点异常和非法内存段访问。 系统状态变化。比如alarm定时器到期将引起SIGALRM信号。 运行kill命令或调用kill函数。 服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止 Linux信号概述发送信号Linux下，一个进程给其他进程发送信号的API是kill函数。 123#include＜sys/types.h＞#include＜signal.h＞int kill(pid_t pid,int sig); 该函数把信号sig发送给目标进程；目标进程由pid参数指定，其可能的取值及含义如表所示。 Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在，因为检查工作总是在信号发送之前就执行。不过这种检测方式是不可靠的。一方面由于进程PID的回绕，可能导致被检测的PID不是我们期望的进程的PID；另一方面，这种检测方法不是原子操作。 该函数成功时返回0，失败则返回-1并设置errno。几种可能的errno 信号处理方式目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的原型如下 12#include＜signal.h＞typedef void(*__sighandler_t)(int); 信号处理函数只带有一个整型参数，该参数用来指示信号类型。信号处理函数应该是可重入的，否则很容易引发一些竞态条件。所以在信号处理函数中严禁调用一些不安全的函数。除了用户自定义信号处理函数外，bits&#x2F;signum.h头文件中还定义了信号的两种其他处理方式——SIG_IGN和SIG_DEL： 1234#include＜bits/signum.h＞#define SIG_DFL((__sighandler_t)0)#define SIG_IGN((__sighandler_t)1)//SIG_IGN表示忽略目标信号，SIG_DFL表示使用信号的默认处理方式。信号的默认处理方式有如下几种：结束进程（Term）、忽略信号（Ign）、结束进程并生成核心转储文件（Core）、暂停进程（Stop），以及继续进程（Cont）。 中断系统调用如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为该信号设置了信号处理函数，则默认情况下系统调用将被中断，并且errno被设置为EINTR。我们可以使用sigaction函数（见后文）为信号设置SA_RESTART标志以自动重启被该信号中断的系统调用。 对于默认行为是暂停进程的信号（比如SIGSTOP、SIGTTIN），如果我们没有为它们设置信号处理函数，则它们也可以中断某些系统调用（比如connect、epoll_wait）。POSIX没有规定这种行为，这是Linux独有的。 信号函数signal系统调用为一个信号设置处理函数 12#include＜signal.h＞_sighandler_t signal(int sig,_sighandler_t_handler) sig参数指出要捕获的信号类型。_handler参数是_sighandler_t类型的函数指针，用于指定信号sig的处理函数。 signal函数成功时返回一个函数指针，该函数指针的类型也是_sighandler_t。这个返回值是前一次调用signal函数时传入的函数指针，或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用signal的话）。 signal系统调用出错时返回SIG_ERR，并设置errno。 sigaction系统调用设置信号处理函数更好的版本 12#include＜signal.h＞int sigaction(int sig,const struct sigaction*act,struct sigaction*oact); sig参数指出要捕获的信号类型，act参数指定新的信号处理方式，oact参数则输出信号先前的处理方式（如果不为NULL的话）。act和oact都是sigaction结构体类型的指针，sigaction结构体描述了信号处理的细节，其定义如下： 12345678910111213141516struct sigaction&#123; #ifdef__USE_POSIX199309 union&#123; _sighandler_t sa_handler; void(*sa_sigaction)(int,siginfo_t*,void*); &#125; _sigaction_handler;#define sa_handler__sigaction_handler.sa_handler#define sa_sigaction__sigaction_handler.sa_sigaction#else _sighandler_t sa_handler;#endif _sigset_t sa_mask; int sa_flags; void(*sa_restorer)(void);&#125;; 该结构体中的sa_hander成员指定信号处理函数。sa_mask成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号掩码），以指定哪些信号不能发送给本进程。sa_mask是信号集sigset_t（_sigset_t的同义词）类型，该类型指定一组信号。关于信号集，我们将在后面介绍。sa_flags成员用于设置程序收到信号时的行为，其可选值如表10-4所示。 sa_restorer成员已经过时，最好不要使用。sigaction成功时返回0，失败则返回-1并设置errno。 信号集Linux使用数据结构sigset_t来表示一组信号。其定义如下： 12345#include＜bits/sigset.h＞#define_SIGSET_NWORDS(1024/(8*sizeof(unsigned long int)))typedef struct&#123; unsigned long int__val[_SIGSET_NWORDS];&#125;__sigset_t; 由该定义可见，sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。Linux提供了如下一组函数来设置、修改、删除和查询信号集： 进程信号掩码被挂起的信号设置进程信号掩码后，被屏蔽的信号将不能被进程接收。 统一事件源信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）太久。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么主循环怎么知道管道上何时有数据可读呢?这很简单，我们只需要使用I&#x2F;O复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他I&#x2F;O事件一样被处理，即统一事件源。 网络编程相关信号SIGHUP当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。一个典型的例子是xinetd超级服务程序。xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数（见xinetd源码），它循环读取&#x2F;etc&#x2F;xinetd.d&#x2F;目录下的每个子配置文件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送SIGTERM信号以结束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建新的socket并将其绑定到该服务对应的端口上。下面我们简单地分析xinetd处理SIGHUP信号的流程。 ##定时器 比如定期检测一个客户连接的活动状态。我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。 定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码中依次处理所有到期的定时器 linux三种定时方法 socket选项SO_RCVTIMEO和SO_SNDTIMEO SIGALRM信号 I&#x2F;O复用系统调用的超时参数 ###socket选项SO_RCVTIMEO和SO_SNDTIMEO 分别设置socket接收数据超时时间和发送数据超时时间 我们可以根据系统调用（send、sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务。 connect为例，说明程序中如何使用SO_SNDTIMEO选项来定时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;/*超时连接函数*/int timeout_connect(const char *ip, int port, int time)&#123; int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;address.sin_addr); address.sin_port = htons(port); int sockfd = socket(PF_INET, SOCK_STREAM, 0); assert(sockfd &gt;= 0); /*通过选项SO_RCVTIMEO和SO_SNDTIMEO所设置的超时时间的类型是timeval，这和 select系统调用的超时参数类型相同*/ struct timeval timeout; timeout.tv_sec = time; timeout.tv_usec = 0; socklen_t len = sizeof(timeout); ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len); assert(ret != -1); ret = connect(sockfd, (struct sockaddr *)&amp;address, sizeof(address)); if (ret == -1) &#123; /*超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任 务了*/ if (errno == EINPROGRESS) &#123; printf(&quot;connecting timeout,process timeout logic\\n&quot;); return -1; &#125; printf(&quot;error occur when connecting to server\\n&quot;); return -1; &#125; return sockfd;&#125;int main(int argc, char *argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;usage:%s ip_address port_number\\n&quot;, basename(argv[0])); return 1; &#125; const char *ip = argv[1]; int port = atoi(argv[2]); int sockfd = timeout_connect(ip, port, 10); if (sockfd &lt; 0) &#123; return 1; &#125; return 0;&#125; SIGALRM信号由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设置的定时周期T保持不变。如果某个定时任务的超时时间不是T的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期T反映了定时的精度。 本节中我们通过一个实例——处理非活动连接，来介绍如何使用SIGALRM信号定时。不过，我们需要先给出一种简单的定时器实现——基于升序链表的定时器，并把它应用到处理非活动连接这个实例中。这样，我们才能观察到SIGALRM信号处理函数是如何处理定时器并执行定时任务的。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。 基于升序链表的定时器定时器通常至少要包含两个成员：一个超时时间（相对时间或者绝对时间）和一个任务回调函数。有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。 升序定时器链表将其中的定时器按照超时时间做升序排序。 代码。。。 为了便于阅读，我们将实现包含在头文件中。sort_timer_lst是一个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)，执行定时任务的时间复杂度是O(1)。 处理非活动连接升序定时器链表的实际应用-定期处理非活动连接 给客户端发一个重连请求，或者关闭该连接，或者其他。Linux在内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。因此，我们可以考虑在应用层实现类似于KEEPALIVE的机制，以管理所有长时间处于非活动状态的连接。比如，代码清单11-3利用alarm函数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。 代码。。。 I&#x2F;O复用系统调用的超时参数Linux下的3组I&#x2F;O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I&#x2F;O事件，也能统一处理定时事件。但是由于I&#x2F;O复用系统调用可能在超时时间到期之前就返回（有I&#x2F;O事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间 代码。。。 高性能定时器时间轮基于排序链表的定时器存在一个问题：添加定时器的效率偏低 时间堆前面讨论的定时方案都是以固定的频率调用心搏函数tick，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数。设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时 最小堆很适合处理这种定时方案。最小堆是指每个节点的值都小于或等于其子节点的值的完全二叉树。图11-2给出了一个具有6个元素的最小堆。 高性能I&#x2F;O框架库Libevent前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须处理的三类事件：I&#x2F;O事件、信号和定时事件。在处理这三类事件时我们通常需要考虑如下三个问题： 统一事件源。很明显，统一处理这三类事件既能使代码简单易懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事件源的一般方法——利用I&#x2F;O复用系统调用来管理所有事件 可移植性。不同的操作系统具有不同的I&#x2F;O复用方式，比如Solaris的dev&#x2F;poll文件，FreeBSD的kqueue机制，Linux的epoll系列系统调用。 对并发编程的支持。在多进程和多线程环境下，我们需要考虑各执行实体如何协同处理客户连接、信号和定时器，以避免竞态条件 所幸的是，开源社区提供了诸多优秀的I&#x2F;O框架库。它们不仅解决了上述问题，让开发者可以将精力完全放在程序的逻辑上，而且稳定性、性能等各方面都相当出色。比如ACE、ASIO和Libevent。本章将介绍其中相对轻量级的Libevent框架库。 多进程编程 复制进程映像的fork系统调用和替换进程映像的exec系列系统调用 僵尸进程以及如何避免僵尸进程 进程间通信（Inter-Process Communication，IPC）最简单的方式：管道。 3种System V进程间通信方式：信号量、消息队列和共享内存。它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC 在进程间传递文件描述符的通用方法：通过UNIX本地域socket传递特殊的辅助数据 ###fork系统调用 创建新进程 多线程编程（请忽略）早期Linux不支持线程，直到1996年，Xavier Leroy等人才开发出第一个基本符合POSIX标准的线程库LinuxThreads。但LinuxThreads效率低而且问题很多。自内核2.6开始，Linux才真正提供内核级的线程支持，并有两个组织致力于编写新的线程库：NGPT（Next Generation POSIX Threads）和NPTL（Native POSIX Thread Library）。不过前者在2003年就放弃了，因此新的线程库就称为NPTL。NPTL比LinuxThreads效率高，且更符合POSIX规范，所以它已经成为glibc的一部分。本书所有线程相关的例程使用的线程库都是NPTL。 本章要讨论的线程相关的内容都属于POSIX线程（简称pthread）标准，而不局限于NPTL实现，具体包括： 创建线程和结束线程 读取和设置线程属性 POSIX线程同步方式：POSIX信号量、互斥锁和条件变量 Linux线程概述线程模型线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境和调度者的身份，线程可分为内核线程和用户线程。内核线程，在有的系统上也称为LWP（Light Weight Process，轻量级进程），运行在内核空间，由内核来调度；用户线程运行在用户空间，由线程库来调度。当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。 完全在用户空间实现的线程无须内核的支持，内核甚至根本不知道这些线程的存在。线程库负责管理所有执行线程，比如线程的优先级、时间片等。线程库利用longjmp来切换线程的执行，使它们看起来像是“并发”执行的。但实际上内核仍然是把整个进程作为最小单位来调度的。换句话说，一个进程的所有执行线程共享该进程的时间片，它们对外表现出相同的优先级。因此，对这种实现方式而言，N&#x3D;1，即M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程本身。完全在用户空间实现的线程的优点是：创建和调度线程都无须内核的干预，因此速度相当快。并且由于它不占用额外的内核资源，所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影响。其缺点是：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程中的线程有效，比较不同进程中的线程的优先级没有意义。早期的伯克利UNIX线程就是采用这种方式实现的 完全由内核调度的模式将创建、调度线程的任务都交给了内核，运行在用户空间的线程库无须执行管理任务，这与完全在用户空间实现的线程恰恰相反。二者的优缺点也正好互换。较早的Linux内核对内核线程的控制能力有限，线程库通常还要提供额外的控制能力，尤其是线程同步机制，不过现代Linux内核已经大大增强了对线程的支持。完全由内核调度的这种线程实现方式满足M:N&#x3D;1:1，即1个用户空间线程被映射为1个内核线程。 双层调度模式是前两种实现模式的混合体：内核调度M个内核线程，线程库调度N个用户线程。这种线程实现方式结合了前两种方式的优点：不但不会消耗过多的内核资源，而且线程切换速度也较快，同时它可以充分利用多处理器的优势 Linux线程库Linux上两个最有名的线程库是LinuxThreads和NPTL，它们都是采用1:1的方式实现的。由于LinuxThreads在开发的时候，Linux内核对线程的支持还非常有限，所以其可用性、稳定性以及POSIX兼容性都远远不及NPTL。现代Linux上默认使用的线程库是NPTL。用户可以使用如下命令来查看当前系统上所使用的线程库： $getconf GNU_LIBPTHREAD_VERSION NPTL 2.28 创建线程和结束线程pthread_create 12#include＜pthread.h＞int pthread_create(pthread_t* thread,const pthread_attr_t* attr,void*(*start_routine)(void*),void*arg); thread参数是新线程的标识符 类型pthread_t的定义如下： #include＜bits&#x2F;pthreadtypes.h＞ typedef unsigned long int pthread_t; attr参数用于设置新线程的属性。给它传递NULL表示使用默认线程属性。线程拥有众多属性，我们将在后面详细讨论之。 start_routine和arg参数分别指定新线程将运行的函数及其参数 pthread_create成功时返回0，失败时返回错误码。一个用户可以打开的线程数量不能超过RLIMIT_NPROC软资源限制。此外，系统上所有用户能创建的线程总数也不得超过&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max内核参数所定义的值 pthread_join 线程一旦被创建好，内核就可以调度内核线程来执行start_routine函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以确保安全、干净地退出： 12#include＜pthread.h＞void pthread_exit(void*retval); pthread_exit函数通过retval参数向线程的回收者传递其退出信息。它执行完之后不会返回到调用者，而且永远不会失败。 pthread_join 一个进程中的所有线程都可以调用pthread_join函数来回收其他线程（前提是目标线程是可回收的），即等待其他线程结束，这类似于回收进程的wait和waitpid系统调用。pthread_join的定义如下： 12#include＜pthread.h＞int pthread_join(pthread_t thread,void**retval); thread参数是目标线程的标识符，retval参数则是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回0，失败则返回错误码。 pthread_cancel 异常终止一个线程，即取消线程 int pthread_cancel(pthread_t thread); 数成功时返回0，失败则返回错误码。 接收到取消请求的目标线程可以决定是否允许被取消以及如何取消，这分别由如下两个函数完成 123#include＜pthread.h＞int pthread_setcancelstate(int state,int*oldstate);int pthread_setcanceltype(int type,int*oldtype); 这两个函数的第一个参数分别用于设置线程的取消状态（是否允许取消）和取消类型（如何取消），第二个参数则分别记录线程原来的取消状态和取消类型。 state参数有两个可选值： ❑PTHREAD_CANCEL_ENABLE，允许线程被取消。它是线程被创建时的默认取消状态。 ❑PTHREAD_CANCEL_DISABLE，禁止线程被取消。这种情况下，如果一个线程收到取消请求，则它会将请求挂起，直到该线程允许被取消。 type参数也有两个可选值 ❑PTHREAD_CANCEL_ASYNCHRONOUS，线程随时都可以被取消。它将使得接收到取消请求的目标线程立即采取行动。 线程属性123456#include＜bits/pthreadtypes.h＞#define__SIZEOF_PTHREAD_ATTR_T 36typedef union&#123; char__size[__SIZEOF_PTHREAD_ATTR_T]; long int__align;&#125;pthread_attr_t; 各种线程属性全部包含在一个字符数组中。 123456789101112131415161718192021222324#include＜pthread.h＞/*初始化线程属性对象*/int pthread_attr_init(pthread_attr_t*attr);/*销毁线程属性对象。被销毁的线程属性对象只有再次初始化之后才能继续使用*/int pthread_attr_destroy(pthread_attr_t*attr);/*下面这些函数用于获取和设置线程属性对象的某个属性*/int pthread_attr_getdetachstate(const pthread_attr_t*attr,int*detachstate);int pthread_attr_setdetachstate(pthread_attr_t* attr,int detachstate);int pthread_attr_getstackaddr(const pthread_attr_t*attr,void**stackaddr);int pthread_attr_setstackaddr(pthread_attr_t*attr,void*stackaddr);int pthread_attr_getstacksize(const pthread_attr_t*attr,size_t*stacksize);int pthread_attr_setstacksize(pthread_attr_t*attr,size_t stacksize);int pthread_attr_getstack(const pthread_attr_t*attr,void**stackaddr,size_t*stacksize);int pthread_attr_setstack(pthread_attr_t*attr,void*stackaddr,size_t stacksize);int pthread_attr_getguardsize(const pthread_attr_t*__attr,size_t*guardsize);int pthread_attr_setguardsize(pthread_attr_t*attr,size_t guardsize);int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param*param);int pthread_attr_setschedparam(pthread_attr_t*attr,const struct sched_param*param);int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int*policy);int pthread_attr_setschedpolicy(pthread_attr_t*attr,int policy);int pthread_attr_getinheritsched(const pthread_attr_t*attr,int*inherit);int pthread_attr_setinheritsched(pthread_attr_t*attr,int inherit);int pthread_attr_getscope(const pthread_attr_t*attr,int*scope);int pthread_attr_setscope(pthread_attr_t*attr,int scope); detachstate，线程的脱离状态。它有PTHREAD_CREATE_JOINABLE和PTHREAD_CREATE_DETACH两个可选值。前者指定线程是可以被回收的，后者使调用线程脱离与进程中其他线程的同步。脱离了与其他线程同步的线程称为“脱离线程”。脱离线程在退出时将自行释放其占用的系统资源。线程创建时该属性的默认值是PTHREAD_CREATE_JOINABLE。此外，我们也可以使用pthread_detach函数直接将线程设置为脱离线程。 stackaddr和stacksize，线程堆栈的起始地址和大小 guardsize，保护区域大小 schedparam，线程调度参数 schedpolicy，线程调度策略 inheritsched，是否继承调用线程的调度属性 scope，线程间竞争CPU的范围，即线程优先级的有效范围 POSIX信号量线程同步的机制：POSIX信号量、互斥量和条件变量 信号量API有两组。一组是讨论过的System VIPC信号量，另外一组是POSIX信号量 原理语义相同 123456#include＜semaphore.h＞int sem_init(sem_t*sem,int pshared,unsigned int value);int sem_destroy(sem_t*sem);int sem_wait(sem_t*sem);int sem_trywait(sem_t*sem);int sem_post(sem_t*sem); sem指向被操作的信号量 sem_init函数用于初始化一个未命名的信号量（POSIX信号量API支持命名信号量）。pshared参数指定信号量的类型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则该信号量就可以在多个进程之间共享。value参数指定信号量的初始值。此外，初始化一个已经被初始化的信号量将导致不可预期的结果。 sem_destroy函数用于销毁信号量，以释放其占用的内核资源。如果销毁一个正被其他线程等待的信号量，则将导致不可预期的结果 sem_wait函数以原子操作的方式将信号量的值减1。如果信号量的值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。 sem_trywait与sem_wait函数相似，不过它始终立即返回，而不论被操作的信号量是否具有非0值，相当于sem_wait的非阻塞版本。当信号量的值非0时，sem_trywait对信号量执行减1操作。当信号量的值为0时，它将返回-1并设置errno为EAGAIN。 sem_post函数以原子操作的方式将信号量的值加1。当信号量的值大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。 上面这些函数成功时返回0，失败则返回-1并设置errno。 互斥锁互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占式的访问，这有点像一个二进制信号量。当进入关键代码段时，我们需要获得互斥锁并将其加锁，这等价于二进制信号量的P操作；当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，这等价于二进制信号量的V操作。 ####互斥锁基础API 123456#include＜pthread.h＞int pthread_mutex_init(pthread_mutex_t*mutex,const pthread_mutexattr_t*mutexattr);int pthread_mutex_destroy(pthread_mutex_t*mutex);int pthread_mutex_lock(pthread_mutex_t*mutex);int pthread_mutex_trylock(pthread_mutex_t*mutex);int pthread_mutex_unlock(pthread_mutex_t*mutex); mutex指向要操作的目标互斥锁，互斥锁的类型是pthread_mutex_t结构体。 pthread_mutex_init函数用于初始化互斥锁。mutexattr参数指定互斥锁的属性。如果将它设置为NULL，则表示使用默认属性。 使用另一种方式初始化一个互斥锁 pthread_mutex_t mutex&#x3D;PTHREAD_MUTEX_INITIALIZER; 这个宏把互斥锁的各个字段都初始化为0 pthread_mutex_destroy函数用于销毁互斥锁，以释放其占用的内核资源。销毁一个已经加锁的互斥锁将导致不可预期的后果 pthread_mutex_lock函数以原子操作的方式给一个互斥锁加锁。如果目标互斥锁已经被锁上，则pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。 pthread_mutex_trylock，始终立即返回，相当于pthread_mutex_lock的非阻塞版本。当目标互斥锁未被加锁时，pthread_mutex_trylock对互斥锁执行加锁操作。当互斥锁已经被加锁时，pthread_mutex_trylock将返回错误码EBUSY。 pthread_mutex_unlock函数以原子操作的方式给一个互斥锁解锁。如果此时有其他线程正在等待这个互斥锁，则这些线程中的某一个将获得它。 上面这些函数成功时返回0，失败则返回错误码。 互斥锁属性pthread_mutexattr_t结构体定义了一套完整的互斥锁属性。线程库提供了一系列函数来操作pthread_mutexattr_t类型的变量，以方便我们获取和设置互斥锁属性。这里我们列出其中一些主要的函数： 1234567891011#include＜pthread.h＞/*初始化互斥锁属性对象*/int pthread_mutexattr_init(pthread_mutexattr_t*attr);/*销毁互斥锁属性对象*/int pthread_mutexattr_destroy(pthread_mutexattr_t*attr);/*获取和设置互斥锁的pshared属性*/int pthread_mutexattr_getpshared(const pthread_mutexattr_t*attr,int*pshared);int pthread_mutexattr_setpshared(pthread_mutexattr_t*attr,int pshared);/*获取和设置互斥锁的type属性*/int pthread_mutexattr_gettype(const pthread_mutexattr_t*attr,int*type);int pthread_mutexattr_settype(pthread_mutexattr_t*attr,int type); 两种常用属性:pshared和type。 pshared指定是否允许跨进程共享互斥锁，其可选值有两个 PTHREAD_PROCESS_SHARED。互斥锁可以被跨进程共享 PTHREAD_PROCESS_PRIVATE。互斥锁只能被和锁的初始化线程隶属于同一个进程的线程共享 type指定互斥锁的类型 PTHREAD_MUTEX_NORMAL，普通锁。这是互斥锁默认的类型。当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了资源分配的公平性。但这种锁也很容易引发问题：一个线程如果对一个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致不可预期的后果 PTHREAD_MUTEX_ERRORCHECK，检错锁。一个线程如果对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错锁再次解锁，则解锁操作返回EPERM PTHREAD_MUTEX_RECURSIVE，嵌套锁。这种锁允许一个线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要获得这个锁，则当前锁的拥有者必须执行相应次数的解锁操作。对一个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁再次解锁，则解锁操作返回EPERM PTHREAD_MUTEX_DEFAULT，默认锁。一个线程如果对一个已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的后果。这种锁在实现的时候可能被映射为上面三种锁之一。 死锁举例死锁使得一个或多个线程被挂起而无法继续执行，而且这种情况还不容易被发现。前文提到，在一个线程中对一个已经加锁的普通锁再次加锁，将导致死锁。这种情况可能出现在设计得不够仔细的递归函数中。另外，如果两个线程按照不同的顺序来申请两个互斥锁，也容易产生死锁 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int a = 0;int b = 0;pthread_mutex_t mutex_a;pthread_mutex_t mutex_b;void *another(void *arg)&#123; pthread_mutex_lock(&amp;mutex_b); printf(&quot;in child thread,got mutex b,waiting for mutex a\\n&quot;); sleep(5); ++b; pthread_mutex_lock(&amp;mutex_a); b += a++; pthread_mutex_unlock(&amp;mutex_a); pthread_mutex_unlock(&amp;mutex_b); pthread_exit(NULL);&#125;int main()&#123; pthread_t id; pthread_mutex_init(&amp;mutex_a, NULL); pthread_mutex_init(&amp;mutex_b, NULL); pthread_create(&amp;id, NULL, another, NULL); pthread_mutex_lock(&amp;mutex_a); printf(&quot;in parent thread,got mutex a,waiting for mutex b\\n&quot;); sleep(5); ++a; pthread_mutex_lock(&amp;mutex_b); a += b++; pthread_mutex_unlock(&amp;mutex_b); pthread_mutex_unlock(&amp;mutex_a); pthread_join(id, NULL); pthread_mutex_destroy(&amp;mutex_a); pthread_mutex_destroy(&amp;mutex_b); return 0;&#125; 主线程试图先占有互斥锁mutex_a，然后操作被该锁保护的变量a，但操作完毕之后，主线程并没有立即释放互斥锁mutex_a，而是又申请互斥锁mutex_b，并在两个互斥锁的保护下，操作变量a和b，最后才一起释放这两个互斥锁； 与此同时，子线程则按照相反的顺序来申请互斥锁mutex_a和mutex_b，并在两个锁的保护下操作变量a和b。 我们用sleep函数来模拟连续两次调用pthread_mutex_lock之间的时间差，以确保代码中的两个线程各自先占有一个互斥锁（主线程占有mutex_a，子线程占有mutex_b），然后等待另外一个互斥锁（主线程等待mutex_b，子线程等待mutex_a）。这样，两个线程就僵持住了，谁都不能继续往下执行，从而形成死锁。 如果代码中不加入sleep函数，则这段代码或许总能成功地运行，从而为程序留下了一个潜在的BUG。 条件变量如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程 123456#include＜pthread.h＞int pthread_cond_init(pthread_cond_t*cond,const pthread_condattr_t* cond_attr);int pthread_cond_destroy(pthread_cond_t*cond);int pthread_cond_broadcast(pthread_cond_t*cond);int pthread_cond_signal(pthread_cond_t*cond);int pthread_cond_wait(pthread_cond_t*cond,pthread_mutex_t*mutex); 这些函数的第一个参数cond指向要操作的目标条件变量，条件变量的类型是pthread_cond_t结构体 pthread_cond_init函数用于初始化条件变量。cond_attr参数指定条件变量的属性。如果将它设置为NULL，则表示使用默认属性。条件变量的属性不多，而且和互斥锁的属性类型相似，所以我们不再赘述。 我们还可以使用如下方式来初始化一个条件变量： pthread_cond_t cond&#x3D;PTHREAD_COND_INITIALIZER; 是把条件变量的各个字段都初始化为0 pthread_cond_destroy函数用于销毁条件变量，以释放其占用的内核资源。销毁一个正在被等待的条件变量将失败并返回EBUSY。 pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件变量的线程。 pthread_cond_signal函数用于唤醒一个等待目标条件变量的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策略。有时候我们可能想唤醒一个指定的线程，但pthread没有对该需求提供解决方法。不过我们可以间接地实现该需求：定义一个能够唯一表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就开始执行后续代码，如果不是则返回继续等待。 pthread_cond_wait函数用于等待目标条件变量。mutex参数是用于保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。在调用pthread_cond_wait前，必须确保互斥锁mutex已经加锁，否则将导致不可预期的结果。pthread_cond_wait函数执行时，首先把调用线程放入条件变量的等待队列中，然后将互斥锁mutex解锁。可见，从pthread_cond_wait开始执行到其调用线程被放入条件变量的等待队列之间的这段时间内，pthread_cond_signal和pthread_cond_broadcast等函数不会修改条件变量。换言之，pthread_cond_wait函数不会错过目标条件变量的任何变化。当pthread_cond_wait函数成功返回时，互斥锁mutex将再次被锁上。 上面这些函数成功时返回0，失败则返回错误码。 线程同步机制包装类为了充分复用代码，同时由于后文的需要，我们将前面讨论的3种线程同步机制分别封装成3个类，实现在locker.h文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#ifndef LOCKER_H#define LOCKER_H#include &lt;exception&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;/*封装信号量的类*/class sem&#123;public: /*创建并初始化信号量*/ sem() &#123; if (sem_init(&amp;m_sem, 0, 0) != 0) &#123; /*构造函数没有返回值，可以通过抛出异常来报告错误*/ throw std::exception(); &#125; &#125; /*销毁信号量*/ ~sem() &#123; sem_destroy(&amp;m_sem); &#125; /*等待信号量*/ bool wait() &#123; return sem_wait(&amp;m_sem) == 0; &#125; /*增加信号量*/ bool post() &#123; return sem_post(&amp;m_sem) == 0; &#125;private: sem_t m_sem;&#125;;/*封装互斥锁的类*/class locker&#123;public: /*创建并初始化互斥锁*/ locker() &#123; if (pthread_mutex_init(&amp;m_mutex, NULL) != 0) &#123; throw std::exception(); &#125; &#125; /*销毁互斥锁*/ ~locker() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125; /*获取互斥锁*/ bool lock() &#123; return pthread_mutex_lock(&amp;m_mutex) == 0; &#125; /*释放互斥锁*/ bool unlock() &#123; return pthread_mutex_unlock(&amp;m_mutex) == 0; &#125;private: pthread_mutex_t m_mutex;&#125;;/*封装条件变量的类*/class cond&#123;public: /*创建并初始化条件变量*/ cond() &#123; if (pthread_mutex_init(&amp;m_mutex, NULL) != 0) &#123; throw std::exception(); &#125; if (pthread_cond_init(&amp;m_cond, NULL) != 0) &#123; /*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/ pthread_mutex_destroy(&amp;m_mutex); throw std::exception(); &#125; &#125; /*销毁条件变量*/ ~cond() &#123; pthread_mutex_destroy(&amp;m_mutex); pthread_cond_destroy(&amp;m_cond); &#125; /*等待条件变量*/ bool wait() &#123; int ret = 0; pthread_mutex_lock(&amp;m_mutex); ret = pthread_cond_wait(&amp;m_cond, &amp;m_mutex); pthread_mutex_unlock(&amp;m_mutex); return ret == 0; &#125; /*唤醒等待条件变量的线程*/ bool signal() &#123; return pthread_cond_signal(&amp;m_cond) == 0; &#125;private: pthread_mutex_t m_mutex; pthread_cond_t m_cond;&#125;;#endif 多线程环境可重入函数如果一个函数能被多个线程同时调用且不发生竞态条件，则我们称它是线程安全的（thread safe），或者说它是可重入函数。Linux库函数只有一小部分是不可重入的，比如inet_ntoa函数，以及getservbyname和getservbyport函数。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。不过Linux对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上_r。比如，函数localtime对应的可重入函数是localtime_r。在多线程程序中调用库函数，一定要使用其可重入版本，否则可能导致预想不到的结果。 线程和进程思考这样一个问题：如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？答案是“否”，正如我们期望的那样。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。这就引起了一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;pthread_mutex_t mutex;/*子线程运行的函数。它首先获得互斥锁mutex，然后暂停5 s，再释放该互斥锁*/void *another(void *arg)&#123; printf(&quot;in child thread,lock the mutex\\n&quot;); pthread_mutex_lock(&amp;mutex); sleep(5); pthread_mutex_unlock(&amp;mutex);&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); pthread_t id; pthread_create(&amp;id, NULL, another, NULL); /*父进程中的主线程暂停1 s，以确保在执行fork操作之前，子线程已经开始运行并获 得了互斥变量mutex*/ sleep(1); int pid = fork(); if (pid &lt; 0) &#123; pthread_join(id, NULL); pthread_mutex_destroy(&amp;mutex); return 1; &#125; else if (pid == 0) &#123; printf(&quot;I am in the child,want to get the lock\\n&quot;); /*子进程从父进程继承了互斥锁mutex的状态，该互斥锁处于锁住的状态，这是由父进 程中的子线程执行pthread_mutex_lock引起的，因此，下面这句加锁操作会一直阻塞， 尽管从逻辑上来说它是不应该阻塞的*/ pthread_mutex_lock(&amp;mutex); printf(&quot;I can not run to here,oop...\\n&quot;); pthread_mutex_unlock(&amp;mutex); exit(0); &#125; else &#123; wait(NULL); &#125; pthread_join(id, NULL); pthread_mutex_destroy(&amp;mutex); return 0;&#125; pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚的锁状态。该函数的定义如下： 1int pthread_atfork(void(*prepare)(void),void(*parent)(void),void(*child)(void)); 该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。prepare句柄将在fork调用创建出子进程之前被执行。它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。该函数成功时返回0，失败则返回错误码 fork调用前加入代码 1234567void prepare()&#123; pthread_mutex_lock(＆mutex);&#125;void infork()&#123; pthread_mutex_unlock(＆mutex);&#125;pthread_atfork(prepare,infork,infork); 线程和信号每个线程都可以独立地设置信号掩码。我们讨论过设置进程信号掩码的函数sigprocmask，但在多线程环境下我们应该使用如下所示的pthread版本的sigprocmask函数来设置线程信号掩码： 123#include＜pthread.h＞#include＜signal.h＞int pthread_sigmask(int how,const sigset_t*newmask,sigset_t*oldmask); 该函数的参数的含义与sigprocmask的参数完全相同，因此不再赘述。pthread_sigmask成功时返回0，失败则返回错误码。 由于进程中的所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。因此，如果我们在每个子线程中都单独设置信号掩码，就很容易导致逻辑错误。此外，所有线程共享信号处理函数。也就是说，当我们在一个线程中设置了某个信号的信号处理函数后，它将覆盖其他线程为同一个信号设置的信号处理函数。这两点都说明，我们应该定义一个专门的线程来处理所有的信号。这可以通过如下两个步骤来实现 在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了 在某个线程中调用如下函数来等待信号并处理之 12#include＜signal.h＞int sigwait(const sigset_t*set,int*sig); set参数指定需要等待的信号的集合。我们可以简单地将其指定为在第1步中创建的信号掩码，表示在该线程中等待所有被屏蔽的信号。参数sig指向的整数用于存储该函数返回的信号值。sigwait成功时返回0，失败则返回错误码。一旦sigwait正确返回，我们就可以对接收到的信号做处理了。很显然，如果我们使用了sigwait，就不应该再为信号设置信号处理函数了。这是因为当程序接收到信号时，二者中只能有一个起作用。 代码取自pthread_sigmask函数的man手册。它展示了如何通过上述两个步骤实现在一个线程中统一处理所有信号。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#define handle_error_en(en, msg) \\ do \\ &#123; \\ errno = en; \\ perror(msg); \\ exit(EXIT_FAILURE); \\ &#125; while (0)static void *sig_thread(void *arg)&#123; sigset_t *set = (sigset_t *)arg; int s, sig; for (;;) &#123; /*第二个步骤，调用sigwait等待信号*/ s = sigwait(set, &amp;sig); if (s != 0) handle_error_en(s, &quot;sigwait&quot;); printf(&quot;Signal handling thread got signal%d\\n&quot;, sig); &#125;&#125;int main(int argc, char *argv[])&#123; pthread_t thread; sigset_t set; int s; /*第一个步骤，在主线程中设置信号掩码*/ sigemptyset(&amp;set); sigaddset(&amp;set, SIGQUIT); sigaddset(&amp;set, SIGUSR1); s = pthread_sigmask(SIG_BLOCK, &amp;set, NULL); if (s != 0) handle_error_en(s, &quot;pthread_sigmask&quot;); s = pthread_create(&amp;thread, NULL, &amp;sig_thread, (void *)&amp;set); if (s != 0) handle_error_en(s, &quot;pthread_create&quot;); pause();&#125; 最后，pthread还提供了下面的方法，使得我们可以明确地将一个信号发送给指定的线程 #include＜signal.h＞ int pthread_kill(pthread_t thread,int sig); 其中，thread参数指定目标线程，sig参数指定待发送的信号。如果sig为0，则pthread_kill不发送信号，但它任然会执行错误检查。我们可以利用这种方式来检测目标线程是否存在。pthread_kill成功时返回0，失败则返回错误码 进程池和线程池在前面的章节中，我们是通过动态创建子进程（或子线程）来实现并发服务器的。这样做有如下缺点 动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。 动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量CPU时间 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能 进程池和线程池概述进程池和线程池相似，以进程池为例进行介绍。 数目 进程池是由服务器预先创建的一组子进程，这些子进程的数目在3～10个之间（典型情况）。 线程池中的线程数量应该和CPU数量差不多。 进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。 任务分配 主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流选取）算法，但更好的算法均匀分配任务到工作线程 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之 任务通知和数据传递 任务分配之后，主进程还需要告诉目标子进程有新任务需要处理，并传递必要的数据。 最简单的方法是，在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使用）。 在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局的，那么它们本身就是被所有线程共享的。 处理多客户 监听socket和连接socket是否都由主进程来统一管理 半同步&#x2F;半反应堆模式是由主进程统一管理这两种socket的 高效的半同步&#x2F;半异步模式，以及领导者&#x2F;追随者模式，则是由主进程管理所有监听socket，而各个子进程分别管理属于自己的连接socket的 对于前一种情况，主进程接受新的连接以得到连接socket，然后它需要将该socket传递给子进程（对于线程池而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易地共享该socket。但对于进程池而言，我们必须传递该socket）。 后一种情况的灵活性更大一些，因为子进程可以自己调用accept来接受新的连接，这样父进程就无须向子进程传递socket，而只需要简单地通知一声：“我检测到新的连接，你来接受它 一个客户连接上的所有任务是否始终由一个子进程来处理 如果说客户任务是无状态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服务 如果客户任务是存在上下文关系的，则最好一直用同一个子进程来为之服务，因为我们不得不在各子进程之间传递上下文数据。我们讨论了epoll的EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周期中仅被一个线程处理 半同步&#x2F;半异步进程池实现为了避免在父、子进程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很显然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423// filename:processpool.h#ifndef PROCESSPOOL_H#define PROCESSPOOL_H#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;/*描述一个子进程的类，m_pid是目标子进程的PID，m_pipefd是父进程和子进程通信用的管道*/class process&#123;public: process() : m_pid(-1) &#123;&#125;public: pid_t m_pid; int m_pipefd[2];&#125;;/*进程池类，将它定义为模板类是为了代码复用。其模板参数是处理逻辑任务的类*/template &lt;typename T&gt;class processpool&#123;private: /*将构造函数定义为私有的，因此我们只能通过后面的create静态函数来创建 processpool实例*/ processpool(int listenfd, int process_number = 8);public: /*单体模式，以保证程序最多创建一个processpool实例，这是程序正确处理信号的 必要条件*/ static processpool&lt;T&gt; *create(int listenfd, int process_number = 8) &#123; if (!m_instance) &#123; m_instance = new processpool&lt;T&gt;(listenfd, process_number); &#125; return m_instance; &#125; ～processpool() &#123; delete[] m_sub_process; &#125; /*启动进程池*/ void run();private: void setup_sig_pipe(); void run_parent(); void run_child();private: /*进程池允许的最大子进程数量*/ static const int MAX_PROCESS_NUMBER = 16; /*每个子进程最多能处理的客户数量*/ static const int USER_PER_PROCESS = 65536; /*epoll最多能处理的事件数*/ static const int MAX_EVENT_NUMBER = 10000; /*进程池中的进程总数*/ int m_process_number; /*子进程在池中的序号，从0开始*/ int m_idx; /*每个进程都有一个epoll内核事件表，用m_epollfd标识*/ int m_epollfd; /*监听socket*/ int m_listenfd; /*子进程通过m_stop来决定是否停止运行*/ int m_stop; /*保存所有子进程的描述信息*/ process *m_sub_process; /*进程池静态实例*/ static processpool&lt;T&gt; *m_instance;&#125;;template &lt;typename T&gt;processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = NULL;/*用于处理信号的管道，以实现统一事件源。后面称之为信号管道*/static int sig_pipefd[2];static int setnonblocking(int fd)&#123; int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option;&#125;static void addfd(int epollfd, int fd)&#123; epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event); setnonblocking(fd);&#125;/*从epollfd标识的epoll内核事件表中删除fd上的所有注册事件*/static void removefd(int epollfd, int fd)&#123; epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0); close(fd);&#125;static void sig_handler(int sig)&#123; int save_errno = errno; int msg = sig; send(sig_pipefd[1], (char *)&amp;msg, 1, 0); errno = save_errno;&#125;static void addsig(int sig, void(handler)(int), bool restart = true)&#123; struct sigaction sa; memset(&amp;sa, &#x27;\\0&#x27;, sizeof(sa)); sa.sa_handler = handler; if (restart) &#123; sa.sa_flags |= SA_RESTART; &#125; sigfillset(&amp;sa.sa_mask); assert(sigaction(sig, &amp;sa, NULL) != -1);&#125;/*进程池构造函数。参数listenfd是监听socket，它必须在创建进程池之前被创建，否则子进程无法直接引用它。参数process_number指定进程池中子进程的数量*/template &lt;typename T&gt;processpool&lt;T&gt;::processpool(int listenfd, int process_number) : m_listenfd(listenfd), m_process_number(process_number), m_idx(-1), m_stop(false)&#123; assert((process_number &gt; 0) &amp;&amp; (process_number &lt; = MAX_PROCESS_NUMBER)); m_sub_process = new process[process_number]; assert(m_sub_process); /*创建process_number个子进程，并建立它们和父进程之间的管道*/ for (int i = 0; i &lt; process_number; ++i) &#123; int ret = socketpair(PF_UNIX, SOCK_STREAM, 0, m_sub_process[i].m_pipefd); assert(ret == 0); m_sub_process[i].m_pid = fork(); assert(m_sub_process[i].m_pid &gt;= 0); if (m_sub_process[i].m_pid &gt; 0) &#123; close(m_sub_process[i].m_pipefd[1]); continue; &#125; else &#123; close(m_sub_process[i].m_pipefd[0]); m_idx = i; break; &#125; &#125;&#125;/*统一事件源*/template &lt;typename T&gt;void processpool&lt;T&gt;::setup_sig_pipe()&#123; /*创建epoll事件监听表和信号管道*/ m_epollfd = epoll_create(5); assert(m_epollfd != -1); int ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sig_pipefd); assert(ret != -1); setnonblocking(sig_pipefd[1]); addfd(m_epollfd, sig_pipefd[0]); /*设置信号处理函数*/ addsig(SIGCHLD, sig_handler); addsig(SIGTERM, sig_handler); addsig(SIGINT, sig_handler); addsig(SIGPIPE, SIG_IGN);&#125;/*父进程中m_idx值为-1，子进程中m_idx值大于等于0，我们据此判断接下来要运行的是父进程代码还是子进程代码*/template &lt;typename T&gt;void processpool&lt;T&gt;::run()&#123; if (m_idx != -1) &#123; run_child(); return; &#125; run_parent();&#125;template &lt;typename T&gt;void processpool&lt;T&gt;::run_child()&#123; setup_sig_pipe(); /*每个子进程都通过其在进程池中的序号值m_idx找到与父进程通信的管道*/ int pipefd = m_sub_process[m_idx].m_pipefd[1]; /*子进程需要监听管道文件描述符pipefd，因为父进程将通过它来通知子进程accept 新连接*/ addfd(m_epollfd, pipefd); epoll_event events[MAX_EVENT_NUMBER]; T *users = new T[USER_PER_PROCESS]; assert(users); int number = 0; int ret = -1; while (!m_stop) &#123; number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1); if ((number &lt; 0) &amp;&amp; (errno != EINTR)) &#123; printf(&quot;epoll failure\\n&quot;); break; &#125; for (int i = 0; i &lt; number; i++) &#123; int sockfd = events[i].data.fd; if ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; int client = 0; /*从父、子进程之间的管道读取数据，并将结果保存在变量client中。如果读取成 功，则表示有新客户连接到来*/ ret = recv(sockfd, (char *)&amp;client, sizeof(client), 0); if (((ret &lt; 0) &amp;&amp; (errno != EAGAIN)) || ret == 0) &#123; continue; &#125; else &#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); int connfd = accept(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (connfd &lt; 0) &#123; printf(&quot;errno is:%d\\n&quot;, errno); continue; &#125; addfd(m_epollfd, connfd); /*模板类T必须实现init方法，以初始化一个客户连接。我们直接使用connfd来索引 逻辑处理对象（T类型的对象），以提高程序效率*/ users[connfd].init(m_epollfd, connfd, client_address); &#125; &#125; /*下面处理子进程接收到的信号*/ else if ((sockfd == sig_pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; int sig; char signals[1024]; ret = recv(sig_pipefd[0], signals, sizeof(signals), 0); if (ret &lt;= 0) &#123; continue; &#125; else &#123; for (int i = 0; i &lt; ret; ++i) &#123; switch (signals[i]) &#123; case SIGCHLD: &#123; pid_t pid; int stat; while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) &#123; continue; &#125; break; &#125; case SIGTERM: case SIGINT: &#123; m_stop = true; break; &#125; default: &#123; break; &#125; &#125; &#125; &#125; &#125; /*如果是其他可读数据，那么必然是客户请求到来。调用逻辑处理对象的process方法 处理之*/ else if (events[i].events &amp; EPOLLIN) &#123; users[sockfd].process(); &#125; else &#123; continue; &#125; &#125; &#125; delete[] users; users = NULL; close(pipefd); // close(m_listenfd);这句话注释掉，以提醒读者：应该由m_listenfd的创建者来关闭这个文件描述符（见后文）, // 即所谓的对象（比如一个文件描述符，又或者一段堆内存）由哪个函数创建，就应该由哪个函数销毁”*/ close(m_epollfd);&#125;template &lt;typename T&gt;void processpool&lt;T&gt;::run_parent()&#123; setup_sig_pipe(); /*父进程监听m_listenfd*/ addfd(m_epollfd, m_listenfd); epoll_event events[MAX_EVENT_NUMBER]; int sub_process_counter = 0; int new_conn = 1; int number = 0; int ret = -1; while (!m_stop) &#123; number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1); if ((number &lt; 0) &amp;&amp; (errno != EINTR)) &#123; printf(&quot;epoll failure\\n&quot;); break; &#125; for (int i = 0; i &lt; number; i++) &#123; int sockfd = events[i].data.fd; if (sockfd == m_listenfd) &#123; /*如果有新连接到来，就采用Round Robin方式将其分配给一个子进程处理*/ int i = sub_process_counter; do &#123; if (m_sub_process[i].m_pid != -1) &#123; break; &#125; i = (i + 1) % m_process_number; &#125; while (i != sub_process_counter); if (m_sub_process[i].m_pid == -1) &#123; m_stop = true; break; &#125; sub_process_counter = (i + 1) % m_process_number; send(m_sub_process[i].m_pipefd[0], (char *)&amp;new_conn, sizeof(new_conn), 0); printf(&quot;send request to child%d\\n&quot;, i); &#125; /*下面处理父进程接收到的信号*/ else if ((sockfd == sig_pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; int sig; char signals[1024]; ret = recv(sig_pipefd[0], signals, sizeof(signals), 0); if (ret &lt;= 0) &#123; continue; &#125; else &#123; for (int i = 0; i &lt; ret; ++i) &#123; switch (signals[i]) &#123; case SIGCHLD: &#123; pid_t pid; int stat; while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) &#123; for (int i = 0; i &lt; m_process_number; ++i) &#123; /*如果进程池中第i个子进程退出了，则主进程关闭相应的通信管道，并设置相应的 m_pid为-1，以标记该子进程已经退出*/ if (m_sub_process[i].m_pid == pid) &#123; printf(&quot;child%d join\\n&quot;, i); close(m_sub_process[i].m_pipefd[0]); m_sub_process[i].m_pid = -1; &#125; &#125; &#125; /*如果所有子进程都已经退出了，则父进程也退出*/ m_stop = true; for (int i = 0; i &lt; m_process_number; ++i) &#123; if (m_sub_process[i].m_pid != -1) &#123; m_stop = false; &#125; &#125; break; &#125; case SIGTERM: case SIGINT: &#123; /*如果父进程接收到终止信号，那么就杀死所有子进程，并等待它们全部结束。当然， 通知子进程结束更好的方法是向父、子进程之间的通信管道发送特殊数据，读者不妨自己实 现之*/ printf(&quot;kill all the clild now\\n&quot;); for (int i = 0; i &lt; m_process_number; ++i) &#123; int pid = m_sub_process[i].m_pid; if (pid != -1) &#123; kill(pid, SIGTERM); &#125; &#125; break; &#125; default: &#123; break; &#125; &#125; &#125; &#125; &#125; else &#123; continue; &#125; &#125; &#125; // close(m_listenfd);/*由创建者关闭这个文件描述符（见后文）*/ close(m_epollfd);&#125;#endif 用进程池实现的简单CGI服务器半同步&#x2F;半反应堆线程池实现该线程池的通用性要高得多，因为它使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。不过，如果要将该线程池应用到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。 用线程池实现的简单Web服务器我们曾使用有限状态机实现过一个非常简单的解析HTTP请求的服务器。下面我们将利用前面介绍的线程池来重新实现一个并发的Web服务器","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"文心一言","slug":"source/后端/文心一言api","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/后端/文心一言api/","permalink":"http://example.com/2025/03/02/source/%E5%90%8E%E7%AB%AF/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80api/","excerpt":"","text":"登录百度智能云账号并实名 百度智能云-云智一体深入产业 (baidu.com) 访问千帆平台-立即使用百度智能云千帆大模型平台ModelBuilder (baidu.com) 或者百度智能云控制台 (baidu.com) 应用接入-创建应用-获取api key和Secret key 获取access_token 一个月有效 替换下方参数浏览器访问即可或者看代码示例请求 https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=[API Key]&amp;client_secret&#x3D;[Secret Key] api文档API列表 - 千帆大模型平台 | 百度智能云文档 (baidu.com) 代码示例中心百度智能云控制台 (baidu.com)","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"文心一言","slug":"文心一言","permalink":"http://example.com/tags/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/"}]},{"title":"计算机组成原理","slug":"source/基础四大件/计算机组成原理","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/基础四大件/计算机组成原理/","permalink":"http://example.com/2025/03/02/source/%E5%9F%BA%E7%A1%80%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","excerpt":"","text":"计算机系统概述##计算机发展历程 什么是计算机系统？ 硬件+软件(系统软件 应用软件) 硬件的发展 第一台计算机 ENIAC 1946 冯诺依曼顾问 逻辑元件 1.8w个电子管 机器语言编程-纸带 有孔为0 bug：小虫子 第二代 贝尔实验室发明晶体管 面向过程语言：FORTRAN 操作系统 第三代 中小规模集成电路 高级语言 分时操作系统 第四代 大规模，超大规模集成电路 摩尔定律：集成电路的晶体管隔18个月能增强一倍，性能增强一倍 ###计算机硬件的基本组成 早期冯诺依曼结构 第一代ENIAC需要手动接线输入指令，他提出存储程序：将指令以二进制代码的形式事先输入到计算机的主存储器 以运算器为中心导致效率降低 主存是内存 辅存是硬盘 各个硬件的工作原理 &#x3D;&#x3D;主存储器&#x3D;&#x3D;的基本组成：存储体 + MAR(存储地址寄存器) + MDR(存储数据寄存器) MAR给出所需数据的地址，拿到数据后放到MDR 存储字长是8的整数倍 电子元件是电容 MAR的位数反应存储单元的个数 MAR 4位表示一共2^4个存储单元 MDR位数&#x3D;存储字长 16位MDR 每个单元可放16bit 1个字&#x3D;16bit (这里的字不是字节(B)8bit) 100Mbps指的是下载速度100M bit&#x2F;s 下载器100&#x2F;8M B&#x2F;s &#x3D;&#x3D;运算器&#x3D;&#x3D; ACC + MQ + X + ALU 作用：算术，逻辑运算 ACC 寄存器&#x2F;累加器 存操作数或运算结果 MQ 乘除时存操作数或运算结果 X 通用寄存器 存操作数 ALU （核心）算术逻辑单元 实现算术和逻辑运算 了解一下 &#x3D;&#x3D;控制器&#x3D;&#x3D; CU 控制单元 分析指令，给出控制信号 IR 指令寄存器 存当前执行的指定 PC 程序计数器 存下一条指令的地址 自+1 顺序 PC-&gt;IR-&gt;CU PC取完指令后，指向下一条指令的地址2 多级层次结构 高级语言 汇编语言 机器语言 编译程序：高级语言全部译为汇编语言或机器语言 汇编程序：汇编到机器 解释程序：高级到机器 翻译一句执行一句 计算机的性能指标###存储器性能指标 主存储器总容量：MAR32位 MDR8位 2^32*8bit&#x3D;4GB MAR位数反应存储单元的个数 MDR位数反应每个存储单元的大小 CPU主频 CPU数字脉冲信号震荡的频率 xGHz 越高cpu处理越快 CPI 每条指令的执行需要多少个时钟周期 1000Hz 100条指令 平均CPI&#x3D;3 需要执行多久？ 100*3*1&#x2F;1000&#x3D;0.3s IPS 每秒多少条指令 主频&#x2F;CPI FLOPS 每秒多少次浮点运算 前面可以加K M G T 分别是10的 3 6 9 12次方 文件大小 2^10 K 2^20 M 2^30 G 2^40 T 系统整体性能指标数据通路带宽：数据总线一次能并行传递信息的位数 吞吐量：系统单位时间内处理请求的数量 响应时间：向计算机发送请求到获得响应需要等待的时间 基准程序：跑分软件 数据的表示和运算进位转换&#x3D;&#x3D;二进制转化为8进制&#x3D;&#x3D;：三位一组，（分别是4 2 1*对应位值）每组表示0-7 ， 前面不足的补0，小数点后的最后不足的补0 &#x3D;&#x3D;二进制转化为16进制&#x3D;&#x3D;：四位一组 &#x3D;&#x3D;十六进制，八进制转化为二进制&#x3D;&#x3D;：每个数字或字母转化为四位或三位二进制，去掉头尾的0 &#x3D;&#x3D;符号表示&#x3D;&#x3D; 十六进制：(1652)16 1652H 0x1652 二进制 B 十进制 D &#x3D;&#x3D;十进制转为其他进制&#x3D;&#x3D; 整数部分 小数部分 无限循环 BCD码&#x3D;&#x3D;8421码&#x3D;&#x3D;：每位十进制数用四位二进制表示 权重分别为8 4 2 1 加法：(手算)：5+8&#x3D;13 用8421表示13 0001 0011 ​ （电脑）：0101+1000&#x3D;1101不在映射表里面 则再加上数字六的BCD码0110 1101+0110&#x3D;1 0011 &#x3D;&#x3D;余3码&#x3D;&#x3D;：8421对应规则+3(0011) &#x3D;&#x3D;2421码&#x3D;&#x3D;：5-9首位是1 ##unsigned unsigned char 1B ASCLL是0-127 unsigned short 2B unsigned int 4B &#x3D;&#x3D;减法&#x3D;&#x3D;：减数全部取反，末位+1，减法变加法 &#x3D;&#x3D;位运算&#x3D;&#x3D;:适合对无符号类型快速计算 无符号-原码表示 内存中都是二进制但是解释的时候会根据定义的类型 &lt;&lt; 向左移动低位补0 左移一次*2 &gt;&gt; 右移,高位补0&#x2F;1 除2 &gt;&gt;&gt; 无符号右移,高位补1 ##带符号整数 short 2B int 4B 原码，补码，反码 同一个数的不同表现形式，含义相同 机器字长 64位或者32位 表示通用寄存器能存多少位 能进行多少位的带符号整数的运算 以8位通用寄存器为例子 8位是最小存储单元 &#x3D;&#x3D;原码&#x3D;&#x3D;：1位符号位 7位数值位 机器字长n+1位 带符号整数表示 -(2^n-1) &lt;&#x3D; x &lt;&#x3D; 2^n-1 +0 与 -0 含义相同 原码运算：符号位不能参与运算，需要设计复杂的电路才能处理 &#x3D;&#x3D;补码&#x3D;&#x3D;:正数的补码是本身,负数是其二进制取反+1 原码 -&gt; 反码 -&gt; 补码 正数 三种状态一样 负数 -符号位不变 数值位取反&gt; 反码 -末位+1&gt; 补码 快速转换：负数原码 -&gt; 补码 从右往左找到第一个1，左边所有的数值位取反 加法：全部按位相加 减法：减法看作加法，A-B&#x3D;A+(-B) 求-B的补码：全部位取反，末尾+1 快速：从右往左找到第一个1，左边所有位取反 因此同一套电路可以实现无符号和有符号的运算 最终一个字节范围[-128,127) 11111111 -1 (规定) 11111110 表示-2 -1 + -2 11111101 &#x3D; -3 10000001 表示-127 10000000 -128 00000000 0 00000001 1 01111111 127 &#x3D;&#x3D;特性比较&#x3D;&#x3D;：n位能表示的最大值为2^n - 1 n+1位 原码 [-(2^n - 1) , 2^n - 1] 反码 [-(2^n - 1) , 2^n - 1] 补码 [-2^n , 2^n - 1] 无符号整数 [0 , 2^n+1 - 1] 是否发生溢出：-64+(-64) 用原码则溢出，补码则没有溢出 所以隐式转化就是非负数前面+0，负数前面+1,强制转换就是把前面多余的字节直接切掉,极大可能导致数据改变 &#x3D;&#x3D;移码&#x3D;&#x3D;：补码基础上，符号位取反 只能表示整数 以8位为例，从-128到127 从00000000到11111111 通常用于浮点数的阶码当中 定点小数 定点：小数点位置固定 定点整数：有符号整数 原码，反码，补码，移码 定点小数： 原码，反码，补码 整数.小数 小数点默认在整数的最后，在小数的符号位后面 符号位.位权 0&#x2F;1.2^-1 2^-2 … 2^-7 -0.5 0.25 0.125 转换规则与整数一摸一样 加法减法，与整数的规则也一样 原码 [-(1 - 2^n) , 1 - 2^n] 反码 [-(1 - 2^n) , 1 - 2^n] 补码 [-1 , 1- 2^n] ##电路 ALU 算术逻辑单元 输入信号 输出信号 控制信号(cu) -&gt; 算术&#x2F;逻辑运算 ALU多少位 寄存器就多少位 也就是机器字长 基本逻辑运算：与 &amp;&amp; 或 || 非 ! 对应三个门电路 * + 优先级:与 &gt; 或 分配律 结合律 实现电路简化 异或 :相同为0 &#x3D;&#x3D;1位全加器 FA&#x3D;&#x3D;: 串行加法器:进位信息保存起来,计算两个n位相加,串行执行n次,每次输出一个结果 并行加法器: &#x3D;&#x3D;并行进位加法器 CLA&#x3D;&#x3D;:每个进位并行同时产生 &#x3D;&#x3D;补码加减运算器&#x3D;&#x3D;:减数全部按位取反+1 变加法 用Sub控制加法或者减法,加法为0,不做任何处理,进位为0 减法则进位为0 减数取反,进位为1 无符号也可以使用 &#x3D;&#x3D;原码的加减&#x3D;&#x3D;: &#x3D;&#x3D;补码的加减运算&#x3D;&#x3D;:不用考虑符号位,直接参与运算 只有正数+正数 负数+负数 才会溢出 正数+正数 得到的结果看起来是负数 负数+负数 得到的结果看起来是正数 &#x3D;&#x3D;溢出判断&#x3D;&#x3D;: 方法一:v的值为1 则有溢出 ABS分别表示AB的符号和结果的符号位 方法二:符号位往更高位进位为Cs 符号位C1 他们异或为1 则溢出 方法三:双符号位:00 11 都参与运算 与法二一样 双符号位 :模4补码 实际也是存一个符号位,另一个是运算时复制的 单符号位:模2补码 ###标志位 OF 有符号运算的加减运算是否溢出 1表示溢出 最高位产生的进位与次高位产生的进位异或 SF 有符号加减运算结果的正负性 0表示正数 最高位的输出 ZF 表示运算结果是否为0 ZF1为表示结果为0 全0 CF 表示无符号数的加减法是否产生了进位或者借位 1发生 最高位的进位异或sub(sub&#x3D;0表示加法) 移位运算移位：改变数码位和小数点的相对位置，从而改变数码位的位权。 可以用算术移位来实现乘法和除法 算术移位小数点前后移动，数*10^n &#x3D;&#x3D;原码&#x3D;&#x3D;：符号位不变。数值位移位 右移：高位补0，低位舍弃，舍弃位为0，相当于÷2，舍弃为1，丢失精度 左移：低位补0，高位丢弃，舍弃位为0 *2 为1 严重误差 定点小数的原码同样 &#x3D;&#x3D;反码&#x3D;&#x3D;： 正数与原码一样 负数：补位补1 &#x3D;&#x3D;补码&#x3D;&#x3D;： 正数：与原码一致 负数：补位规则，最右边的1及其右侧同原码(右移 高位补1)，左边的同补码(左移 低位补0) 逻辑移位逻辑右移：高位补0，低位舍弃 逻辑左移：低位补0，高位舍弃 看作无符号数的移位 应用例子：RGB，用24位来存储，先用24位大小的数组填充R，然后左移16位，然后依次得到三个数组，相加得到最后的表示 ###循环移位 左移的时候移除的高位放到最低位 带进位的循环左移：进位信息CF也参与循环 应用：适合高字节与低字节的调换 如大端和小端的调换 乘除原码的乘法计算X*Y 运算器中ACC MQ X ALU X存 |x|的原码，也就是符号位为0其余不变 MQ 存放|Y|的原码和乘积低位 ACC 存乘积高位 机器字长位n+1 原码的一位乘法 符号位单独处理：异或 数值位绝对值相乘 乘法之前，ACC清0，第一次计算：MQ的最低位如果为1 ACC加上X，为0则加0(由ALU完成)，进行第二次的时候，ACC和MQ并起来逻辑右移，同样是MQ的最低位，一共进行n次，最后修改符号位 补码的乘法运算 MQ中扩展一位，称为辅助位，初始化为0，参与右移，MQ增加一位，ACC，X都会增加一位，可以采用双符号位补码运算 会有一个辅助电路处理|-x|补码，再交给ALU 原码的除法规律：忽略小数点，每确定一个商进行一次减法，得到四位余数，余数末尾补0，再确定下一位商，直到5位商(机器字长5) &#x3D;&#x3D;恢复余数法&#x3D;&#x3D;： 符号位单独处理，异或 数值位取绝对值进行除法运算 分别写出 |X|原 |-X|原 |Y|补 |-Y|补 商MQ初始化为0 ACC存|X| X存|Y| 从MQ低位开始确定一位商，默认为1，错了再改为0 ACC+|-Y|补 -&gt; ACC 最高位为1，则为负数，所以商改为0，然后ACC+|Y|补 -&gt; ACC ACC和MQ逻辑左移 循环n次 修改符号位 余数&#x3D;得到的商MQ*2^-n &#x3D;&#x3D;加减交替法&#x3D;&#x3D;：先不确定商位，ACC+|-Y|补 -&gt; ACC再给出商的 然后ACC左移加上|Y|补为下一个ACC，再确定一个商 补码的除法符号位参与运算，采用双符号位，被除数与除数异号则+|Y|补，同号则+|-Y|补，根据余数和除数同号则商1，左移，循环，末位商横置为1，*2^-n 强制类型转换 c语言中的定点整数 short int lang 都是补码的形式存储 unsigned 无符号 short x&#x3D;-4321 2字节 16bit 1110 1111 0001 1111 强制转换： unsigned short y &#x3D; (unsigned short)x y &#x3D; 61215 都是2字节则bit位原封不同 int 强制转化为 short 时，截断高字节 小字节转化为大字节-符号扩展 真值不变 负数在符号位和数值位间添1，正数在符号位和数值位之间添0 数据的存储和排列大小端模式4字节int 01 23 45 67 H (16进制) 1908878743 D (10进制) 01 MSB 最高有效字节 67 LSB 最低有效字节 大端:内存低地址-&gt;高地址 MSB-&gt;LSB 符合阅读习惯 小端:便于机器处理 边界对齐按字节编址:每个字节对应一个地址 假设一个字32位,则半字16位,一个字节8bit 寻址方式:可以按照字,半字,字节寻址,但是都要需要转化为字节地址 字和半字寻址需要逻辑左移转化为字节地址 字地址-&gt;字节地址 逻辑左移2位 *4 比如2号字,也就是第3行,10,左移2位,1000,8,8号字节,2号字则是从8号字节开始连续读4字节内容 半字-&gt;字节地址,逻辑左移1位 边界对齐:比如一个结构体,存储3个char,3个short,1个int,发现有两个需要填充的空白 边界对齐访问更快 ##浮点数 定点数表示的数据范围有限 浮点数:位数不变的情况下增加范围 用科学计数法表示 +3.026*10^11 &#x3D; +11 +3.062 N&#x3D;r^E×M E是阶码,M是尾数 底r通常为2.方便左移右移得到真值 E表示范围,M表示精度 浮点数尾数字的规格化,尾数的最高位必须是有效值,尽可能保留精度 左规:规格化,尾数左移,阶码-1 右规:尾数溢出(双符号位为01或10),尾数右移,阶码+1 IEEE 754阶码用移码的方式表示 移码:补码的基础上符号位取反,只能表示整数 移码&#x3D;真值+偏置值 当n&#x3D;8,偏置值&#x3D;128D&#x3D;1000 0000 即 2^n-1 eg:真值-127&#x3D;-111 1111B 移码&#x3D;-111 1111+1000 0000 &#x3D; 0000 0001 IEEE 754 中偏置置是127D &#x3D; 2^n-1 - 1 M23位是因为默认尾数为1.xxx float 4字节 1+8+23 真值:(-1)^s × 1.M × 2^(E-127) double 8字节 1+11+52 浮点数的运算 舍入:规格化尾数右移时如果舍弃了右侧的1要+1,如果+1后又溢出,又需要右规 或 如果舍弃了1需要把最后一位改为1 判溢出:阶码+1看符号位是否改变 32位机器long占32位,64位机器long占64位 64位机器,lang向double转化会有精度损失 int -&gt; float 会损失精度,但是范围不损失 float -&gt; int 可能损失精度,可能溢出 存储系统基本概念层次结构 16+512 16是主存，512是辅存，使用辅存数据要先掉入主存，CPU能直接访问的是内存和Cache 分类按存储介质分类 半导体器件，主存 Cache 磁表面存储器，磁盘，磁带 光存储器，光盘，DVD 存取方式 随机存取存储器 RAM，读写任何一个存储单元需要的时间都相同 内存条 顺序存取存储器 SAM 取决于存储单元所在维持 磁带 直接存取存储器 DAM 磁盘 兼具特性 相联存储器 CAM 按照内容检索到存储位置进行读写 “快表” 信息可更改性 读写存储器，磁盘，内存，Cache 只读存储器，ROM 实体专辑，BIOS 信息可保存性 易失性存储器：断电后存储信息消失，主存，Cache 非易失性：磁盘，光盘 破坏性读出：信息读出后原信息被破坏，DRAM芯片，读出后需要重写 非破坏性：SRAM芯片，磁盘，光盘 ###性能指标 存储容量：存储字长 × 字长 (1M × 8位) 单位成本：每位价格&#x3D;总成本&#x2F;总容量 存储速度：数据传输速率&#x3D;数据的宽度&#x2F;存储周期 存储周期&#x3D;存取时间+恢复时间 主存储器的基本组成###半导体元件的原理 ###存储芯片的原理 存储体由很多存储单元组成，存储单元由存储原组成，一个存储字是一条线连接的MOS管的字节数 MAR 译码器：n位的地址 -&gt; 2^n个存储单元,给出哪个地址就转化对应的存储单元为高电频信号 判断存储单元的金属引脚的数目 偏选线是选择对哪一块存储单元运算,一个内存条上多个存储单元 ###如何实现不同的寻址方式 一个小格是一个字节8bit，一整行是一个存储字，一行四字节，也就是字长为4B， 如果总容量为1KB，也就是256个字，也就是256行 现代计算机按字节编址，一个字节就是一个地址，1KB，也就是有1K个地址 按字节编址，但是也可按字节寻址，按字寻址，按半字寻址，按双字寻址 1KB 地址线10根，2^10&#x3D;1 K 所以10根地址线才能表示1K的地址 按字寻址：以行为单位，一共256个单位(行)，转化为字节地址，需要算术左移两位，末尾+2个0，因为一行四个字节，2^2 &#x3D; 4, SRAM和DRAM存储元件不同导致的特性差异DRAM用的栅极电容，如上，读取的时候是破坏性读出，读出后应该有重写操作。速度更慢，常做主存，集成度高。发热相对要小 SRAM用的双稳态触发器，非破坏性读出，不需要重写，运行速度快，用于Cache，集成度低，发热大 DRAM的刷新 ###DRAM的地址线复用技术 n位的地址用n&#x2F;2条地址线代替n条，分两次传行地址和列地址，地址线减半，芯片引脚减少 SRAM同时送行列地址，不用地址复用技术，因为集成度低点 DRAM采用地址线复用技术 刷新由存储器控制不由CPU控制 只读存储器ROMRAM-易失性，断电后数据消失 ROM-非易失 BIOS芯片ROM用于引导开机，将辅存ROM中的指令调入主存RAM，然后CPU就可以执行指令了 内存优化技术存取周期：可连续读写的最短时间&#x3D;存取时间+恢复时间 DRAM芯片的恢复时间比较长，有可能是存取时间的好几倍 双端口RAM忽略，不考 多模块存储器####多体并行存储器 高位交叉编址的多体存储器 体号+体内地址 低位交叉编址的多体存储器 体内地址+体号 先根据体号选择不同的存储体，然后根据体内地址再在存储体内寻址，低位效率高于高位 所以连续访问更快！存取周期T，存取时间r，为了使流水线不间断，应保证模块数m&gt;&#x3D;T&#x2F;r ,最好&#x3D;，小于会更待，大于会过剩空闲时间 ####单体多字存储器 主存储器和cpu的连接字扩展：扩展主存字数 位扩展：当数据总线(比如64位计算机)&gt;存储芯片字长(一个芯片只有8*8位) &#x3D;&#x3D;位扩展&#x3D;&#x3D; 这里的8K × 1位 表示8k个地址 即2^13次方，所以需要13根地址线，然后每个地址只有1位，数据线一根，这里连了两个芯片 当连续接了8个芯片之后，即8片8k*1位的存储芯片，得到一个8K*8位的存储器，容量8KB 线选法：根据不同的数据线，n条数据线连n个芯片 &#x3D;&#x3D;字扩展&#x3D;&#x3D; 连接多个8K*8位的存储芯片，然后然后根据A13-A15来控制选择不同的芯片 译码器片选法：n条线，2^n个片选信号，n&#x3D;3时，可以连8个存储芯片(38译码器)，这样就得到了8K*64位的存储器 下面右上方是74LS138译码器，三个使能端，三个输入端，8个初始端，头上带横线是低电平有效 外部存储器###磁盘存储器 RAID 多个独立的物理磁盘组成一个独立的逻辑盘 固态硬盘SSD CacheCache被集成到CPU内部，用SRAM实现 设tc为访问一次Cache需要的时间，tm为访问一次主存需要的时间 命中率H：CPU欲访问的信息已经在cache中的比率 缺失率：M&#x3D;1-H 系统的平均访问时间t&#x3D;Htc+(1-H)(tc+tm) 或t&#x3D;Htc+(1-H)tm 同时访问cache和内存，若cache命中则停止访问主存 将cpu目前访问地址的周围的数据放到cache中，如何定义周围？ 将主存的存储空间分块&#x2F;页，主存与Cache之间以块为单位进行数据交换，比如1kb一块，主存4M，分为4096块，每一块进行编号 Cache中的块也称为行 Cache与主存的映射 a：最慢，命中率高，空间利用充分 b：最快，命中率低，空间利用不充分 c：折中 替换算法Cache满了之后怎么办 a：满了才需要换 b：直接替换 c：分组满了才替换 RAND随机算法 FIFO先进先出算法 抖动现象：频繁替换，刚被替换的块很快又被调入 LRU近期最少使用 LFU最不经常使用算法 Cache写策略写命中 写回法：只修改Cache中的内容，当块被换出时才写回主存 全写法：同时写入Cache和主存，一般使用写缓冲(SRAM实现的FIFO队列)，可能写缓冲饱和发生阻塞 写不命中 写分配法：把主存中的块掉入Cache，再写，通常搭配写回法使用 非写分配法：只写入主存，不掉入Cache，搭配全写法 页式存储器进程分为页，页大小与主存物理块大小相同，每个页面离散的放入不同的主存块 逻辑地址：虚地址 程序员看到的地址 物理地址：实地址 主存中看到的地址 逻辑地址：逻辑页号+页内地址 -&gt; 物理地址：主存块号+块内地址 页表：逻辑页号 -&gt; 主存块号 快表：SRAM 慢表：DRAM 虚拟存储器虚拟存储系统，每次使用一个程序不会调入全部的数据而是调入部分 页式虚拟存储系统： 了解： 指令系统##指令格式 指令：操作码OP+地址码A (做什么+对谁做) 根据指令的地址码数量分 零地址指令 不需要操作数或者堆栈计算机(操作数隐含在栈顶和次栈顶-后缀表达式) 一地址指令 只需要单操作数 +1 -1 取反 取补 等 或 其中一个操作数被隐含在寄存器中 二地址指令 a+b 三地址指令 结果存到第三个地址 四地址指令 将下一个指令的地址指向第四个地址 指令字长：可能会变 机器字长：不变，和cpu有关，一次整数运算能处理的二进制位数 存储字长：一个存储单元中二进制代码的位数 和主存有关 扩展操作码指令格式 定长指令字结构+可变操作码 指令寻址指令寻址：如何确定下一条指令的存放地址 程序计数器PC指令下一条指令的存放地址 顺序寻址 定长指令字结构+指令字长&#x3D;存储字长&#x3D;2B+主存按字编制 每次PC+1 定长指令字结构+指令字长&#x3D;存储字长&#x3D;2B+主存按字节编制 （每个指令占两个字节） 每次PC+2 变长指令字结构 + 主存字节编址 读入第一个字，根据操作码确定该指令占n字节，然后PC+n 跳跃寻址 由转移指令指出 定长指令字结构+指令字长&#x3D;存储字长&#x3D;2B+主存按字编制 每次执行指令PC+1，如果指令是转移指令JMP，PC跳到转移指令指定的位置 数据寻址确定本条指令的地址码指明的真实地址 基于指令字长&#x3D;机器字长&#x3D;存储字长 的 一地址指令 直接寻址 EA&#x3D;A 访存两次 取指令+执行指令 间接寻址 EA&#x3D;(A) A是有效地址所在存储单元的地址，要在主存中寻找 访存三次取指令+执行指令2 寄存器寻址 EA&#x3D;Ri 操作数在Ri所指的寄存器内 访存一次：取地址 速度快 寄存器间接寻址 EA&#x3D;(Ri) 2 隐含寻址 另一个操作数在ACC中 立即寻址 A就是操作数本身 #+立即数 1 偏移寻址 堆栈寻址 CPU功能和结构cpu的功能： 指令控制 操作控制 时间控制 数据加工 中断处理 &#x3D;&#x3D;CPU&#x3D;&#x3D;： 运算器 对数据加工 控制器 协调并控制计算机各部件执行程序的指令序列，包括：取指令，分析指令，执行指令 &#x3D;&#x3D;运算器的结构&#x3D;&#x3D; 运算器的核心：ALU 算术逻辑单元 通用寄存器R0 R1 R2 SP(堆栈寄存器) 其中保存的数据可能作为ALU的输入A或B，用MUX多路选择器与ALU的输入端连接，或者使用内部单总线的方式，所有寄存器的输入输出都连到一条公共的通路上 暂存寄存器：暂存从主存读过来的数据 程序状态字寄存器 移位器 计数器 &#x3D;&#x3D;控制器的结构&#x3D;&#x3D; 程序计数器PC 指出下一个指令的地址 指令寄存器 保存正在执行的那条指令 指令译码器 仅对操作码进行译码，向控制器提供特定信号 微操作信号发生器 时序系统 存储器地址寄存器MAR 存放要访问的主存单元的地址 存储器数据寄存器MDR 存放从主存读入的信息 指令执行过程 取址周期","categories":[{"name":"四大件","slug":"四大件","permalink":"http://example.com/categories/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"}],"tags":[]},{"title":"操作系统","slug":"source/基础四大件/操作系统","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-12T03:07:30.034Z","comments":true,"path":"2025/03/02/source/基础四大件/操作系统/","permalink":"http://example.com/2025/03/02/source/%E5%9F%BA%E7%A1%80%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统环境准备###安装编译工具 12345sudo yum groupinstall &quot;Development Tools&quot; (GCC make Debug)yum install kernel-devel (内核开发相关的头文件)yum install genisoimage 用于生成ISO光盘映像文件 123456789安装汇编语言编译器 nasmyum install wgetwget https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/nasm-2.15.05.tar.gztar -xf nasm-2.15.05.tar.gzcd nasm-2.15.05./configuremakesudo make installnasm -v ###安装虚拟机-Bochs 下载地址：https://sourceforge.net/projects/bochs/files/bochs/ 下载2.8 tar.gz 地址：https://sourceforge.net/projects/bochs/files/bochs/2.8/bochs-2.8.tar.gz/download 这里我选择直接使用curl下载 curl -L -o bochs-2.8.tar.gz https://sourceforge.net/projects/bochs/files/bochs/2.8/bochs-2.8.tar.gz/download tar xvf bochs-2.8.tar.gz cd bochs-2.8 ./configure \\ --prefix=/root/bochs \\ --enable-debugger \\ --enable-disasm \\ --enable-iodebug \\ --enable-x86-debugger \\ --with-x \\ --with-x11 –prefix是安装的目录的位置，这里我是 &#x2F;root&#x2F;bochs&#x2F; make install 我遇到了找不到X11的错误 sudo yum install libX11-devel make ###配置bochs 类似于配置bios，知道有哪些硬件，启动顺序是什么，这里需要一个配置文件，参考文件在安装目录下的share&#x2F;doc&#x2F;bochs&#x2F;bochsrc-sample.txt，启动顺序大概在531-543行 下方文件放到&#x2F;root&#x2F;bochs&#x2F;bochsrc.txt 123456789megs : 512romimage: file=/root/bochs/share/bochs/BIOS-bochs-latest //注意路径vgaromimage: file=/root/bochs/share/bochs/VGABIOS-lgpl-latest //注意路径boot: disklog: bochs.outmouse:enabled=0keyboard:keymap=/root/bochs/share/bochs/keymaps/x11-pc-us.map //注意路径ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14#gdbstub:enabled=1,port=1234,text_base=0,data_base=0,bss_base=0 cd /root/bochs sudo bin/bochs -f bochsrc.txt -q 运行bochs -f 指定配置文件 -q 跳过界面指引 报错：cannot connect to X server 原因：我使用的vscode远程连接没有访问Linux centos图形界面的权力,用MobaXterm是可以的有X server 报错：No bootable device 没有启动盘 设置启动盘BIOS会将PC的控制权转移到引导加载程序，使用现有的引导加载程序GNU GRand(GRUB)，GRUB可以将操作系统构建为普通的ELF可执行文件，然后由GRUB将其加载到正确的内存位置。 GRUB将寻找一个数(具体的)以确保它实际上是在跳转到操作系统。然后GRUB跳转到内存中的某个位置将控制权转移到OS。 操作系统的这一部分必须用汇编代码编写，因为C需要一个不可用的堆栈。将以下代码保存在一个名为loader.s的文件中 1234567891011121314151617global loader ; the entry symbol for ELFMAGIC_NUMBER equ 0x1BADB002 ; define the magic number constantFLAGS equ 0x0 ; multiboot flagsCHECKSUM equ -MAGIC_NUMBER ; calculate the checksum ; (magic number + checksum + flags should equal 0)section .text: ; start of the text (code) sectionalign 4 ; the code must be 4 byte aligned dd MAGIC_NUMBER ; write the magic number to the machine code, dd FLAGS ; the flags, dd CHECKSUM ; and the checksumloader: ; the loader label (defined as entry point in linker script) mov eax, 0xCAFEBABE ; place the number 0xCAFEBABE in the register eax.loop: jmp .loop ; loop forever 功能：将0xCAFEBABE写入eax寄存器 后续开发中，.loop循环会被替换为真正的内核初始化代码 mkdir /root/tutuio nasm -f elf32 loader.s 将loader.s文件编译为32位ELF目标文件 ###链接内核 现在必须链接代码以生成可执行文件。我们希望GRUB在大于或等于0x00100000（1兆字节（MB））的内存地址上加载内核，因为GRUB本身，BIOS和内存映射的I &#x2F; O使用小于1 MB的地址。因此，需要以下链接程序脚本（为GNU LD编写） 1234567891011121314151617181920212223242526ENTRY(loader) /* the name of the entry label */SECTIONS &#123; . = 0x00100000; /* the code should be loaded at 1 MB */ .text ALIGN (0x1000) : /* align at 4 KB */ &#123; *(.text) /* all text sections from all files */ &#125; .rodata ALIGN (0x1000) : /* align at 4 KB */ &#123; *(.rodata*) /* all read-only data sections from all files */ &#125; .data ALIGN (0x1000) : /* align at 4 KB */ &#123; *(.data) /* all data sections from all files */ &#125; .bss ALIGN (0x1000) : /* align at 4 KB */ &#123; *(COMMON) /* all COMMON sections from all files */ *(.bss) /* all bss sections from all files */ &#125;&#125; 将链接程序脚本保存到名为link.ld的文件中 ld -T link.ld -melf_i386 loader.o -o kernel.elf ###创建可引导的so镜像 我们将使用的GRUB版本是GRUB Legacy，因为可以在同时使用GRUB Legacy和GRUB 2的系统上生成OS ISO映像。将使用GRUB Legacy stage2_eltorito引导程序。 教程中wget ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz 然后构建文件，我编译失败 从http://littleosbook.github.com/files/stage2_eltorito直接下载stage2_eltorito文件，这个地址也失效了 从syslinux构建isolinux.bin 即stage2_eltorito文件 12345678wget https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/syslinux-6.03.tar.gztar xzf syslinux-6.03.tar.gzcd syslinux-6.03make biosmkdir -p /root/iso/boot/grub cp /root/syslinux-6.03/bios/core/isolinux.bin /root/iso/boot/grub/cp /root/tutuio/kernel.elf /root/iso/boot/ 此时的目录结构： menu.lst内容如下 12345default=0timeout=0title oskernel /boot/kernel.elf 在iso同级目录下运行下方指令， isolinux.bin本来是stage2_eltorito被我替换了 可以使用man genisoimage查看参数含义 12345678910genisoimage -R \\ -b boot/grub/isolinux.bin \\ -no-emul-boot \\ -boot-load-size 4 \\ -A os \\ -input-charset utf8 \\ -quiet \\ -boot-info-table \\ -o os.iso \\ iso 此时iso同级目录下会生成 os.iso文件 以isolinux.bin构建的iso并不使用，会出现报错failed to load ldlinux.32c 所以用GRUB 2构建iso sudo yum install grub2 grub2-tools grub2-tools-extra mtools xorriso 新的目录结构 grub2-mkrescue -o os.iso /root/iso 启动bochssudo bin/bochs -f bochsrc.txt -q c 成功启动！ cat bochslog.txt | grep &#39;EAX=&#39;查看日志并没有EAX &#x3D; CAFEBABE的字样？ 过渡到c操作系统真相还原软件是如何访问硬件的？ 硬件发展迅速，操作系统不可能及时更新驱动，于是使用硬件适配器，也就是IO接口，生产出来的设备按照这个标准工作就实现了通用 访问外部硬件有两个方式。 （1）将某个外设的内存映射到一定范围的地址空间中，CPU 通过地址总线访问该内存区域时会落到外设的内存中 比如显卡，显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端 1MB 的 0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，往这片内存上写字节便是往屏幕上打印内容。计算机中处处是分层，我们要充分相信上一层的工作。 （2）外设是通过 IO 接口与 CPU 通信的，CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递给另一端的外设，也就是说，CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看，处处体现着分层。 于是问题来了，如何访问到 IO 接口呢，答案就是 IO 接口上面有一些寄存器，访问 IO 接口本质上就是访问这些寄存器，这些寄存器就是人们常说的端口。这些端口是人家 IO 接口给咱们提供的接口。人家接口电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。 部署工作环境CentOS 9 (CentOS-Stream-9-latest-x86_64-dvd1.iso) 我使用CentOS 7试过，无法连接到X server，需要安装图形界面，我就没有尝试了 nasm 汇编语言编译器 (只能使用汇编语言修改寄存器) bochs 虚拟机 virtualBox 虚拟机 我用的vmware 只有从源码安装的版本才会在其配置和编译过程中根据所在的平台的特性去优化，这些是其他形式的软件包不可比拟的。 ##安装bochs 下载地址：http://sourceforge.net/projects/bochs/files/bochs/ 1234curl -L -o bochs-2.8.tar.gz https://sourceforge.net/projects/bochs/files/bochs/2.8/bochs-2.8.tar.gz/downloadtar xvf bochs-2.8.tar.gz书籍中使用的2.6.2 我使用的时候已经make编译不过了，需要&lt;gtk/gtk.h&gt; 编译 三部曲configure make make install 1234567891011121314151617cd bochs-2.8./configure \\ --prefix=/root/tutuos/bochs-2.8-installed \\ --enable-debugger \\ --enable-disasm \\ --enable-iodebug \\ --enable-x86-debugger \\ --with-x \\ --with-x11注意各行结尾的&#x27;\\&#x27;字符前面有个空格//直接复制可使用版本：./configure --prefix=/root/tutuos/bochs-2.8-installed --enable-debugger --enable-disasm --enable-iodebug --enable-x86-debugger --with-x --with-x11我使用2.8出现报错：configure: WARNING: unrecognized options: --enable-disasm 我暂时没有理会，可以取消这个选项应该没有影响 –enable-gdb-stub替换–enable-debugger来使用gdb调试，但是不建议 12makemake install 配置bochs类似BIOS的作用 安装目录下有配置文件的样本文件：share&#x2F;doc&#x2F;bochs&#x2F;bochsrc-sample.txt 在安装目录下新建bochsrc.disk 文件名和位置都不固定，注意文件 12345678910111213141516171819202122232425262728############################################### # Configuration file for Bochs ############################################### # 第一步，首先设置 Bochs 在运行过程中能够使用的内存，本例为 32MB。# 关键字为：megs megs: 32 # 第二步，设置对应真实机器的 BIOS 和 VGA BIOS。# 对应两个关键字为：romimage 和 vgaromimage romimage: file=/root/tutuos/bochs-2.8-installed/share/bochs/BIOS-bochs-latest vgaromimage: file=/root/tutuos/bochs-2.8-installed/share/bochs/VGABIOS-lgpl-latest # 第三步，设置 Bochs 所使用的磁盘，软盘的关键字为 floppy。# 若只有一个软盘，则使用 floppya 即可，若有多个，则为 floppya，floppyb…#floppya: 1_44=a.img, status=inserted # 第四步，选择启动盘符。#boot: floppy #默认从软盘启动，将其注释boot: disk #改为从硬盘启动。我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作。# 第五步，设置日志文件的输出。log: bochs.out # 第六步，开启或关闭某些功能。# 下面是关闭鼠标，并打开键盘。mouse: enabled=0 keyboard:keymap=/root/tutuos/bochs-2.8-installed/share/bochs/keymaps/x11-pc-us.map# 硬盘设置ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63# 下面的是开放的 bochs 对 gdb 的支持，这样 gdb 便可以远程连接到此机器的 1234 端口调试了#gdbstub: enabled=1, port=4567, text_base=0, data_base=0, bss_base=0 注释掉，会出现段错误################### 配置文件结束 ##################### 运行bochs在 bochs 安装路径下 1234bin/bochs第一个默认选择是2，选择配置文件，这里2.8版本出现段错误，应该渲染选项界面出错，但是我也不知道如何解决sudo bin/bochs -f bochsrc.disk -q 指定配置文件并跳过指引 1234创建启动硬盘bin/bximage -hd -mode=flat -size=60 -q hd60M.imgbin/bximage -func=create -hd=60 -imgmode=flat -q hd60M.imgbin/bochs –f bochsrc.disk 编写 MBR 主引导记录为什么程序要载入内存？ 内存快且容量大 操作系统可以存储在多种存储介质中 什么是载入内存？ 程序被加载器（软件或硬件）加载到内存某个区域 CPU 的 cs：ip 寄存器被指向这个程序的起始地址 ##BIOS Base Input &amp; Output System，即基本输入输出系统 实模式下1mb内存布局Intel 8086 有 20 条地址线，故其可以访问 1MB 的内存空间，即 2 的 20 次方&#x3D;1048576&#x3D;1MB，地址范围若按十六进制来表示，是 0x00000 到 0xFFFFF 地址 0～0x9FFFF 处是 DRAM(动态随机访问内存)，我们所装的物理内存就是 DRAM 动态是什么意思？ 动态指此种存储介质由于本身电气元件的性质，需要定期地刷新(电容漏电，及时补点来保存数据，称为刷新) 看顶部的 0xF0000～0xFFFFF，这 64KB 的内存是 ROM。这里面存的就是 BIOS 的代码 BIOS的作用： 过“int 中断号”来实现相关的硬件调用，即对硬件的输入输出，但由于就 64KB 大小的空间，挑一些重要的、保证计算机能运行的那些硬件的基本 IO 操作 BIOS不用更该,被写进ROM，映射在低端1MB内存顶部，0xF0000入口地址 开机指令执行顺序： 开机的瞬间CPU 的 cs：ip 寄存器被强制初始化为 0xF000：0xFFF0 执行跳转指令 jmp far f000：e05b 跳转到0xfe05b 处(段基址 0xf000 左移 4 位+0xe05b)，这是 BIOS 代码真正开始的地方 cs：f000 加电，强制将 cs 置为 f000 接下来 BIOS 便马不停蹄地检测内存、显卡等外设信息，当检测通过，并初始化好硬件后，开始在内存中 0x000～0x3FF 处建立数据结构，中断向量表 IVT 并填写中断例程。 BIOS 最后一项工作校验启动盘中位于 0 盘 0 道 1 扇区的内容（最开始那个区域 CHS方法），也就是MBR所在位置 MBR如果此扇区末尾的两个字节分别是魔数 0x55 和 0xaa，BIOS 便认为此扇区中确实存在可执行的程序，加载到物理地址 0x7c00 MBR 的大小必须是 512 字节，这是为了保证 0x55 和 0xaa 这两个魔数恰好出现在该扇区的最后两个字节处，即第 510 字节处和第 511 字节处，由于我们的 bochs 模拟的是 x86 平台，所以是小端字节序，故其最后两个字节内容是 0xaa55 神奇好用的$和$$，令人迷惑的 section$和$$是编译器 NASM 预留的关键字，用来表示当前行和本 section 的地址，起到了标号的作用，它是 NASM 提供的，并不是 CPU 原生支持的，相当于伪指令一样，对 CPU 来说是假的。 1234code_start: mov ax, 0code_start被nasm认为是一个地址，此地址是：mov ax, 0这条指令所在的地址 $属于“隐式地”藏在本行代码前的标号，也就是编译器给当前行安排的地址，看不到却又无处不在，$在每行都有。 123code_start: jmp $ 等效于jmp code_start $$指代本 section 的起始地址 p70，暂且跳过 NASM简单用法nasm -f &lt;format&gt;&lt;filename&gt; [-o &lt;output&gt;] -f指定输出格式，默认bin，需要用elf格式才使用-f，一共21中格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253; 主引导程序SECTION MBR vstart=0x7c00 mov ax, cs mov ds, ax mov es, ax mov ss, ax mov fs, ax mov sp, 0x7c00 ; 清屏利用 0x06 号功能,上卷全部行,则可清屏。; INT 0x10 功能号:0x06 功能描述:上卷窗口; 输入: ; AH 功能号 = 0x06 ; AL = 上卷的行数(如果为 0,表示全部) ; BH = 上卷行属性; (CL,CH) = 窗口左上角的(X,Y)位置; (DL,DH) = 窗口右下角的(X,Y)位置; 无返回值: mov ax, 0x600 mov bx, 0x700 mov cx, 0 ; 左上角: (0, 0) mov dx, 0x184f ; 右下角: (80,25) ; VGA 文本模式中,一行只能容纳 80 个字符,共 25 行。; 下标从 0 开始,所以 0x18=24,0x4f=79 int 0x10 ; int 0x10 ;.get_cursor 获取当前光标位置,在光标位置处打印字符。mov ah, 3 ; 输入: 3 号子功能是获取光标位置,需要存入 ah 寄存器mov bh, 0 ; bh 寄存器存储的是待获取光标的页号int 0x10 ; 输出: ch=光标开始行,cl=光标结束行; dh=光标所在行号,dl=光标所在列号; 打印字符串 ; 还是用 10h 中断,不过这次调用 13 号子功能打印字符串mov ax, message mov bp, ax ; es:bp 为串首地址,es 此时同 cs 一致, ; 开头时已经为 sreg 初始化; 光标位置要用到 dx 寄存器中内容,cx 中的光标位置可忽略mov cx, 5 ; cx 为串长度,不包括结束符 0 的字符个数mov ax, 0x1301 ; 子功能号 13 显示字符及属性,要存入 ah 寄存器, ; al 设置写字符方式 ah=01: 显示字符串,光标跟随移动mov bx, 0x2 ; bh 存储要显示的页号,此处是第 0 页, ; bl 中是字符属性,属性黑底绿字(bl = 02h) int 0x10 ; 执行 BIOS 0x10 号中断jmp $ ; 使程序悬停在此message db &quot;1 MBR&quot; times 510-($-$$) db 0 db 0x55,0xaa 代码功能：在屏幕上打印字符串“1 MBR”，背景色为黑色，前景色为绿色 没有使用显卡，本段代码中关于“打印显示”的操作都利用 BIOS 建立好的例程就好了，这里第 0x10 号中断便是负责有关打印的例程。 第 3 行的“vstart&#x3D;0x7c00”表示本程序在编译时，告诉编译器，把我的起始地址编译为 0x7c00。 第 4～8 行是用 cs 寄存器的值去初始化其他寄存器。由于 BIOS 是通过 jmp 0：0x7c00 跳转到 MBR 的，故cs 此时为 0。对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现，只有通过其他寄存器来中转，这里我们用的是通用寄存器 ax 来中转。例如 mov ds：0x7c00，这样就错了。 第 9 行是初始化栈指针，在 CPU 上运行的程序得遵从 CPU 的规则，mbr 也是程序，是程序就要用到栈。目前 0x7c00 以下暂时是安全的区域，就把它当作栈来用。 第 11～28 行是清屏。因为在 BIOS 工作中，会有一些输出，如检测硬件的结果信息。为了让大家看清楚我们在 MBR 中的输出字符串，故先把 BIOS 的输出清掉，这里演示的是 BIOS 中断 int 0x10 的用法。 第30～35 行是做打印前的工作，先获取光标位置，目的是避免打印字符混乱，覆盖别人的输出。字符打印的位置，不一定要在光标处，字 符的位置只和显存中的地址有关，和光标是没关系的，这只是人为地加个约束，毕竟光标在视觉上告诉了我们当前字符写到哪里了，完全是为了好看，不要以为光标就是新打印字符的位置。更多细节，以后讲显卡时会提到。 &#x3D;&#x3D;页&#x3D;&#x3D; 第 33 行，往 bh 寄存器中写入了 0，这是告诉 BIOS 例程，我要获取第0 页当前的光标 显示器有很多种模式，如图形模式、文本模式等，在文本模式中，又可以工作于 80*25 和 40*25 等显示方式，默认情况下，所有个人计算机上的显卡在加电后都将自己置为 80*25 这种显示方式。80*25 是指一屏可以显示 25 行、每行 80 列的字符，也就是 2000 个字符。但由于一个字符要用两字节来表示，低字符是字符的 ASCII 编码，高字节是字符属性，故显示一屏字符需要用 4000 字节（实际上，分配给一屏的容量是 4KB），这一屏就称为一页，0 页是默认页。 第 38～52 行是往光标处打印字符。说一下第 48 行的 mov ax，0x1301，13 对应的是 ah 寄存器，这是调用0x13 号子功能。01 对应的是 al 寄存器，表示的是写字符方式，其低 2 位才有意义，各位功能描述如下。 （1）al&#x3D;0，显示字符串，并且光标返回起始位置。 （2）al&#x3D;1，显示字符串，并且光标跟随到新位置。 （3）al&#x3D;2，显示字符串及其属性，并且光标返回起始位置。 （4）al&#x3D;3，显示字符串及其属性，光标跟随到新位置。 第 55 行执行了个死循环，$是本行指令的地址，这属于伪指令，是汇编器在编译期间分配的地址。在最终编译出来的程序中，$会被替换为指令实际所在行的地址。jmp 是个近跳转，$是 jmp 自己的地址，于是跳到自己所在的地址再执行自己，又是跳到自己所在的地址再继续执行跳转，这样便实现了死循环。 第 57 行是定义打印的字符串。 第 58 行的$$是指本 section 的起始地址，上面说过了$是本行所在的地址，故$-$$是本行到本 section的偏移量。由于 MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节，故本扇区内前 512-2&#x3D;510 字节要填满，那到底要用多少字节才能填满此扇区呢。用 510 字节减去上面通过$-$$得到的偏移量，其结果便是本扇区内的剩余量，也就是要填充的字节数。由此可见第 50 行的“times 510-（$-$$） db 0”是在用 0 将本扇区剩余空间填充。 123456789编译nasm -o mbr.bin mbr.S验证是否为512字节ls -lb mbr.bin磁盘操作，将文件写入 0 盘 0 道 1 扇区dd if=/root/tutuos/mbr.bin of=/root/tutuos/bochs-2.8-installed/hd60M.img bs=512 count=1 conv=notrunc运行bin/bochs -f bochsrc.disk -q输入c后回车 第一个提示设置环境变量：export BXSHARE&#x3D;&#x2F;root&#x2F;tutuos&#x2F;bochs-2.8-installed&#x2F;share&#x2F;bochs 完善MBR地址 section vstart浅尝什么是地址地址：描述各种符号在源文件中的位置，各符号偏移文件开头的距离 编译器：给各符号编址，根据硬件平台特性，不考虑对齐则彼此相连 每个变量的地址是前一个变量的地址+前一个变量的内存空间大小。 代码编译之后，源代码中的标号(比如$)会被替换为实际地址 为了看程序编译后的各指令或标号的地址，可以用反汇编来查看，用 ndisasm 这个工具完成 指令 mov ds,ax，被编译器处理之后，其所在地址处的内容就是机器码 8ED8 var dw 0x99 数据定义 定义一个双字节字，编译后为99 00 x86小端序，低地址在99 看第 1 行的 mov 指令，$$表示的是所在的 section 的起始地址，由于这 6 行代码中没有定义 section，故 nasm 默认把全体文件当成一个大的 section，全体文件自然偏移地址为 0，所以在反汇编代码那列中，起始地址$$被置换为 0。 第 2 行代码是真指令，不牵涉到符号转换，所以反汇编后的代码同源码一致。 第 3 行引用了 var 变量的值，[]符号是取所在地址处的内容。在相应的反汇编代码中，相应的第三行中 var 这个符号地址被编译器替换为 0xd。结合地址列查看一下内容列，地址为 0xd 的内容为 99，这正是var 的值。 第 4 行源码为“label: mov ax,$”,label 是个标号，代表指令“mov ax，$”所在地址。$是个隐式的标号，表示当前行地址。按理说这两个标号值应该是一致的，验证一下：查看下反汇编代码列的第 4 行，$被替换为0x8，即本行 mov 指令地址是 0x8，在地址列第 4 行查看，地址确实为 8，吻合。 第 5 行的“jmp label”编译后被替换为 jmp short 0x8，这是短跳转指令，地址为 8 处的内容是第 4 行的“mov ax，$”，同样吻合。 &#x3D;&#x3D;地址等于上一个地址+上一个地址处的内容的长度。例如地址列第二行的 3 等于“上一个地址 0”+“上一个地址0 处的内容：B80000 的长度 3(一个长度32位)”，以此类推。&#x3D;&#x3D; 节 section编译器提供的伪指令，将程序逻辑上分为几个部分，比如将指令和数据分开便于维护等 vstart是 section 用 vstart&#x3D;来修饰后，可以被赋予一个虚拟起始地址，它被用来计算在该 section 内的所有内存引用地址。 在 section 中添加了 vstart，这个参数是让编译器将 section 中的数据的地址以 vstart 的值为起始，不再从整个程序开头算起。只有以程序开头 0 算起的地址才是真实存在的，在这个地址上能访问到相应的符号，所以不以程序开头算起的地址，必然在程序内部不存在，是虚拟的。 源码第 1 行的 section 含有 vstart&#x3D;0x7c00，故该节中的数据地址以 0x7c00 为起始编址。此 0x7c00 便是虚拟的地址，在程序中没有偏移文件开头为 0x7c00 的地址，整个程序不到 100 字节。 源码第 2 行的$$在编译后被替换为 vstart 的值 0x7c00 第 5 行的$在文件中的地址是 0x9，经编译后变成了 0x7c09，以vstart为起始计算的 第 6、7 行中引用的变量 var1 和 var2 属于 data 节，根据第二个vstart计算的 CPU的实模式(汇编讲解)实模式其实就是 8086 CPU 的工作环境、工作方式、工作状态，这是一整套的内容，实模式是指 8086 CPU 的寻址方式、寄存器大小、指令用法等，是用来反应 CPU 在该环境下如何工作的概念 实模式的“实”体现在：程序中用到的地址都是真实的物理地址，“段基址：段内偏移”产生的逻辑地址就是物理地址，也就是程序员看到的完全是真实的内存 直接对显示器说点什么CPU如何与外设通信-IO接口IO接口：CPU和外设之间的中间层，形式不限 IO接口的多功能和多工作模式，甚至多设备，通过软件指令实，称为“IO接口控制编程”，通过端口读写指令in&#x2F;out实现 IO接口的功能： 设置数据缓冲，解决速度不匹配问题 设置信号电平转换电路，CPU是TTL电平，外设大多机电设备无法被TTL驱动 设置数据格式转换 设置时序控制电路同步CPU和外设 提供地址译码，多端口设备 同一时刻CPU 只能和一个 IO 接口通信,CPU将选择这个工作交给输入输出控制中心（I&#x2F;O control hub，ICH），也就是南桥芯片 南桥用于连接 pci、pci-express、AGP 等低速设备，北桥用于连接高速设备，如内存 IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 0～65535。要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作 内存来操作，因此 CPU 提供了专门的指令来干这事，in 和 out。 1234567891011in 指令用于从端口中读取数据，其一般形式是：（1）in al, dx；（2）in ax, dx; 其中 al 和 ax 用来存储从端口获取的数据，dx 是指端口号目的操作数是用 al，还是 ax，取决于 dx 端口指代的寄存器是 8 位宽度，还是 16 位宽度（1）out dx, al；（2）out dx,ax；（3）out 立即数, al；（4）out 立即数, ax; 显卡概述mbr运行在实模式下，实模式下才有中断向量表，将来运行在保护模式下就不能调用BIOS中断0x10打印字符串 显存，显卡，显示器显卡的工作：不断读取显存中的内容，发送到屏幕上 根据ASCLL编码往显示屏写入字符 指令中的地址由地址总线寻址，指向某个介质，而不是都通过内存条 显卡默认文本模式为80*25 一屏可以打印2000个字符，一行80个共25行 打出彩色字符：ASCLL码一位，颜色一位，颜色RGB+I(1高亮) 可用颜色： 改进MBR，直接操作显卡mbr.S 1234567891011121314151617181920212223242526272829303132SECTION MBR vstart=0x7c00 ;标记一个MBR段 起始地址为0x7c00 mov ax, cs mov ds, ax mov es, ax mov ss, ax mov fs, ax mov sp, 0x7c00 ;栈指针赋值，从7c00开始 mov ax, 0xb800 ;0xb800是文本模式下显存的段地址，后续通过gs访问显存 mov gs, axmov ax, 0x600 ;滚动窗口mov bx, 0x700 ;黑底白字mov cx, 0 ;左上角行列坐标 (0,0)mov dx, 0x184f ;右下角行列坐标 (80,25)int 10h ;调用 BIOS 的 INT 10H 中断来清屏mov byte [gs:0x00],&#x27;1&#x27; ;直接向显存写入数据，ASCLL码+属性mov byte [gs:0x01],0xA4mov byte [gs:0x02],&#x27; &#x27;mov byte [gs:0x03],0xA4mov byte [gs:0x04],&#x27;M&#x27;mov byte [gs:0x05],0xA4mov byte [gs:0x06],&#x27;B&#x27;mov byte [gs:0x07],0xA4mov byte [gs:0x08],&#x27;R&#x27;mov byte [gs:0x09],0xA4jmp $ ;无限循环times 510-($-$$) db 0 ;填充剩余空间db 0x55,0xaa ;结束标志 123nasm -o mbr.bin mbr.Sdd if=/root/tutuos/mbr.bin of=/root/tutuos/bochs-2.8-installed/hd60M.img bs=512 count=1 conv=notruncbin/bochs -f bochsrc.disk -q bochs调试方法bochs一般用法","categories":[{"name":"四大件","slug":"四大件","permalink":"http://example.com/categories/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"}],"tags":[]},{"title":"shell脚本","slug":"source/工具-环境/shell脚本","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/工具-环境/shell脚本/","permalink":"http://example.com/2025/03/02/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/shell%E8%84%9A%E6%9C%AC/","excerpt":"","text":"shell：命令行解释器-接收用户输入的命令-调用操作系统内核去执行-返回结果 运行环境：linux-bash windows-powershell 切换shell版本 vi hello.sh 约定以sh，可以是其他任何或者没有 12345#!/bin/bash#表示这个脚本使用的是Bash解释器，系统会自动调用，可以替换成想用的路径echo &quot;hello&quot;datewhoami 运行脚本 bash hello.sh .&#x2F;hello.sh 这种方式需要权限 chmod +x hello.sh 添加执行权限 使用参数 12345bash hello.sh param1 param2$0 $1read name#控制台读取name=$0#使用参数echo&quot;$name&quot; 123name=jokeer#会话变量export name=joker#环境变量，脚本中可以使用 但是推出会话就失效了~下 ls -a 查看隐藏文件 ~下 ls -a 查看隐藏文件 .profile .bashrc(推荐)都可以用来存储环境变量 将export name&#x3D;joker添加到最后就可以了 source .bashrc 或 . .bashrc 或 重新登录会话 使生效 .bashrc 还存有一些简化命令 生成随机数 shuf -i 1-10 -n 1 输出一个1-10的随机数 写进sh 12345678910111213num=&#x27;shuf -i 1-10 -n 1&#x27;或num=$(shuf -i 1-10 -n 1) #(推荐)read guessif [[$guess -eq $num]]; then #-lt小于 -gt大于 echo &quot;yes&quot;else echo &quot;no&quot;fiwhile [[$guess -ne $num]]#循环 上面的判断放进去就行了 true不需要[[]]do done $RANDOM生成0-32767的随机数 $((RANDOM % 10 + 1))","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"}]},{"title":"OpenCV","slug":"source/库/OpenCV","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.388Z","comments":true,"path":"2025/03/02/source/库/OpenCV/","permalink":"http://example.com/2025/03/02/source/%E5%BA%93/OpenCV/","excerpt":"","text":"下载 msvc编译的版本 官网：https://opencv.org/releases/ 下载windows版本 环境变量Path C:\\APP\\opencv\\build\\x64\\vc16\\bin MinGW编译版 https://github.com/huihut/OpenCV-MinGW-Build 下载 环境变量 C:\\APP\\OpenCV-MinGW-Build\\x64\\mingw\\bin Qt中使用OpenCV教程：https://blog.csdn.net/kdnnnd/article/details/132840038 查看qt中使用的编译器是什么，我用的是MinGW pro文件写入内容 1234INCLUDEPATH+= C:\\APP\\OpenCV-MinGW-Build\\include\\ C:\\APP\\OpenCV-MinGW-Build\\include\\opencv2LIBS+=C:\\APP\\OpenCV-MinGW-Build\\x64\\mingw\\bin\\libopencv_*.dll 测试 1234567891011#include &lt;QCoreApplication&gt;#include &quot;opencv2/opencv.hpp&quot;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); using namespace cv; Mat image=imread(&quot;C:/MY/Qt-project/yun1/Default.jpg&quot;); imshow(&quot;Output&quot;,image); return a.exec();&#125; MSVC编译器则为 1234567INCLUDEPATH +=C:\\OpenCV_s\\opencv_vc\\opencv\\build\\include\\ C:\\OpenCV_s\\opencv_vc\\opencv\\build\\include\\opencv\\ C:\\OpenCV_s\\opencv_vc\\opencv\\build\\include\\opencv2LIBS +=C:\\OpenCV_s\\opencv_vc\\opencv\\build\\x64\\vc15\\lib\\opencv_world3414.lib 或 C:\\OpenCV_s\\opencv_vc\\opencv\\build\\x64\\vc15\\lib\\opencv_world3414d.lib注意: opencv_world3414d.lib 为debug版,opencv_world3414.lib为release版","categories":[{"name":"库","slug":"库","permalink":"http://example.com/categories/%E5%BA%93/"}],"tags":[]},{"title":"技术运营","slug":"source/面试/技术运营","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/面试/技术运营/","permalink":"http://example.com/2025/03/02/source/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E8%BF%90%E8%90%A5/","excerpt":"","text":"对技术运营的看法？ 保障技术系统的稳定运行，推动业务的发展和创新，负责服务器维护、网络管理、数据库优化等基础工作，确保整个技术架构的稳定可靠，优化业务流程等。 系统运维与监控 技术支持与优化 数据管理与分析 技术能力：包括操作系统、网络技术、数据库管理、编程语言等方面的知识。例如，要熟练掌握 Linux 系统的操作和管理，能够使用 Python 等编程语言进行自动化脚本编写 沟通能力解决问题的能力，保证业务连续，提升业务效率 你都用过哪些Linux开源程序 vim docker nginx mysql PostgreSQL apache 了解过nginx吗？ Nginx 是一款轻量级的高性能 Web 服务器、反向代理服务器以及电子邮件（IMAP&#x2F;POP3）代理服务器 http 服务器：处理静态资源 反向代理：将请求转发到真实的服务器 负载均衡：轮询、加权轮询、IP哈希，最少连接，随机 SSL&#x2F;TLS 加密 使用apache过程中遇到过什么问题，怎么分析的 ps -ef | grep httpd 发现apache进程过多或者根本无法启动 参数配置过大：MaxClients MaxRequestWorkers 内存泄漏：某些 Apache 模块或第三方插件可能存在内存泄漏问题，导致进程不断占用内存，使用系统监控工具，如 top、htop 或 vmstat 等，观察 Apache 进程的内存使用情况。如果发现某个进程的内存占用持续增长，可能存在内存泄漏 服务器的 CPU、内存、磁盘 I&#x2F;O 等资源不足，Apache 处理请求过于复杂，或者存在死循环使CPU使用过高，如果磁盘 I&#x2F;O 过高，可能是日志文件写入频繁或磁盘性能不佳 用户访问网站时，页面加载时间过长，响应缓慢 服务器的硬件资源不足，如 CPU 性能低下、内存不足、磁盘 I&#x2F;O 缓慢等，使用系统监控工具，如 top、htop、iostat 等 网络带宽不足、网络延迟高、网络丢包等问题，ping traceroute ifconfig Apache 配置不合理：Apache 的一些配置参数，如 KeepAlive、Timeout 等，设置不合理，会影响服务器的性能和响应速度。 应用程序性能问题，如果网站使用了动态脚本语言，如 PHP、Python 等，应用程序本身的性能问题也会影响 Apache 的访问速度。PHP 的 Xdebug、Python 的 cProfile 等，对应用程序进行性能分析 缓存配置不当：如果网站没有合理配置缓存，每次请求都需要重新生成页面内容，会增加服务器的负载，导致访问速度变慢。检查缓存配置，是否启用了 mod_cache模块，是否设置了合理的缓存规则 tcp连接数 netstat -ant | grep ESTABLISHED | wc -l ss -ant | grep ESTABLISHED | wc -l Windows： netstat -an | findstr &#x2F;i “ESTABLISHED” | find &#x2F;c &#x2F;v “” 一个小时内的每个ip访问服务器的数目 nginx或apache的日志文件，使用grep进行筛选统计 用过awk吗？如果我要替换文中字符，行间用tab分割，用awk怎么解决？ awk 替换和提取，awk ‘{gsub(&#x2F;apple&#x2F;, “grape”); print}’ OFS&#x3D;’\\t’ data.txt 替换函数gsub 8.一行命令替换所有中文，不使用awk sed ‘s&#x2F;hello&#x2F;hi&#x2F;g’ example.txt sed流编辑器，将所有hello替换为hi 给一个PID，返回进程文件的位置 readlink &#x2F;proc&#x2F;&#x2F;exe 怎么获取Linux系统当前的所有状态（CPU，内存，硬盘剩余等） cpu：top&#x2F;htop m mpstat -P ALL 内存： free -h vmstat 1 硬盘：df -h du -sh &#x2F;path&#x2F;to&#x2F;directory&#x2F;* 文件或目录的使用量 lvm 逻辑卷管理器，磁盘分区管理，lvm可以动态调整逻辑卷大小 锁 数据库锁：行级锁 在事务查询结果集上加，这些数据无法被删除，修改，直到事务释放 表级锁：整个表加锁，数据备份，导入导出 页级锁： 共享锁：多个事务可以同时加，加了锁的无法修改 排他锁：其他事务无法在其基础上加锁，持有者可以修改 意向锁：为了在进行表级锁操作时，能够快速判断表中是否有行或页已经被加锁，从而避免全表扫描。 互斥锁：mutex 读写锁：可以同时持有读锁，但是有人持有写锁时其他人不能持有读锁 自旋锁：当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，该线程不会进入睡眠状态，而是会不断地循环检查锁是否被释放 linux信号 在linux下有很多信号，按可靠性分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号，linux进程也有三种方式来处理收到的信号： （1）忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP； （2）捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数； （3）执行缺省操作，Linux对每种信号都规定了默认操作。 常见的信号： ① SIGINT (2) 程序终止(interrupt)信号，在用户键入INTR字符(通常是Ctrl + C)时发出。 ② SIGQUIT (3) 和SIGINT类似，但由QUIT字符(通常是Ctrl + )来控制。进程在因收到 SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误信号。 ③ SIGKILL (9) 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。 ④ SIGTERM (15) 程序结束(terminate)信号。与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常（优雅地）退出。shell命令kill缺省产生这个信号。 ⑤ SIGSTOP (19) 停止(stopped)进程的执行。注意它和terminate以及interrupt的区别：该进程还未结束，只是暂停执行。本信号不能被阻塞、处理或忽略。 16.Http 短连接和长连接的区别，以及各自使用的场景，以及长连接的缺点有哪些？ 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。 迭代和递归的区别吗 递归：重复调用函数自身实现循环称为递归； 迭代：利用变量的原值推出新值称为迭代，或着说迭代是函数内某段代码实现循环； redis分布式锁 分布式锁来保证同一时间只有一个服务实例能够访问该资源，setnx设置键值对来上锁，可以使用 Redlock 算法来提高分布式锁的可靠性 redis多线程 Redis 的多线程主要是用于处理网络 I&#x2F;O ，键值对的读写操作仍然是单线程执行的，主线程接受多个连接放入队列，IO线程从队列取出请求进行网络IO(读取请求发送响应)，然后将请求返回给主线程，主线程处理之后再给IO线程，IO线程返回给客户端 操作系统的内存管理 任务： 内存分配：为每个进程分配所需的内存空间，确保进程能够正常运行。操作系统需要根据进程的需求和内存的使用情况，合理地分配内存块。 内存回收：当进程执行完毕或不再需要某些内存空间时，操作系统需要及时回收这些内存，以便重新分配给其他进程使用。 地址映射：将进程的逻辑地址转换为物理地址。进程在编写程序时使用的是逻辑地址，而内存中的实际存储位置是物理地址，操作系统需要完成这两者之间的映射。 内存保护：防止不同进程之间的内存相互干扰和破坏。每个进程只能访问自己被分配的内存空间，操作系统需要提供相应的机制来确保内存的安全性。 内存扩充：当物理内存不足时，操作系统需要通过虚拟内存等技术，为进程提供更大的内存空间，以满足进程的需求。 内存分配： 单一连续分配：将内存分为系统区和用户区，系统区供操作系统使用，用户区供一个用户进程使用。在任何时刻，内存中只有一个用户进程。 分区分配：固定分区分配：将内存划分为若干个固定大小的分区，每个分区可以容纳一个进程。操作系统维护一个分区表，记录每个分区的使用情况。 ​ 动态分区分配：当有新进程需要内存时，操作系统从空闲内存中划分出一个合适大小的分区分配给该进程 分页&#x2F;段存储管理：将进程的逻辑地址空间划分为若干个大小相等的页&#x2F;段，(将内存的物理地址空间划分为若干个与页大小相等的帧)。通过页&#x2F;段表管理 段页式存储（现在）：结合了分段存储管理和分页存储管理的优点。先将进程的逻辑地址空间划分为若干个段，再将每个段划分为若干个页。通过段表和页表来实现逻辑地址到物理地址的映射。 内存分配算法 虚拟存储：将进程的部分地址空间存储在磁盘上，而只将当前需要的部分加载到内存中 topk问题，维护小根堆的复杂度分析，除此之外还有别的方法吗 TopK 问题指的是从包含n个元素的数据集中找出最大的k个元素 小根堆方法：前k个元素构建小根堆，顶端最小，遍历k+1之后，比堆顶大就替换然后调整堆顶O(nlogk) 排序法：快速排序、归并排序O(nlogn) 桶排序：前提：数据范围小，统计每个元素出现的次数，然后从大到小遍历桶，找出最大的k个元素O(n+m,m是范围) B+树知道吗？覆盖索引怎么优化的 从根节点开始，根据查询键值与节点中键值的大小关系，选择合适的子节点继续查找，直到到达叶子节点找到目标数据记录。由于数据都存储在叶子节点，范围查询时可以通过叶子节点的指针顺序遍历，效率较高。 覆盖索引是指一个查询语句的执行只需要从索引中获取数据，而不需要回表查询（即不需要再到数据表中查找对应的数据行） 减少磁盘IO即回表 减少内存占用，索引通常比数据表小，命中率提升 避免排序，b+数索引有序 数据库隔离级别介绍？RR隔离级别如何解决脏读问题的 读未提交：一个事务读取另一个未提交事务的数据，会产生脏读、不可重复读和幻读问题，脏读指的是一个事务读取到了另一个未提交事务修改的数据 读已提交：解决了脏读问题，存在不可重复读(多次读取的结果不同)和幻读问题 可重复读：多次读取同一数据的结果是一致的，在某些数据库中可能仍然存在幻读问题 串行化：只能事务结束才能新事务 RR(可重复读)隔离级别解决脏读问题的原理：多版本并发控制MVCC+行锁(修改某一行数据时加锁) OSPF OSPF 即开放式最短路径优先（Open Shortest Path First），是用于在单一自治系统（AS）内动态地建立、维护和更新路由信息的内部网关协议（IGP） OSPF 可以通过区域划分来管理网络，提高网络的可扩展性和性能。 操作系统进程间通信方式管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标# 识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 数据库索引 普通索引，频繁查询某个字段 唯一索引，索引列的值必须唯一，但允许有空值。如果是组合唯一索引，则列值的组合必须唯一 主键索引：主键索引是一种特殊的唯一索引，不允许有空值 全文索引：用于内容搜索 组合索引：多个列上创建的索引，数据库会根据这些列的顺序来使用索引。 k8s 应用服务和服务器的中间层，腾讯云中叫TKE，写一份配置文件而已将应用自动部署到服务器上，k8s将服务器分为控制平面+工作节点node，控制平面决定将应用部署到哪一个节点上，node负责部署实际应用服务Pod,Pod可以自动改变容量，如何让node节点也弹性伸缩：再加一层中间层实现节点伸缩：CA&#x2F;Kapernter，以pod形式部署然后通过控制平面获取集群资源状态，一个动态一个静态。还能节点整合，节点替换(当出现错误) 从ls或者cd命令举例，命令背后如何执行的。如何从用户态到内核态执行，命令的整体流程 解析shell fork创建进程 内核为新进程分配资源，包括内存空间、进程控制块（PCB）等，并复制父进程（Shell）的相关信息。 子进程通过系统调用execve()来加载ls命令对应的可执行程序 执行系统调用获取文件信息，切换到内核态。当执行系统调用时，CPU 会将当前进程的状态信息保存到内核栈中，然后根据系统调用号查找对应的内核函数，并跳转到内核函数的入口地址开始执行。 内核完成操作后，将结果返回给ls程序。ls程序接收到结果后，对其进行处理，如按照一定的格式将文件信息显示在终端上。 ls程序执行完毕后，通过系统调用exit()结束进程 内核态才能执行系统调用 bios ROM(只读)，现在使用闪存芯片","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"数据库","slug":"source/面试/数据库","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2025/03/02/source/面试/数据库/","permalink":"http://example.com/2025/03/02/source/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"B+树和B树的区别 B树：数据可以在内部节点，插入删除可能破坏结构造成更多操作，适合随机访问要求高，如操作系统的文件系统索引 B+树：数据只在叶子节点，插入删除更简单，适合范围查询和顺序查询，如数据库索引，叶子节点形成双向链表方便查找 mysql隔离级别 T1事务可能读取到T2事务未提交的数据，但是最后T2回滚了，导致T1读取到了一个未存在的数据，从而导致脏读现象 T1在读取同一行数据的两次结果不一样，从而导致不可重复读的问题 T1在执行范围查询或范围修改的时候,T2插入了一条属于T1范围内的数据，并且提交了，这个时候T1查询的时候发现多了一条数据，造成了幻读现象 读未提交：直接读取数据版本链中的最新版本 读已提交：使用快照读，即按照MVCC读取符合ReadView要求的版本数据，生成多个ReadView，解决了脏读 可重复读：使用快照读，只会在首次查询时生成ReadView，解决了不可重复读 串行化：读取时加入共享表锁，更新时加入独占表锁，解决了幻读 Innodb默认是可重复读，因为他需要保证事务ACID特性中的隔离性，通过Next-key避免幻读 MVCC就是在事务启动的时候对数据库拍了个快照，保留了那个时候的状态，这个事务后续的读取都从快照中获取，哪怕加了新的数据，也不会影响 意向锁意向锁是一种用于数据库管理系统，它试图在锁定资源之前表明事务希望锁定该资源。当一个事务想要获得锁时，数据库会检查是否存在资源的意向锁。 回表回表是指二级索引，你通过当前索引不能查询到想要的数据，需要再查找一个主键主键索引才能找到。避免回表的方法：在索引中包含查询所需的所有字段，这样，在查询时，不需要再回原表。 索引覆盖不用回表 mysql锁全局锁：加锁后整个数据库实例都处于只读状态。 表锁：锁定整张表 行锁：并发度高，但是加锁资源开销比较大，Innodb支持 慢查询优化是否用了索引，该索引是否是最左索引是否返回了过多字段，查出了多余数据检查数据是否过多，是否应该进行分库分表检查数据库实例所在的机器性能修改配置文件：在my.ini文件中，慢查询的定义事件是超过2秒，我们可以修改慢查询的定义优化数据库结构：合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。少使用join语句：比如左连接必须先查左表全表扫描，然后一条条到外表去查询利用explain的key，看看到底使用了哪个索引，把用不到的索引删除掉如果是联合索引，考虑是否满足最左前缀原则，尽量少使用聚合函数like模糊查询的%不可以放在最前面，不要使用or、union（去重）、not in这些条件查询 聚簇索引和非聚簇索引都是B+树 聚簇索引：将数据存储与索引放在一块，找到了索引也就找到了数据 非聚簇索引：叶子节点不存储数据，存储的是数据行地址，需要回表，相当于字典查询中的按照偏旁查找 Redis和MySQL如何保证数据一致先删除缓存再更新数据库 延迟双删：先删redis，再更新mysql，延迟一段时间再删redis，这样就算在更新mysql时，有其他线程读了mysql，把老数据读到了redis中，也会被删掉，从而保证数据一致 一页多大一页16kb，操作系统一页4kb","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"计算机网络","slug":"source/面试/计算机网络","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T14:07:47.760Z","comments":true,"path":"2025/03/02/source/面试/计算机网络/","permalink":"http://example.com/2025/03/02/source/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"socket状态转变 特殊情况：同时调用close，同时先收到FIN包的状态：FIN_WAIT_1 -&gt; ClOSE -&gt; TIME_WAIT（另一个走1 2），如果同时收到FIN则都走这种状态 超时时间：2MSL 三次握手 你能听到吗？我携带了序列号(SYN),我的序列号(seq&#x3D;x)是x 你能听到吗？我确认能听到(ACK&#x3D;1),我携带了序列号(SYN)，我的序列号是(seq&#x3D;y)是y，下一个数据包给我发送序列号(ack&#x3D;x+1) 我确认能听到(ACK&#x3D;1)，我的序列号是(seq&#x3D;x+1)，下一个数据包给我发送序列号(ack&#x3D;y+1) 四次挥手 超时时间：2MSL，2MSL是报文存在的最长时间，确认最后客户端发送的ACK能到达服务器 TLS SSL TLS是SSL更安全的进化版本，也是现在主流。TLS是OSI模型中的会话层 OSI七层模型 物理层 bit 数据链路层 帧 交换机&#x2F;网桥&#x2F;MAC 网络层 数据包 路由器&#x2F;IP 传输层 段&#x2F;数据报 TCP&#x2F;UDP 会话层 报文 TLS&#x2F;SSL （负责建立、管理和终止不同主机之间的会话连接） 表示层 报文（数据的表示和转换） 应用层 报文 HTTP&#x2F;FTP&#x2F;SMTP&#x2F;snmp 网页&#x2F;文件传输&#x2F;邮件","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"IO复用","slug":"source/Linux/Linix高性能服务器编程/IO复用","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/IO复用/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/IO%E5%A4%8D%E7%94%A8/","excerpt":"","text":"IO复用为什么要封装？ 封装各个接口简化调用，并且方便使用wait然后循环遍历各个事件，根据不同的事件处理不同的逻辑 epoll存储形式 int epollFd_; 构造的时候epoll_create(512) 返回fd并指定最大可监听512个，较新的linux内核用epoll_create1 std::vector events_; wait的时候存储监听到的事件 监听事件： 123456789101112131415161718基础事件EPOLLIN: 可读事件EPOLLOUT: 可写事件EPOLLRDHUP: TCP连接对端关闭或者半关闭EPOLLERR: 错误事件EPOLLHUP: 挂起事件EPOLLPRI: 紧急数据到达事件修饰符EPOLLET: 边缘触发模式EPOLLONESHOT: 一次性触发，触发后需要重新添加EPOLLWAKEUP: 当事件触发时防止系统休眠EPOLLEXCLUSIVE: 对于同一个文件描述符，在多个 epoll 实例中只有一个会触发（从 Linux 4.5 开始支持）最常用的组合是：EPOLLIN | EPOLLET: 边缘触发的读事件EPOLLIN | EPOLLOUT | EPOLLET: 边缘触发的读写事件EPOLLIN | EPOLLRDHUP: 用于检测对端关闭 12345678910111213struct epoll_event&#123; uint32_t events; epoll_data_t data;&#125; __EPOLL_PACKED;typedef union epoll_data&#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t; epoller.h123456789101112131415161718192021222324252627#ifndef EPOLLER_H#define EPOLLER_H#include &lt;sys/epoll.h&gt; //epoll_ctl()#include &lt;unistd.h&gt; // 对 POSIX 操作系统 API 的访问#include &lt;assert.h&gt; #include &lt;vector&gt;#include &lt;errno.h&gt;class Epoller &#123;public: explicit Epoller(int maxEvent = 1024); ~Epoller(); bool AddFd(int fd, uint32_t events); bool ModFd(int fd, uint32_t events);//修改指定文件描述符的事件类型 bool DelFd(int fd); int Wait(int timeoutMs = -1);//等待事件发生并返回事件的个数 int GetEventFd(size_t i) const; uint32_t GetEvents(size_t i) const; private: int epollFd_; std::vector&lt;struct epoll_event&gt; events_; //或者epoll_event events[MAX_EVENT_NUMBER]; wait的时候就传events &#125;;#endif //EPOLLER_H epoller.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;epoller.h&quot;Epoller::Epoller(int maxEvent):epollFd_(epoll_create(512)), events_(maxEvent)&#123; assert(epollFd_ &gt;= 0 &amp;&amp; events_.size() &gt; 0); //epollFd_ epoll的实例 vector存放注册的监听事件&#125;Epoller::~Epoller() &#123; close(epollFd_);&#125;bool Epoller::AddFd(int fd, uint32_t events) &#123; if(fd &lt; 0) return false; epoll_event ev = &#123;0&#125;; ev.data.fd = fd; ev.events = events; return 0 == epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);&#125;bool Epoller::ModFd(int fd, uint32_t events) &#123; if(fd &lt; 0) return false; epoll_event ev = &#123;0&#125;; ev.data.fd = fd; ev.events = events; return 0 == epoll_ctl(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);&#125;bool Epoller::DelFd(int fd) &#123; if(fd &lt; 0) return false; return 0 == epoll_ctl(epollFd_, EPOLL_CTL_DEL, fd, 0);&#125;// 返回事件数量int Epoller::Wait(int timeoutMs) &#123; return epoll_wait(epollFd_, &amp;events_[0], static_cast&lt;int&gt;(events_.size()), timeoutMs);&#125;//使用events_将发生的epoll_event存入events_中// 获取事件的fdint Epoller::GetEventFd(size_t i) const &#123; assert(i &lt; events_.size() &amp;&amp; i &gt;= 0); return events_[i].data.fd;&#125;// 获取事件属性uint32_t Epoller::GetEvents(size_t i) const &#123; assert(i &lt; events_.size() &amp;&amp; i &gt;= 0); return events_[i].events;&#125; ###main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;epoller.h&quot;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void simulate_read_event(int pipe_fd) &#123; // 写入 &quot;hello&quot; 到管道 const char* message = &quot;hello&quot;; write(pipe_fd, message, strlen(message));&#125;int main() &#123; int pipe_fds[2]; if (pipe(pipe_fds) == -1) &#123; perror(&quot;pipe&quot;); return 1; &#125; Epoller epoller(10); if (!epoller.AddFd(pipe_fds[0], EPOLLIN)) &#123; std::cerr &lt;&lt; &quot;Failed to add fd to epoller&quot; &lt;&lt; std::endl; return 1; &#125; std::thread waiter([&amp;epoller]() &#123; // 移除 &amp;pipe_fds，因为不需要 while (true) &#123; int n = epoller.Wait(1000); if (n &gt; 0) &#123; for (int i = 0; i &lt; n; ++i) &#123; int fd = epoller.GetEventFd(i); uint32_t evt = epoller.GetEvents(i); // 打印触发的事件类型 std::cout &lt;&lt; &quot;触发的事件类型: &quot;; if (evt &amp; EPOLLIN) std::cout &lt;&lt; &quot;EPOLLIN &quot;; if (evt &amp; EPOLLOUT) std::cout &lt;&lt; &quot;EPOLLOUT &quot;; if (evt &amp; EPOLLERR) std::cout &lt;&lt; &quot;EPOLLERR &quot;; if (evt &amp; EPOLLHUP) std::cout &lt;&lt; &quot;EPOLLHUP &quot;; std::cout &lt;&lt; std::endl; // 读取并打印数据 char buffer[128] = &#123;0&#125;; int bytes_read = read(fd, buffer, sizeof(buffer) - 1); if (bytes_read &gt; 0) &#123; std::cout &lt;&lt; &quot;收到数据: &quot; &lt;&lt; buffer &lt;&lt; std::endl; &#125; return; &#125; &#125; &#125; &#125;); std::thread simulator([&amp;pipe_fds]() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(500)); simulate_read_event(pipe_fds[1]); &#125;); simulator.join(); waiter.join(); close(pipe_fds[0]); close(pipe_fds[1]); return 0;&#125; 这里是使用的管道来使用的epoll 当管道的写端往内核缓冲区64KB写入数据时，读端触发EPOLLIN信号，然后打印数据 边缘触发和水平触发水平触发：LT 默认 只要有数据(没有被处理完)就一直触发 边缘触发ET。满足条件的时候触发(只触发一次) 必须一次性读取完所有数据，需要使用循环读取保证取完，必须设置非阻塞模式，性能高，适合高并发 为什么ET需要设置非阻塞模式？ 如果不设置非阻塞模式，会在循环读取数据的时候不会设置errno &#x3D;&#x3D; EAGAIN || errno &#x3D;&#x3D; EWOULDBLOCK，read的时候会一直阻塞等待新数据 如何使用ET 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &quot;epoller.h&quot;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;fcntl.h&gt;void SetNonBlocking(int fd) &#123; int flags = fcntl(fd, F_GETFL); flags |= O_NONBLOCK; fcntl(fd, F_SETFL, flags);&#125;void simulate_read_event(int pipe_fd) &#123; const char* message = &quot;hello&quot;; write(pipe_fd, message, strlen(message));&#125;int main() &#123; int pipe_fds[2]; if (pipe(pipe_fds) == -1) &#123; perror(&quot;pipe&quot;); return 1; &#125; // 设置非阻塞模式 SetNonBlocking(pipe_fds[0]); Epoller epoller(10); // 使用ET模式 if (!epoller.AddFd(pipe_fds[0], EPOLLIN | EPOLLET)) &#123; std::cerr &lt;&lt; &quot;Failed to add fd to epoller&quot; &lt;&lt; std::endl; return 1; &#125; std::thread waiter([&amp;epoller]() &#123; while (true) &#123; int n = epoller.Wait(1000); if (n &gt; 0) &#123; for (int i = 0; i &lt; n; ++i) &#123; int fd = epoller.GetEventFd(i); uint32_t evt = epoller.GetEvents(i); std::cout &lt;&lt; &quot;触发的事件类型: &quot;; if (evt &amp; EPOLLIN) std::cout &lt;&lt; &quot;EPOLLIN &quot;; if (evt &amp; EPOLLOUT) std::cout &lt;&lt; &quot;EPOLLOUT &quot;; if (evt &amp; EPOLLERR) std::cout &lt;&lt; &quot;EPOLLERR &quot;; if (evt &amp; EPOLLHUP) std::cout &lt;&lt; &quot;EPOLLHUP &quot;; std::cout &lt;&lt; std::endl; // ET模式下的读取循环 while (true) &#123; char buffer[128] = &#123;0&#125;; int bytes_read = read(fd, buffer, sizeof(buffer) - 1); if (bytes_read &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; // 数据读取完毕 break; &#125; // 处理其他错误 perror(&quot;read error&quot;); break; &#125; else if (bytes_read == 0) &#123; // 连接关闭 std::cout &lt;&lt; &quot;连接关闭&quot; &lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; &quot;收到数据: &quot; &lt;&lt; buffer &lt;&lt; std::endl; &#125; return; // 完成一次读取后退出 &#125; &#125; &#125; &#125;); std::thread simulator([&amp;pipe_fds]() &#123; std::this_thread::sleep_for(std::chrono::milliseconds(500)); simulate_read_event(pipe_fds[1]); &#125;); simulator.join(); waiter.join(); close(pipe_fds[0]); close(pipe_fds[1]); return 0;&#125; tcp监听套接字注册 EPOLLIN | EPOLLET 连接套接字注册 EPOLLIN | EPOLLET 根据需要可以加上EPOLLOUT 关闭和错误&#x3D;&#x3D;EPOLLIN&#x3D;&#x3D;： 对端关闭时会触发 read() 返回 0 表示对端关闭 &#x3D;&#x3D;EPOLLRDHUP&#x3D;&#x3D;： 对端关闭连接时触发 需要在注册时指定此事件 &#x3D;&#x3D;EPOLLHUP&#x3D;&#x3D;： 表示管道写端被关闭 不需要特别注册，会自动触发 &#x3D;&#x3D;EPOLLERR&#x3D;&#x3D;： 发生错误时触发 不需要特别注册，会自动触发 select、poll 和 epoll 区别12345678910 select poll epoll-----------------------------------------------------------------操作方式 遍历 遍历 回调底层实现 数组 链表 红黑树最大连接数 1024 无限制 无限制fd拷贝 每次都需要 每次都需要 只需一次返回就绪fd 遍历全部fd 遍历全部fd 只有就绪fd遍历复杂度 O(n) O(n) O(1)设置ET 否 否 是平台 多平台 多平台 Linux fd 拷贝指的是文件描述符从用户空间拷贝到内核空间的过程 select需要每次都需要重新注册事件 性能对比：epoll&gt;poll&gt;select &#x3D;&#x3D;epoll的优势&#x3D;&#x3D;： 内核态操作，不适合短期活跃连接 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。 底层红黑树，并且维护一个ready lisst 读取更快elect使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述； fd就绪时通过回调通知，更快 select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll触发epoll回调函数，放到ready list中等待epoll_wait调用后被处理。 epoll同时支持LT和ET模式 select和poll都只能工作在相对低效的LT模式下。 总结：当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Linux编程总结","slug":"source/Linux/Linix高性能服务器编程/Linux编程总结","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/Linux编程总结/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"服务器框架服务器模型C&#x2F;S模型 B&#x2F;S模型 浏览器服务器模型 P2P模型 每个节点都既是服务器又是客户端，可以直接与其他节点通信。 服务器编程框架 模块 单个服务器 服务器集群 I&#x2F;O处理单元 处理客户端连接，读写网络数据 作为接入服务器，实现负载均衡 逻辑单元 业务进程，线程 逻辑服务器 网络存储单元 本地数据库，文件，缓存 数据库服务器 请求队列 各单元之间通信方式 各服务器之间永久tcp连接 ####I&#x2F;O处理单元 #####I&#x2F;O模型 在I&#x2F;O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I&#x2F;O事件（是就绪事件还是完成事件），以及该由谁来完成I&#x2F;O读写（是应用程序还是内核）。 I&#x2F;O复用技术,来实现对监听socket（listenfd）和连接socket（客户请求）的同时监听。注意I&#x2F;O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。 &#x3D;&#x3D;同步IO和异步IO的区别&#x3D;&#x3D;： 同步IO：CPU一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。 异步IO：只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程： 1234loop = get_event_loop()while True: event = loop.get_event() process_event(event) #####事件处理模式 ######Reactor模式 要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。 Reactor（事件分发器）：1. 管理EventHandler的注册与销毁 2. 分发事件 (根据Demultiplexer返回的注册的事件分发) Demultiplexer（多路复用器 ： 1. 底层监听机制（如select、poll、epoll） EventHandler（事件处理器）：1. 实际处理各类事件的组件 事件源：1. 可以是Socket、Timer、Pipe等 产生各类I&#x2F;O事件 Proactor模式将所有的I&#x2F;O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool-&gt;append(users + sockfd)。 Proactor Initiator: 发起异步操作的初始化器 异步操作处理器: 负责提交异步操作到操作系统 操作系统执行实际的IO操作 IO操作完成后通知完成端口 Completion Dispatcher接收完成通知 分发给对应的Completion Handler Handler处理完成事件并返回结果给应用程序 模拟Proactor模式为了可以在不支持异步I&#x2F;O的系统上模拟Proactor模式，这样就可以实现异步的接口了 使用同步I&#x2F;O方式模拟出Proactor模式的一种方法：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 CompletionHandler: 完成事件处理接口 ThreadPool: 执行同步I&#x2F;O的线程池 ProactorInitiator: 发起异步操作的接口 Reactor和Proactor的区别 I&#x2F;O操作处理方式 Reactor: 应用程序负责进行实际的I&#x2F;O操作 Proactor: 操作系统负责进行实际的I&#x2F;O操作 事件通知内容 Reactor: 通知的是I&#x2F;O就绪事件（可读&#x2F;可写） Proactor: 通知的是I&#x2F;O完成事件 编程复杂度 Reactor: 相对简单，符合同步编程思维 Proactor: 较复杂，需要操作系统支持异步I&#x2F;O 适用平台 Reactor: 在Linux下应用广泛（如epoll） Proactor: 在Windows下应用广泛（如IOCP） 性能特点 Reactor: 需要应用程序自己执行I&#x2F;O，会占用应用程序线程 Proactor: I&#x2F;O由操作系统执行，应用程序线程可以处理其他任务 实现示例 Reactor: Linux的epoll、select、poll Proactor: Windows的IOCP、Linux的AIO 资源消耗 Reactor: 较少的系统资源 Proactor: 需要更多的系统资源来支持异步操作 总的来说，Reactor是同步非阻塞I&#x2F;O模型，而Proactor是异步I&#x2F;O模型。 并发模式在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。 如果程序是IO密集，而不是计算密集则需要并发 多进程和多线程两种方式 ######半同步&#x2F;半异步模式 同步线程用于处理客户逻辑；异步线程用于处理I&#x2F;O事件 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象 同步服务层 负责接收客户端请求 以同步的方式工作 通常是多线程实现 排队层 作为同步层和异步层之间的缓冲 通常使用队列实现 解耦同步和异步操作 异步服务层 从队列中获取任务 管理异步IO操作 协调异步处理流程 异步IO线程池 执行实际的异步IO操作 提高系统并发处理能力 避免阻塞主线程 半同步&#x2F;半反应堆在服务器程序中，如果结合考虑两种事件处理模式和几种I&#x2F;O模型，则半同步&#x2F;半异步模式就存在多种变体。其中有一种变体称为半同步&#x2F;半反应堆 异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权 主线程插入请求队列中的任务是就绪的连接socket。这说明该图所示的半同步&#x2F;半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。实际上，半同步&#x2F;半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其（或者指向该任务对象的一个指针）插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。 缺点： 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间。 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU时间。 一种高效的半同步&#x2F;半异步模式 每个工作线程都能同时处理多个客户连接 主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I&#x2F;O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。 领导者&#x2F;追随者模式 Leader线程 负责等待和接收新的事件，当事件到达时开始处理，在处理之前提升一个新的Leader，处理完成后重新加入线程池 socket123456789101112131415161718192021222324252627282930313233#include&lt;netinet/in.h&gt;//转换大端小端#include &lt;stdio.h&gt; #include &lt;iostream&gt;#include &lt;bits/socket.h&gt;#include &lt;arpa/inet.h&gt;//ip地址转换#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;assert.h&gt;using namespace std;int main() &#123; //源ip port const char* ip=&quot;192.168.6.208&quot;; unsigned short int port=5005; //专用socket结构体 sockaddr_in addr; addr.sin_family=AF_INET;//绑定地址族 addr.sin_port = htons(port);//绑定端口 网络字节序 if(inet_aton(ip,&amp;addr.sin_addr)==1)&#123;//绑定ip 网络字节序 inet_aton？ cout&lt;&lt;addr.sin_addr.s_addr&lt;&lt;endl; &#125; //专用结构体转化为通用结构体 //const struct sockaddr*new_addr=(sockaddr*)&amp;addr; //创建socket int pre_name_socket; pre_name_socket=socket(PF_INET,SOCK_STREAM,0);//ipv4 tcp SOCK_NONBLOCK 输出3 //命名socket int ret=bind(pre_name_socket,(sockaddr*)&amp;addr,sizeof(addr)); assert(ret != -1); cout&lt;&lt;&quot;bind success&quot;&lt;&lt;endl; //监听 ret = listen(pre_name_socket, 5);//监听 return 0;&#125; ET 边缘触发 状态改变才会 epoll会通知一次 LT 水平触发 符合状态就会(持续)通知 项目演示项目地址：https://github.com/qinguoyi/TinyWebServer 机器：centos 9 12345678910111213141516171819202122232425yum install dockerdocker pull dockerpull.org/mysql:latestdocker tag dockerpull.org/mysql:latest mysql:latestdocker run -d --name mysql -e MYSQL_ROOT_PASSWORD=yourpassword -p 3306:3306 mysql:latestdocker start mysqldocker exec -it mysql bashmysql -h localhost -u root -p yourpassword// 建立yourdb库create database yourdb;// 创建user表USE yourdb;CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE=InnoDB;// 添加数据INSERT INTO user(username, passwd) VALUES(&#x27;name&#x27;, &#x27;passwd&#x27;); 修改main.cpp , 如果实在docker中运行的mysql webserver.cpp 文件中 “localhost” 修改为 “127.0.0.1” 安装mysql编译包 123456789101112sudo dnf install https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpmsudo dnf install mysql-devel --nogpgcheckrpm -qi mysql-devel //验证显示没有安装mysql-develecho &quot;/usr/lib64/mysql&quot; | sudo tee /etc/ld.so.conf.d/mysql.conf //添加路径sudo ldconfig 还是找不到-Lmysqlclient//修改makefile 手动添加路径MYSQL_LIBS = -L/usr/lib64/mysql -lmysqlclientserver:$(MYSQL_LIBS)//难道是没有安装mysql的原因？因为我是在docker中运行的mysql 关闭centos防火墙 systemctl stop firewalld systemctl disable firewalld systemctl status firewalld 运行 sh .&#x2F;build.sh","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Log","slug":"source/Linux/Linix高性能服务器编程/Log","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/Log/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Log/","excerpt":"","text":"syslog系统日志mian.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;syslog.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; // 封装日志函数 class Logger &#123; public: Logger(const std::string&amp; appName) &#123; openlog(appName.c_str(), LOG_PID | LOG_CONS, LOG_USER); &#125; ~Logger() &#123; closelog(); &#125; void log(int priority, const std::string&amp; message) &#123; syslog(priority, &quot;%s&quot;, message.c_str()); &#125; // 设置日志掩码以过滤日志级别 void setLogMask(int mask) &#123; setlogmask(mask); &#125; // 示例日志方法 void debug(const std::string&amp; msg) &#123; log(LOG_DEBUG, msg); &#125; void info(const std::string&amp; msg) &#123; log(LOG_INFO, msg); &#125; void warning(const std::string&amp; msg) &#123; log(LOG_WARNING, msg); &#125; void error(const std::string&amp; msg) &#123; log(LOG_ERR, msg); &#125; &#125;; int main() &#123; Logger logger(&quot;MyApp&quot;); // 设置日志掩码，过滤掉 LOG_DEBUG 级别的日志 logger.setLogMask(LOG_UPTO(LOG_INFO)); // 允许 LOG_EMERG 到 LOG_INFO，但排除 LOG_DEBUG // 尝试记录不同级别的日志 logger.debug(&quot;This is a debug message.&quot;); // 这将不会出现在日志中 logger.info(&quot;This is an info message.&quot;); // 这将出现在日志中 logger.warning(&quot;This is a warning message.&quot;); // 这将出现在日志中 logger.error(&quot;This is an error message.&quot;); // 这将出现在日志中 return 0; &#125; 优先级： 特性： RAII模式管理日志资源（构造函数打开，析构函数关闭） 支持日志级别过滤 12345678LOG_EMERG (0) // 系统不可用（最高优先级）LOG_ALERT (1) // 必须立即采取行动LOG_CRIT (2) // 严重错误LOG_ERR (3) // 错误LOG_WARNING (4) // 警告LOG_NOTICE (5) // 正常但重要的情况LOG_INFO (6) // 信息性消息LOG_DEBUG (7) // 调试信息（最低优先级） LOG_UPTO(pri): 记录优先级等于或高于 pri 的所有消息 日志会被写入系统日志 #Ubuntu&#x2F;Debian tail -f &#x2F;var&#x2F;log&#x2F;syslog | grep MyApp #RHEL&#x2F;CentOS tail -f &#x2F;var&#x2F;log&#x2F;messages | grep MyApp 日志格式 时间戳+主机名+程序名+进程ID+日志消息 日志系统参考https://blog.csdn.net/weixin_51322383/article/details/130464403 https://blog.csdn.net/weixin_51322383/article/details/130474753 队列实现异步日志的关键，生成的日志放到队列中，写线程从队列中取出日志写入，用生产者消费者模型实现 生产者消费者模型 配合mutex互斥锁 condition_variable（条件变量） 实现线程间的同步与通信 模板 blockqueue.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# ifndef BLOCKQUEUE_H# define BLOCKQUEUE_H#include &lt;deque&gt;#include &lt;condition_variable&gt;#include &lt;mutex&gt;#include &lt;sys/time.h&gt;using namespace std;template&lt;typename T&gt;class BlockQueue &#123;public: explicit BlockQueue(size_t maxsize = 1000); ~BlockQueue(); bool empty(); bool full(); void push_back(const T&amp; item); void push_front(const T&amp; item); bool pop(T&amp; item); // 弹出的任务放入item bool pop(T&amp; item, int timeout); // 等待时间 void clear(); T front(); T back(); size_t capacity(); size_t size(); void flush(); void Close();private: deque&lt;T&gt; deq_; // 底层数据结构 mutex mtx_; // 锁 bool isClose_; // 关闭标志 size_t capacity_; // 容量 condition_variable condConsumer_; // 消费者条件变量 condition_variable condProducer_; // 生产者条件变量&#125;;template&lt;typename T&gt;BlockQueue&lt;T&gt;::BlockQueue(size_t maxsize) : capacity_(maxsize) &#123; assert(maxsize &gt; 0); isClose_ = false;&#125;template&lt;typename T&gt;BlockQueue&lt;T&gt;::~BlockQueue() &#123; Close();&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::Close() &#123; // lock_guard&lt;mutex&gt; locker(mtx_); // 操控队列之前，都需要上锁 // deq_.clear(); // 清空队列 clear(); isClose_ = true; condConsumer_.notify_all(); condProducer_.notify_all();&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::clear() &#123; lock_guard&lt;mutex&gt; locker(mtx_); deq_.clear();&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::empty() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return deq_.empty();&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::full() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return deq_.size() &gt;= capacity_;&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::push_back(const T&amp; item) &#123; // 注意，条件变量需要搭配unique_lock unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.size() &gt;= capacity_) &#123; // 队列满了，需要等待 condProducer_.wait(locker); // 暂停生产，等待消费者唤醒生产条件变量 &#125; deq_.push_back(item); condConsumer_.notify_one(); // 唤醒消费者&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::push_front(const T&amp; item) &#123; unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.size() &gt;= capacity_) &#123; // 队列满了，需要等待 condProducer_.wait(locker); // 暂停生产，等待消费者唤醒生产条件变量 &#125; deq_.push_front(item); condConsumer_.notify_one(); // 唤醒消费者&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::pop(T&amp; item) &#123; unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.empty()) &#123; if(isClose_) &#123; return false; &#125; condConsumer_.wait(locker); &#125; item = deq_.front(); deq_.pop_front(); condProducer_.notify_one(); return true;&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::pop(T &amp;item, int timeout) &#123; unique_lock&lt;std::mutex&gt; locker(mtx_); while(deq_.empty())&#123; if(condConsumer_.wait_for(locker, std::chrono::seconds(timeout)) == std::cv_status::timeout)&#123; return false; &#125; if(isClose_)&#123; return false; &#125; &#125; item = deq_.front(); deq_.pop_front(); condProducer_.notify_one(); return true;&#125;template&lt;typename T&gt;T BlockQueue&lt;T&gt;::front() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.front();&#125;template&lt;typename T&gt;T BlockQueue&lt;T&gt;::back() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.back();&#125;template&lt;typename T&gt;size_t BlockQueue&lt;T&gt;::capacity() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return capacity_;&#125;template&lt;typename T&gt;size_t BlockQueue&lt;T&gt;::size() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.size();&#125;// 唤醒消费者template&lt;typename T&gt;void BlockQueue&lt;T&gt;::flush() &#123; condConsumer_.notify_one();&#125;# endif 缓冲区###buffer.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef BUFFER_H#define BUFFER_H#include &lt;cstring&gt; //perror#include &lt;iostream&gt;#include &lt;unistd.h&gt; // write#include &lt;sys/uio.h&gt; //readv#include &lt;vector&gt; //readv#include &lt;atomic&gt;#include &lt;assert.h&gt;class Buffer &#123;public: Buffer(int initBuffSize = 1024); ~Buffer() = default; size_t WritableBytes() const; size_t ReadableBytes() const ; size_t PrependableBytes() const; const char* Peek() const; void EnsureWriteable(size_t len); void HasWritten(size_t len); void Retrieve(size_t len); void RetrieveUntil(const char* end); void RetrieveAll(); std::string RetrieveAllToStr(); const char* BeginWriteConst() const; char* BeginWrite(); void Append(const std::string&amp; str); void Append(const char* str, size_t len); void Append(const void* data, size_t len); void Append(const Buffer&amp; buff); ssize_t ReadFd(int fd, int* Errno); ssize_t WriteFd(int fd, int* Errno);private: char* BeginPtr_(); // buffer开头 const char* BeginPtr_() const; void MakeSpace_(size_t len); std::vector&lt;char&gt; buffer_; std::atomic&lt;std::size_t&gt; readPos_; // 读的下标 std::atomic&lt;std::size_t&gt; writePos_; // 写的下标&#125;;#endif //BUFFER_H buffer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &quot;buffer.h&quot;// 读写下标初始化，vector&lt;char&gt;初始化Buffer::Buffer(int initBuffSize) : buffer_(initBuffSize), readPos_(0), writePos_(0) &#123;&#125; // 可写的数量：buffer大小 - 写下标size_t Buffer::WritableBytes() const &#123; return buffer_.size() - writePos_;&#125;// 可读的数量：写下标 - 读下标size_t Buffer::ReadableBytes() const &#123; return writePos_ - readPos_;&#125;// 可预留空间：已经读过的就没用了，等于读下标size_t Buffer::PrependableBytes() const &#123; return readPos_;&#125;const char* Buffer::Peek() const &#123; return &amp;buffer_[readPos_];&#125;// 确保可写的长度void Buffer::EnsureWriteable(size_t len) &#123; if(len &gt; WritableBytes()) &#123; MakeSpace_(len); &#125; assert(len &lt;= WritableBytes());&#125;// 移动写下标，在Append中使用void Buffer::HasWritten(size_t len) &#123; writePos_ += len;&#125;// 读取len长度，移动读下标void Buffer::Retrieve(size_t len) &#123; readPos_ += len;&#125;// 读取到end位置void Buffer::RetrieveUntil(const char* end) &#123; assert(Peek() &lt;= end ); Retrieve(end - Peek()); // end指针 - 读指针 长度&#125;// 取出所有数据，buffer归零，读写下标归零,在别的函数中会用到void Buffer::RetrieveAll() &#123; bzero(&amp;buffer_[0], buffer_.size()); // 覆盖原本数据 readPos_ = writePos_ = 0;&#125;// 取出剩余可读的strstd::string Buffer::RetrieveAllToStr() &#123; std::string str(Peek(), ReadableBytes()); RetrieveAll(); return str;&#125;// 写指针的位置const char* Buffer::BeginWriteConst() const &#123; return &amp;buffer_[writePos_];&#125;char* Buffer::BeginWrite() &#123; return &amp;buffer_[writePos_];&#125;// 添加str到缓冲区void Buffer::Append(const char* str, size_t len) &#123; assert(str); EnsureWriteable(len); // 确保可写的长度 std::copy(str, str + len, BeginWrite()); // 将str放到写下标开始的地方 HasWritten(len); // 移动写下标&#125;void Buffer::Append(const std::string&amp; str) &#123; Append(str.c_str(), str.size());&#125;void Append(const void* data, size_t len) &#123; Append(static_cast&lt;const char*&gt;(data), len);&#125;// 将buffer中的读下标的地方放到该buffer中的写下标位置void Append(const Buffer&amp; buff) &#123; Append(buff.Peek(), buff.ReadableBytes());&#125;// 将fd的内容读到缓冲区，即writable的位置ssize_t Buffer::ReadFd(int fd, int* Errno) &#123; char buff[65535]; // 栈区 struct iovec iov[2]; size_t writeable = WritableBytes(); // 先记录能写多少 // 分散读， 保证数据全部读完 iov[0].iov_base = BeginWrite(); iov[0].iov_len = writeable; iov[1].iov_base = buff; iov[1].iov_len = sizeof(buff); ssize_t len = readv(fd, iov, 2); if(len &lt; 0) &#123; *Errno = errno; &#125; else if(static_cast&lt;size_t&gt;(len) &lt;= writeable) &#123; // 若len小于writable，说明写区可以容纳len writePos_ += len; // 直接移动写下标 &#125; else &#123; writePos_ = buffer_.size(); // 写区写满了,下标移到最后 Append(buff, static_cast&lt;size_t&gt;(len - writeable)); // 剩余的长度 &#125; return len;&#125;// 将buffer中可读的区域写入fd中ssize_t Buffer::WriteFd(int fd, int* Errno) &#123; ssize_t len = write(fd, Peek(), ReadableBytes()); if(len &lt; 0) &#123; *Errno = errno; return len; &#125; Retrieve(len); return len;&#125;char* Buffer::BeginPtr_() &#123; return &amp;buffer_[0];&#125;const char* Buffer::BeginPtr_() const&#123; return &amp;buffer_[0];&#125;// 扩展空间void Buffer::MakeSpace_(size_t len) &#123; if(WritableBytes() + PrependableBytes() &lt; len) &#123; buffer_.resize(writePos_ + len + 1); &#125; else &#123; size_t readable = ReadableBytes(); std::copy(BeginPtr_() + readPos_, BeginPtr_() + writePos_, BeginPtr_()); readPos_ = 0; writePos_ = readable; assert(readable == ReadableBytes()); &#125;&#125; 实现单例模式 这里我们需要传入初始化参数所以选择懒汉模式将类的静态对象放到函数静态函数中。 1234567public: static Log* Instance()&#123;static Log log;return &amp;log;&#125; void init(...);private: Log();Log::Instance()-&gt;init(0, &quot;./log&quot;, &quot;.log&quot;, 1024); log.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#ifndef LOG_H#define LOG_H#include &lt;mutex&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt; // vastart va_end#include &lt;assert.h&gt;#include &lt;sys/stat.h&gt; // mkdir#include &quot;blockqueue.h&quot;#include &quot;../buffer/buffer.h&quot;class Log &#123;public: // 初始化日志实例（阻塞队列最大容量、日志保存路径、日志文件后缀） void init(int level, const char* path = &quot;./log&quot;, const char* suffix =&quot;.log&quot;, int maxQueueCapacity = 1024); static Log* Instance(); static void FlushLogThread(); // 异步写日志公有方法，调用私有方法asyncWrite void write(int level, const char *format,...); // 将输出内容按照标准格式整理 void flush(); int GetLevel(); void SetLevel(int level); bool IsOpen() &#123; return isOpen_; &#125;private: Log(); void AppendLogLevelTitle_(int level); virtual ~Log(); void AsyncWrite_(); // 异步写日志方法private: static const int LOG_PATH_LEN = 256; // 日志文件最长文件名 static const int LOG_NAME_LEN = 256; // 日志最长名字 static const int MAX_LINES = 50000; // 日志文件内的最长日志条数 const char* path_; //路径名 const char* suffix_; //后缀名 int MAX_LINES_; // 最大日志行数 int lineCount_; //日志行数记录 int toDay_; //按当天日期区分文件 bool isOpen_; Buffer buff_; // 输出的内容，缓冲区 int level_; // 日志等级 bool isAsync_; // 是否开启异步日志 FILE* fp_; //打开log的文件指针 std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; deque_; //阻塞队列 std::unique_ptr&lt;std::thread&gt; writeThread_; //写线程的指针 std::mutex mtx_; //同步日志必需的互斥量&#125;;#define LOG_BASE(level, format, ...) \\ do &#123;\\ Log* log = Log::Instance();\\ if (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\\ log-&gt;write(level, format, ##__VA_ARGS__); \\ log-&gt;flush();\\ &#125;\\ &#125; while(0);// 四个宏定义，主要用于不同类型的日志输出，也是外部使用日志的接口// ...表示可变参数，__VA_ARGS__就是将...的值复制到这里// 前面加上##的作用是：当可变参数的个数为0时，这里的##可以把把前面多余的&quot;,&quot;去掉,否则会编译出错。#define LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0); #define LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);#define LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);#define LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);#endif //LOG_H log.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;log.h&quot;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;// 构造函数Log::Log() &#123; fp_ = nullptr; deque_ = nullptr; writeThread_ = nullptr; lineCount_ = 0; toDay_ = 0; isAsync_ = false;&#125;Log::~Log() &#123; if(isAsync_) &#123; deque_-&gt;Close(); if(writeThread_ &amp;&amp; writeThread_-&gt;joinable()) &#123; writeThread_-&gt;join(); &#125; &#125; &#123; lock_guard&lt;mutex&gt; locker(mtx_); if(fp_) &#123; flush(); fclose(fp_); fp_ = nullptr; &#125; &#125;&#125;// 唤醒阻塞队列消费者，开始写日志void Log::flush() &#123; if(isAsync_) &#123; // 只有异步日志才会用到deque deque_-&gt;flush(); &#125; fflush(fp_); // 清空输入缓冲区&#125;// 懒汉模式 局部静态变量法（这种方法不需要加锁和解锁操作）Log* Log::Instance() &#123; static Log log; return &amp;log;&#125;// 异步日志的写线程函数void Log::FlushLogThread() &#123; Log::Instance()-&gt;AsyncWrite_();&#125;// 写线程真正的执行函数void Log::AsyncWrite_() &#123; string str = &quot;&quot;; while(true) &#123; if(deque_-&gt;pop(str)) &#123; lock_guard&lt;mutex&gt; locker(mtx_); fputs(str.c_str(), fp_); fflush(fp_); &#125; else &#123; break; // 队列已关闭 &#125; &#125;&#125;// 初始化日志实例void Log::init(int level, const char* path, const char* suffix, int maxQueCapacity) &#123; isOpen_ = true; level_ = level; path_ = path; suffix_ = suffix; if(maxQueCapacity) &#123; // 异步方式 isAsync_ = true; if(!deque_) &#123; // 为空则创建一个 unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; newQue(new BlockQueue&lt;std::string&gt;); // 因为unique_ptr不支持普通的拷贝或赋值操作,所以采用move // 将动态申请的内存权给deque，newDeque被释放 deque_ = move(newQue); // 左值变右值,掏空newDeque unique_ptr&lt;thread&gt; newThread(new thread(FlushLogThread)); writeThread_ = move(newThread); &#125; &#125; else &#123; isAsync_ = false; &#125; lineCount_ = 0; time_t timer = time(nullptr); struct tm* systime = localtime(&amp;timer); char fileName[LOG_NAME_LEN] = &#123;0&#125;; snprintf(fileName, LOG_NAME_LEN - 1, &quot;%s/%04d_%02d_%02d%s&quot;, path_, systime-&gt;tm_year + 1900, systime-&gt;tm_mon + 1, systime-&gt;tm_mday, suffix_); toDay_ = systime-&gt;tm_mday; &#123; lock_guard&lt;mutex&gt; locker(mtx_); buff_.RetrieveAll(); if(fp_) &#123; // 重新打开 flush(); fclose(fp_); &#125; // 确保目录存在 if (access(path_, F_OK) != 0) &#123; mkdir(path_, 0777); &#125; fp_ = fopen(fileName, &quot;a&quot;); if(fp_ == nullptr) &#123; // 输出错误信息便于调试 printf(&quot;Failed to open file %s, errno: %d\\n&quot;, fileName, errno); return; // 或其他错误处理 &#125; assert(fp_ != nullptr); &#125;&#125;void Log::write(int level, const char *format, ...) &#123; struct timeval now = &#123;0, 0&#125;; gettimeofday(&amp;now, nullptr); time_t tSec = now.tv_sec; struct tm *sysTime = localtime(&amp;tSec); struct tm t = *sysTime; va_list vaList; // 日志日期 日志行数 如果不是今天或行数超了 if (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_ % MAX_LINES == 0))) &#123; unique_lock&lt;mutex&gt; locker(mtx_); locker.unlock(); char newFile[LOG_NAME_LEN]; char tail[36] = &#123;0&#125;; snprintf(tail, 36, &quot;%04d_%02d_%02d&quot;, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday); if (toDay_ != t.tm_mday) // 时间不匹配，则替换为最新的日志文件名 &#123; snprintf(newFile, LOG_NAME_LEN - 72, &quot;%s/%s%s&quot;, path_, tail, suffix_); toDay_ = t.tm_mday; lineCount_ = 0; &#125; else &#123; snprintf(newFile, LOG_NAME_LEN - 72, &quot;%s/%s-%d%s&quot;, path_, tail, (lineCount_ / MAX_LINES), suffix_); &#125; locker.lock(); flush(); fclose(fp_); fp_ = fopen(newFile, &quot;a&quot;); assert(fp_ != nullptr); &#125; // 在buffer内生成一条对应的日志信息 &#123; unique_lock&lt;mutex&gt; locker(mtx_); lineCount_++; int n = snprintf(buff_.BeginWrite(), 128, &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec); buff_.HasWritten(n); AppendLogLevelTitle_(level); va_start(vaList, format); int m = vsnprintf(buff_.BeginWrite(), buff_.WritableBytes(), format, vaList); va_end(vaList); buff_.HasWritten(m); buff_.Append(&quot;\\n\\0&quot;, 2); if(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;full()) &#123; // 异步方式（加入阻塞队列中，等待写线程读取日志信息） deque_-&gt;push_back(buff_.RetrieveAllToStr()); &#125; else &#123; // 同步方式（直接向文件中写入日志信息） fputs(buff_.Peek(), fp_); // 同步就直接写入文件 &#125; buff_.RetrieveAll(); // 清空buff &#125;&#125;// 添加日志等级void Log::AppendLogLevelTitle_(int level) &#123; switch(level) &#123; case 0: buff_.Append(&quot;[debug]: &quot;, 9); break; case 1: buff_.Append(&quot;[info] : &quot;, 9); break; case 2: buff_.Append(&quot;[warn] : &quot;, 9); break; case 3: buff_.Append(&quot;[error]: &quot;, 9); break; default: buff_.Append(&quot;[info] : &quot;, 9); break; &#125;&#125;int Log::GetLevel() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return level_;&#125;void Log::SetLevel(int level) &#123; lock_guard&lt;mutex&gt; locker(mtx_); level_ = level;&#125; 测试main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;#include &quot;log/log.h&quot;void AsyncLog() &#123; int cnt = 0; int n = 5; while(n--) &#123; LOG_DEBUG(&quot;这是第%d条异步调试日志&quot;, ++cnt); LOG_INFO(&quot;这是第%d条异步信息日志&quot;, cnt); LOG_WARN(&quot;这是第%d条异步警告日志&quot;, cnt); LOG_ERROR(&quot;这是第%d条异步错误日志&quot;, cnt); &#125;&#125;void SyncLog() &#123; int cnt = 0; int n = 5; while(n--) &#123; LOG_DEBUG(&quot;这是第%d条同步调试日志&quot;, ++cnt); LOG_INFO(&quot;这是第%d条同步信息日志&quot;, cnt); LOG_WARN(&quot;这是第%d条同步警告日志&quot;, cnt); LOG_ERROR(&quot;这是第%d条同步错误日志&quot;, cnt); &#125;&#125;int main() &#123; //初始化异步日志 Log::Instance()-&gt;init(0, &quot;./log&quot;, &quot;.log&quot;, 1024); std::cout &lt;&lt; &quot;测试异步日志...&quot; &lt;&lt; std::endl; AsyncLog(); // 等待异步日志处理完成 std::this_thread::sleep_for(std::chrono::seconds(1)); // 重新初始化为同步日志 // Log::Instance()-&gt;init(0, &quot;./log&quot;, &quot;.log&quot;, 0); // std::cout &lt;&lt; &quot;测试同步日志...&quot; &lt;&lt; std::endl; // SyncLog(); return 0;&#125; 自己实现阻塞队列需要的功能：通过队列指针实现判断队列是否满，添加元素，取出元素 用模板设计，提高这个工具的复用性 使用标准队列queue实现 使用mutex和条件变量保证线程安全，多个线程可以同时使用这个队列 block_queue.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @file block_queue.hpp * @brief 阻塞队列的模板类实现 */#ifndef PROJECT_BLOCK_QUEUE_HPP_#define PROJECT_BLOCK_QUEUE_HPP_#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;condition_variable&gt;#include &lt;mutex&gt;using namespace std;template&lt;typename T&gt;class BlockQueue&#123;private: mutex mtx; condition_variable cvConsumer; condition_variable cvProducer; queue&lt;T&gt; blockQueue; int maxsize; //单例 BlockQueue()&#123;&#125; BlockQueue(const BlockQueue&amp;) = delete; BlockQueue&amp; operator=(const BlockQueue&amp;) = delete;public: //~BlockQueue(); static BlockQueue&amp; getInstance()&#123; static BlockQueue instance;//或者在类外定义 return instance; &#125; void init(int size)&#123;maxsize=size;&#125;; void push(T data); T pop();&#125;;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::push(T data)&#123; unique_lock&lt;mutex&gt; locker(mtx); while(blockQueue.size() &gt;= maxsize) &#123; // 队列满了，需要等待 cvProducer.wait(locker); // 暂停生产，等待消费者唤醒生产条件变量 &#125; blockQueue.push(data); cvConsumer.notify_one(); &#125;template&lt;typename T&gt;T BlockQueue&lt;T&gt;::pop()&#123; unique_lock&lt;mutex&gt; locker(mtx); cvConsumer.wait(locker, [this]&#123; return blockQueue.size() != 0; &#125;); cvProducer.notify_one(); T temp=blockQueue.front(); blockQueue.pop(); return temp;&#125;#endif ###测试 main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;block_queue.hpp&quot;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;string&gt;void producer(int id) &#123; auto&amp; queue = BlockQueue&lt;int&gt;::getInstance(); for(int i = 0; i &lt; 10; i++) &#123; int data = i + id * 100; queue.push(data); &#123; cout &lt;&lt; &quot;生产者 &quot; &lt;&lt; id &lt;&lt; &quot; 生产数据: &quot; &lt;&lt; data &lt;&lt; endl; &#125; this_thread::sleep_for(chrono::milliseconds(200)); // 模拟生产过程 &#125;&#125;void consumer(int id) &#123; auto&amp; queue = BlockQueue&lt;int&gt;::getInstance(); for(int i = 0; i &lt; 5; i++) &#123; int data = queue.pop(); &#123; cout &lt;&lt; &quot;消费者 &quot; &lt;&lt; id &lt;&lt; &quot; 消费数据: &quot; &lt;&lt; data &lt;&lt; endl; &#125; this_thread::sleep_for(chrono::milliseconds(500)); // 模拟消费过程 &#125;&#125;int main() &#123; auto&amp; queue = BlockQueue&lt;int&gt;::getInstance(); queue.init(5); vector&lt;thread&gt; producers; vector&lt;thread&gt; consumers; for(int i = 0; i &lt; 3; i++) &#123; producers.emplace_back(producer, i); &#125; for(int i = 0; i &lt; 2; i++) &#123; consumers.emplace_back(consumer, i); &#125; for(auto&amp; p : producers) &#123; p.join(); &#125; for(auto&amp; c : consumers) &#123; c.join(); &#125; return 0;&#125; 缓冲区作用： 避免频繁内存的分配和释放，重复使用已分配的空间 功能： * 日志功能： 阻塞和非阻塞功能 单例模式 设置掩码打印不同等级日志 打印的日志自动加上时间","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"日志系统","slug":"source/Linux/Linix高性能服务器编程/日志系统","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/日志系统/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;syslog.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; // 封装日志函数 class Logger &#123; public: Logger(const std::string&amp; appName) &#123; openlog(appName.c_str(), LOG_PID | LOG_CONS, LOG_USER); &#125; ~Logger() &#123; closelog(); &#125; void log(int priority, const std::string&amp; message) &#123; syslog(priority, &quot;%s&quot;, message.c_str()); &#125; // 设置日志掩码以过滤日志级别 void setLogMask(int mask) &#123; setlogmask(mask); &#125; // 示例日志方法 void debug(const std::string&amp; msg) &#123; log(LOG_DEBUG, msg); &#125; void info(const std::string&amp; msg) &#123; log(LOG_INFO, msg); &#125; void warning(const std::string&amp; msg) &#123; log(LOG_WARNING, msg); &#125; void error(const std::string&amp; msg) &#123; log(LOG_ERR, msg); &#125; &#125;; int main() &#123; Logger logger(&quot;MyApp&quot;); // 设置日志掩码，过滤掉 LOG_DEBUG 级别的日志 logger.setLogMask(LOG_UPTO(LOG_INFO)); // 允许 LOG_EMERG 到 LOG_INFO，但排除 LOG_DEBUG // 尝试记录不同级别的日志 logger.debug(&quot;This is a debug message.&quot;); // 这将不会出现在日志中 logger.info(&quot;This is an info message.&quot;); // 这将出现在日志中 logger.warning(&quot;This is a warning message.&quot;); // 这将出现在日志中 logger.error(&quot;This is an error message.&quot;); // 这将出现在日志中 return 0; &#125; https://blog.csdn.net/weixin_51322383/article/details/130464403 https://blog.csdn.net/weixin_51322383/article/details/130474753 单例模式设计日志模块 懒汉模式：调用getInstance的时候，才会去初始化，在C++11后，不需要加锁，直接使用函数内局部静态对象即可。 饿汉模式：程序运行时立即初始化，不需要加锁 异步日志 非阻塞，将所写的日志内容先存入阻塞队列中，写线程从阻塞队列中取出内容，写入日志。 日志队列是什么呢？他的需求就是时不时会有一段日志放到队列里面，时不时又会被取出来一段，这不就是经典的生产者消费者模型吗？所以还需要加锁、条件变量等来帮助这个队列实现。 blockqueue.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159# ifndef BLOCKQUEUE_H# define BLOCKQUEUE_H#include &lt;deque&gt;#include &lt;condition_variable&gt;#include &lt;mutex&gt;#include &lt;sys/time.h&gt;using namespace std;template&lt;typename T&gt;class BlockQueue &#123;public: explicit BlockQueue(size_t maxsize = 1000); ~BlockQueue(); bool empty(); bool full(); void push_back(const T&amp; item); void push_front(const T&amp; item); bool pop(T&amp; item); // 弹出的任务放入item bool pop(T&amp; item, int timeout); // 等待时间 void clear(); T front(); T back(); size_t capacity(); size_t size(); void flush(); void Close();private: deque&lt;T&gt; deq_; // 底层数据结构 mutex mtx_; // 锁 bool isClose_; // 关闭标志 size_t capacity_; // 容量 condition_variable condConsumer_; // 消费者条件变量 condition_variable condProducer_; // 生产者条件变量&#125;;template&lt;typename T&gt;BlockQueue&lt;T&gt;::BlockQueue(size_t maxsize) : capacity_(maxsize) &#123; assert(maxsize &gt; 0); isClose_ = false;&#125;template&lt;typename T&gt;BlockQueue&lt;T&gt;::~BlockQueue() &#123; Close();&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::Close() &#123; // lock_guard&lt;mutex&gt; locker(mtx_); // 操控队列之前，都需要上锁 // deq_.clear(); // 清空队列 clear(); isClose_ = true; condConsumer_.notify_all(); condProducer_.notify_all();&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::clear() &#123; lock_guard&lt;mutex&gt; locker(mtx_); deq_.clear();&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::empty() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return deq_.empty();&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::full() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return deq_.size() &gt;= capacity_;&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::push_back(const T&amp; item) &#123; // 注意，条件变量需要搭配unique_lock unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.size() &gt;= capacity_) &#123; // 队列满了，需要等待 condProducer_.wait(locker); // 暂停生产，等待消费者唤醒生产条件变量 &#125; deq_.push_back(item); condConsumer_.notify_one(); // 唤醒消费者&#125;template&lt;typename T&gt;void BlockQueue&lt;T&gt;::push_front(const T&amp; item) &#123; unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.size() &gt;= capacity_) &#123; // 队列满了，需要等待 condProducer_.wait(locker); // 暂停生产，等待消费者唤醒生产条件变量 &#125; deq_.push_front(item); condConsumer_.notify_one(); // 唤醒消费者&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::pop(T&amp; item) &#123; unique_lock&lt;mutex&gt; locker(mtx_); while(deq_.empty()) &#123; condConsumer_.wait(locker); // 队列空了，需要等待 &#125; item = deq_.front(); deq_.pop_front(); condProducer_.notify_one(); // 唤醒生产者 return true;&#125;template&lt;typename T&gt;bool BlockQueue&lt;T&gt;::pop(T &amp;item, int timeout) &#123; unique_lock&lt;std::mutex&gt; locker(mtx_); while(deq_.empty())&#123; if(condConsumer_.wait_for(locker, std::chrono::seconds(timeout)) == std::cv_status::timeout)&#123; return false; &#125; if(isClose_)&#123; return false; &#125; &#125; item = deq_.front(); deq_.pop_front(); condProducer_.notify_one(); return true;&#125;template&lt;typename T&gt;T BlockQueue&lt;T&gt;::front() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.front();&#125;template&lt;typename T&gt;T BlockQueue&lt;T&gt;::back() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.back();&#125;template&lt;typename T&gt;size_t BlockQueue&lt;T&gt;::capacity() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return capacity_;&#125;template&lt;typename T&gt;size_t BlockQueue&lt;T&gt;::size() &#123; lock_guard&lt;std::mutex&gt; locker(mtx_); return deq_.size();&#125;// 唤醒消费者template&lt;typename T&gt;void BlockQueue&lt;T&gt;::flush() &#123; condConsumer_.notify_one();&#125;# endif log.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#ifndef LOG_H#define LOG_H#include &lt;mutex&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt; // vastart va_end#include &lt;assert.h&gt;#include &lt;sys/stat.h&gt; // mkdir#include &quot;blockqueue.h&quot;#include &quot;../buffer/buffer.h&quot;class Log &#123;public: // 初始化日志实例（阻塞队列最大容量、日志保存路径、日志文件后缀） void init(int level, const char* path = &quot;./log&quot;, const char* suffix =&quot;.log&quot;, int maxQueueCapacity = 1024); static Log* Instance(); static void FlushLogThread(); // 异步写日志公有方法，调用私有方法asyncWrite void write(int level, const char *format,...); // 将输出内容按照标准格式整理 void flush(); int GetLevel(); void SetLevel(int level); bool IsOpen() &#123; return isOpen_; &#125; private: Log(); void AppendLogLevelTitle_(int level); virtual ~Log(); void AsyncWrite_(); // 异步写日志方法private: static const int LOG_PATH_LEN = 256; // 日志文件最长文件名 static const int LOG_NAME_LEN = 256; // 日志最长名字 static const int MAX_LINES = 50000; // 日志文件内的最长日志条数 const char* path_; //路径名 const char* suffix_; //后缀名 int MAX_LINES_; // 最大日志行数 int lineCount_; //日志行数记录 int toDay_; //按当天日期区分文件 bool isOpen_; Buffer buff_; // 输出的内容，缓冲区 int level_; // 日志等级 bool isAsync_; // 是否开启异步日志 FILE* fp_; //打开log的文件指针 std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; deque_; //阻塞队列 std::unique_ptr&lt;std::thread&gt; writeThread_; //写线程的指针 std::mutex mtx_; //同步日志必需的互斥量&#125;;#define LOG_BASE(level, format, ...) \\ do &#123;\\ Log* log = Log::Instance();\\ if (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\\ log-&gt;write(level, format, ##__VA_ARGS__); \\ log-&gt;flush();\\ &#125;\\ &#125; while(0);// 四个宏定义，主要用于不同类型的日志输出，也是外部使用日志的接口// ...表示可变参数，__VA_ARGS__就是将...的值复制到这里// 前面加上##的作用是：当可变参数的个数为0时，这里的##可以把把前面多余的&quot;,&quot;去掉,否则会编译出错。#define LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0); #define LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);#define LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);#define LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);#endif //LOG_H log.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &quot;log.h&quot;// 构造函数Log::Log() &#123; fp_ = nullptr; deque_ = nullptr; writeThread_ = nullptr; lineCount_ = 0; toDay_ = 0; isAsync_ = false;&#125;Log::~Log() &#123; while(!deque_-&gt;empty()) &#123; deque_-&gt;flush(); // 唤醒消费者，处理掉剩下的任务 &#125; deque_-&gt;Close(); // 关闭队列 writeThread_-&gt;join(); // 等待当前线程完成手中的任务 if(fp_) &#123; // 冲洗文件缓冲区，关闭文件描述符 lock_guard&lt;mutex&gt; locker(mtx_); flush(); // 清空缓冲区中的数据 fclose(fp_); // 关闭日志文件 &#125;&#125;// 唤醒阻塞队列消费者，开始写日志void Log::flush() &#123; if(isAsync_) &#123; // 只有异步日志才会用到deque deque_-&gt;flush(); &#125; fflush(fp_); // 清空输入缓冲区&#125;// 懒汉模式 局部静态变量法（这种方法不需要加锁和解锁操作）Log* Log::Instance() &#123; static Log log; return &amp;log;&#125;// 异步日志的写线程函数void Log::FlushLogThread() &#123; Log::Instance()-&gt;AsyncWrite_();&#125;// 写线程真正的执行函数void Log::AsyncWrite_() &#123; string str = &quot;&quot;; while(deque_-&gt;pop(str)) &#123; lock_guard&lt;mutex&gt; locker(mtx_); fputs(str.c_str(), fp_); &#125;&#125;// 初始化日志实例void Log::init(int level, const char* path, const char* suffix, int maxQueCapacity) &#123; isOpen_ = true; level_ = level; path_ = path; suffix_ = suffix; if(maxQueCapacity) &#123; // 异步方式 isAsync_ = true; if(!deque_) &#123; // 为空则创建一个 unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; newQue(new BlockQueue&lt;std::string&gt;); // 因为unique_ptr不支持普通的拷贝或赋值操作,所以采用move // 将动态申请的内存权给deque，newDeque被释放 deque_ = move(newQue); // 左值变右值,掏空newDeque unique_ptr&lt;thread&gt; newThread(new thread(FlushLogThread)); writeThread_ = move(newThread); &#125; &#125; else &#123; isAsync_ = false; &#125; lineCount_ = 0; time_t timer = time(nullptr); struct tm* systime = localtime(&amp;timer); char fileName[LOG_NAME_LEN] = &#123;0&#125;; snprintf(fileName, LOG_NAME_LEN - 1, &quot;%s/%04d_%02d_%02d%s&quot;, path_, systime-&gt;tm_year + 1900, systime-&gt;tm_mon + 1, systime-&gt;tm_mday, suffix_); toDay_ = systime-&gt;tm_mday; &#123; lock_guard&lt;mutex&gt; locker(mtx_); buff_.RetrieveAll(); if(fp_) &#123; // 重新打开 flush(); fclose(fp_); &#125; fp_ = fopen(fileName, &quot;a&quot;); // 打开文件读取并附加写入 if(fp_ == nullptr) &#123; mkdir(fileName, 0777); fp_ = fopen(fileName, &quot;a&quot;); // 生成目录文件（最大权限） &#125; assert(fp_ != nullptr); &#125;&#125;void Log::write(int level, const char *format, ...) &#123; struct timeval now = &#123;0, 0&#125;; gettimeofday(&amp;now, nullptr); time_t tSec = now.tv_sec; struct tm *sysTime = localtime(&amp;tSec); struct tm t = *sysTime; va_list vaList; // 日志日期 日志行数 如果不是今天或行数超了 if (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_ % MAX_LINES == 0))) &#123; unique_lock&lt;mutex&gt; locker(mtx_); locker.unlock(); char newFile[LOG_NAME_LEN]; char tail[36] = &#123;0&#125;; snprintf(tail, 36, &quot;%04d_%02d_%02d&quot;, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday); if (toDay_ != t.tm_mday) // 时间不匹配，则替换为最新的日志文件名 &#123; snprintf(newFile, LOG_NAME_LEN - 72, &quot;%s/%s%s&quot;, path_, tail, suffix_); toDay_ = t.tm_mday; lineCount_ = 0; &#125; else &#123; snprintf(newFile, LOG_NAME_LEN - 72, &quot;%s/%s-%d%s&quot;, path_, tail, (lineCount_ / MAX_LINES), suffix_); &#125; locker.lock(); flush(); fclose(fp_); fp_ = fopen(newFile, &quot;a&quot;); assert(fp_ != nullptr); &#125; // 在buffer内生成一条对应的日志信息 &#123; unique_lock&lt;mutex&gt; locker(mtx_); lineCount_++; int n = snprintf(buff_.BeginWrite(), 128, &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;, t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec); buff_.HasWritten(n); AppendLogLevelTitle_(level); va_start(vaList, format); int m = vsnprintf(buff_.BeginWrite(), buff_.WritableBytes(), format, vaList); va_end(vaList); buff_.HasWritten(m); buff_.Append(&quot;\\n\\0&quot;, 2); if(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;full()) &#123; // 异步方式（加入阻塞队列中，等待写线程读取日志信息） deque_-&gt;push_back(buff_.RetrieveAllToStr()); &#125; else &#123; // 同步方式（直接向文件中写入日志信息） fputs(buff_.Peek(), fp_); // 同步就直接写入文件 &#125; buff_.RetrieveAll(); // 清空buff &#125;&#125;// 添加日志等级void Log::AppendLogLevelTitle_(int level) &#123; switch(level) &#123; case 0: buff_.Append(&quot;[debug]: &quot;, 9); break; case 1: buff_.Append(&quot;[info] : &quot;, 9); break; case 2: buff_.Append(&quot;[warn] : &quot;, 9); break; case 3: buff_.Append(&quot;[error]: &quot;, 9); break; default: buff_.Append(&quot;[info] : &quot;, 9); break; &#125;&#125;int Log::GetLevel() &#123; lock_guard&lt;mutex&gt; locker(mtx_); return level_;&#125;void Log::SetLevel(int level) &#123; lock_guard&lt;mutex&gt; locker(mtx_); level_ = level;&#125;","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"TCP/IP协议详解","slug":"source/Linux/Linix高性能服务器编程/TCPIP协议详解","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/TCPIP协议详解/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Linux高性能服务器编程 -游双著 ​ 作者充分理解巨作《TCP&#x2F;IP协议详解》（三卷本），以及《UNIX网络编程》（两卷本）后融入自己的理解编写 ​ 主题：&#x3D;&#x3D;如何通过各种手段编写高性能的服务器程序&#x3D;&#x3D; 如何提高服务器程序性能？ 比如使用“池”以牺牲空间换取效率，使用零拷贝函数以避免内核和用户空间的切换等； 其次，介绍一些高效的编程模式及其应用，比如使用有限状态机来分析用户数据，使用进程池或线程池来处理用户请求；最后，探讨如何通过调整系统参数来从服务器程序外部提高其整体性能。 为了帮助读者进一步把书中的知识融汇到实际项目中，笔者还特意编写了一个较为完整的负载均衡服务器程序springsnail。该程序能从所有逻辑服务器中选取负荷最小的一台来处理新到的客户连接。在这个程序中，使用了进程池、有限状态机、高效数据结构来提高其性能；同时，细致地封装了每个函数和模块，使之更符合实际工程项目。由于篇幅的限制，笔者未将该程序的源代码列在书中，读者可从华章网站www.hzbook.com。 以上内容整本书阅读完之后再看吧 最开始的目的是写一个起码是先看懂tinywebserver这个项目 然后了解到要先看这本书，现在可谓是0基础开始 先安装两台虚拟机用于测试，我打算一台Anolis OS一台Ubuntu Ubuntu正在安，出了点状况，安装界面会一直卡住 TCP&#x2F;IP协议详解 #TCP&#x2F;IP协议族 TCP&#x2F;IP协议族体系结构以及主要协议TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层 ####数据链路层 实现了网卡接口的网络驱动程序 以处理数据在物理媒介（比如以太网、令牌环等）上的传输 网络驱动程序隐藏了这些细节为上层协议提供一个统一的接口 协议 数据链路层两个常用的协议是&#x3D;&#x3D;ARP&#x3D;&#x3D;协议（Address ResolveProtocol，地址解析协议）和&#x3D;&#x3D;RARP&#x3D;&#x3D;协议（Reverse Address ResolveProtocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换 作用 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。 RARP协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。 网络层网络层实现数据包的选路和转发 连接 WAN（Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN（LocalArea Network，局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。 协议 网络层最核心的协议是&#x3D;&#x3D;IP协议&#x3D;&#x3D;（Internet Protocol，因特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（nexthop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，IP协议使用逐跳（hop by hop）的方式确定通信路径。 网络层另外一个重要的协议是&#x3D;&#x3D;ICMP协议&#x3D;&#x3D;（Internet Control MessageProtocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于检测网络连接。 8位类型字段用于区分报文类型。它将ICMP报文分为两大类：一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）；另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。 有的ICMP报文还使用8位代码字段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。 ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（CyclicRedundancy Check，CRC），以检验报文在传输过程中是否损坏。 ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务） 传输层传输层为两台主机上的应用程序提供端到端（end to end）的通信。不在乎中转过程 实线是实体通信，虚线是逻辑通信 传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等 协议 &#x3D;&#x3D;TCP协议&#x3D;&#x3D;（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。 &#x3D;&#x3D;UDP协议&#x3D;&#x3D;（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。 &#x3D;&#x3D;SCTP协议&#x3D;&#x3D;（Stream Control Transmission Protocol，流控制传输协议）是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。 应用层应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节 协议 &#x3D;&#x3D;ping&#x3D;&#x3D;是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。 &#x3D;&#x3D;telnet&#x3D;&#x3D;协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上 &#x3D;&#x3D;OSPF&#x3D;&#x3D;（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息 &#x3D;&#x3D;DNS&#x3D;&#x3D;（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换 应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过&#x2F;etc&#x2F;services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。 封装应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装 经过TCP封装后的数据称为TCP报文段，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲区（发送缓冲区或接收缓冲区）数据一起构成了TCP报文段 经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。 经过IP封装后的数据称为IP数据报（IP datagram）。IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。 经过数据链路层封装的数据称为帧（frame）。传输媒介不同，帧的类型也不同。比如，以太网上传输的是以太网帧（ethernet frame），而令牌环网络上传输的则是令牌环帧（token ring frame） 4字节CRC字段对帧的其他部分提供循环冗余校验 帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。正因为如此，过长的IP数据报可能需要被分片（fragment）传输 帧才是最终在物理网络上传送的字节序列 分用当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用 分用是依靠头部信息中的类型字段实现的 分用帧 为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们 以太网帧为例，它使用2字节的类型字段来标识上层协议。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报，以太网驱动程序就将帧交付给IP模块；若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块；若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模块 分用IP数据报 因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。 TCP报文段和UDP数据报则通过其头部中的16位的端口号（portnumber）字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议（Hyper-Text Transfer Protocol，超文本传送协议）对应的端口号是80。所有知名应用层协议使用的端口号都可在&#x2F;etc&#x2F;services文件中找到。 ARP协议工作原理ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。其工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。 以太网ARP请求&#x2F;应答报文详解 硬件类型字段定义物理地址的类型，它的值为1表示MAC地址 协议类型字段表示要映射的协议地址类型，它的值为0x800，表示IP地址 硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为4。 操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4）。 最后4个字段指定通信双方的以太网地址和IP地址。发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之（当然，如前所述，操作字段需要设置为2）。 ARP请求&#x2F;应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(ARP为数据部分)，则一个携带ARP请求&#x2F;应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节，此时ARP请求&#x2F;应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求&#x2F;应答报文的以太网帧长度为64字节(512bit)。 ARP高速缓存的查看和修改通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度 Linux下可以使用arp命令来查看和修改ARP高速缓存。比如在某一时刻（注意，ARP高速缓存是动态变化的）的ARP缓存内容使用arp-a 12$sudo arp-d 192.168.1.109 #删除对应的ARP缓存项$sudo arp-s 192.168.1.109 08:00:27:53:10:67 #添加对应的ARP缓存项 使用tcpdump观察ARP通信过程 为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet命令登录Kongming20的echo服务（已经开启），并用tcpdump抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下： 12345678910$sudo arp-d 192.168.1.109#清除ARP缓存中Kongming20对应的项$sudo tcpdump-i eth0-ent&#x27;(dst 192.168.1.109 and src 192.168.1.108)or(dst 192.168.1.108 and src 192.168.1.109)&#x27;#如无特殊声明，抓包都在机器ernest-laptop上执行$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令Trying 192.168.1.109...Connected to 192.168.1.109.Escape character is&#x27;^]&#x27;.^]（回车）#输入Ctrl+]并回车telnet＞quit（回车）Connection closed. 应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行 当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容）。tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出（数据包前面的编号是笔者加入的，后同）： 12345671. 00:16:d3:5c:b9:e3＞ff:ff:ff:ff:ff:ff,ethertypeARP(0x0806),length 42:Request who-has 192.168.1.109 tell192.168.1.108,length 282. 08:00:27:53:10:67＞00:16:d3:5c:b9:e3,ethertypeARP(0x0806),length 60:Reply 192.168.1.109 is-at08:00:27:53:10:67,length 46 由tcpdump抓取的数据包本质上是以太网帧，我们通过该命令的众多选项来控制帧的过滤（比如用dst和src指定通信的目的端IP地址和源端IP地址）和显示（比如用-e选项开启以太网帧头部信息的显示）。 第一个数据包中，ARP通信的源端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop），目的端的物理地址是ff:ff:ff:ff:ff:ff，这是以太网的广播地址，用以表示整个LAN。该LAN上的所有机器都会收到并处理这样的帧。数值0x806是以太网帧头部的类型字段的值，它表示分用的目标是ARP模块。该以太网帧的长度为42字节（实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段），其中数据部分长度为28字节。“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。 第二个数据包中，ARP通信的源端的物理地址是08:00:27:53:10:67（Kongming20），目的端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop）。“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20报告其物理地址。该以太网帧的长度为60字节（实际上是64字节），可见它使用了填充字节来满足最小帧长度。 ARP请求和应答是从以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以我们将它们用虚线表示 路由器也将接收到以太网帧1，因为该帧是一个广播帧。不过很显然，路由器并没有回应其中的ARP请求 DNS工作原理我们通常使用机器的域名来访问这台机器，而不直接使用其IP地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢？这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS（Network Information Service，网络信息服务）、DNS和本地静态文件等。本节主要讨论DNS。 DNS查询和应答报文详解DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。 16位标识字段用于标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。 16位标志字段用于协商具体的通信方式和反馈通信状态。 QR，查询&#x2F;应答标志。0表示这是一个查询报文，1表示这是一个应答报文。 opcode，定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态。 AA，授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器 TC，截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断 RD，递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考。 RA，允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询 zero，这3位未用，必须都设置为0。 rcode，4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。 接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。 查询名以一定的格式封装了要查询的主机域名。16位查询类型表示如何执行查询操作，常见的类型有如下几种 类型A，值是1，表示获取目标主机的IP地址。 类型CNAME，值是5，表示获得目标主机的别名 类型PTR，值是12，表示反向查询 16位查询类通常为1，表示获取因特网地址（IP地址） 应答字段、授权字段和额外信息字段都使用资源记录（ResourceRecord，RR）格式 32位域名是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。 16位类型和16位类字段的含义也与DNS查询问题的对应字段相同 32位生存时间表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒 16位资源数据长度字段和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）。 Linux下访问DNS服务我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下 nameserver 219.239.26.42 nameserver 124.207.160.106 我的机子上是nameserver 114.114.114.114 nameserver 8.8.8 分别是首选和备选 Linux下一个常用的访问DNS服务器的客户端程序是host ？？？，比如下面的命令是向首选DNS服务器219.239.26.42查询机器www.baidu.com的IP地址： 1234$host -t A www.baidu.comwww.baidu.com is an alias for www.a.shifen.com.www.a.shifen.com has address 119.75.217.56www.a.shifen.com has address 119.75.218.77 host命令的输出告诉我们，机器名www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。 使用tcpdump观察DNS通信过程为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行host命令以查询主机www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。具体的操作过程如下： $sudo tcpdump-i eth0-nt-s 500 port domain $host-t A www.baidu.com 这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示只抓取使用domain（域名）服务的数据包，即DNS查询和应答报文。tcpdump的输出如下： 12341. IP 192.168.1.108.34319＞219.239.26.42.53 :57428+A?www.baidu.com.(31)2. IP 219.239.26.42.53＞192.168.1.108.34319 :57428 3/4/4 CNAMEwww.a.shifen.com.,A 119.75.218.77,A 119.75.217.56(226) tcpdump以“IP地址.端口号”的形式来描述通信的某一端 第一个是DNS查询报文第二个是应答报文 第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A?”表示使用A类型的查询方式。“www.baidu.com”则是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度（以字节为单位）。 第二个数据包中，“3&#x2F;4&#x2F;4”表示该报文中包含3个应答资源记录、4个授权资源记录和4个额外信息记录。“CNAME www.a.shifen.com.，A119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。该应答报文的长度为226字节。 我们抓包的时候没有开启tcpdump的-X选项（或者-x选项）。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就能明白上面31字节的查询报文和226字节的应答报文的具体含义 socket和TCP&#x2F;IP协议族的关系前文提到，数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（Application Programming Interface，应用程序编程接口）主要有两套：socket和XTI。XTI现在基本不再使用，本书仅讨论socket。 由socket定义的这一组API提供如下两点功能：一是将应用程序数据从用户缓冲区中复制到TCP&#x2F;UDP内核发送缓冲区，以交付内核来发送数据，或者是从内核TCP&#x2F;UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。 值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP&#x2F;IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等） #IP协议详解 IP协议是TCP&#x2F;IP协议族的核心协议，也是socket网络编程的基础之一 IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为 IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及如何转发。 IP服务的特点IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。 无状态（stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。接收端的IP模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。 面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。 虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。 在网络协议中，无状态是很常见的，比如UDP协议和HTTP协议都是无状态协议。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。 无连接（connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。 不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力（best effort）。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误）给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的 IPv4头部结构IP分片IP路由IP转发重定向IPv6头部结构#TCP协议详解 TCP头部信息。源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流 TCP状态转移过程。TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。 TCP数据流。交互数据流和成块数据流。TCP数据流中有一种特殊的数据，称为紧急数据 TCP数据流的控制。为了可靠和通信质量 超时重传和拥塞控制。 TCP服务的特点与UDP的区别： 建立连接 全双工：双方数据读写通过一个连接进行 UDP适合多播和广播 字节流 数据报 编程中，体现为通信双方是否必须执行相同次数的读、写操作 当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。因此，TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。 当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据按照TCP报文段的序号依次放入TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。 UDP则不然。每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送。接收端必须及时针对每一个UDP数据报执行读操作，否则就会丢包。并且，如果用户没有足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断 可靠 TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功 用超时重传机制 定时器时间内没有收到应答重发报文段 收到的IP数据报可能乱序，重复，tcp协议会整理之后再交付 UDP和IP都是不可靠的 ###TCP头部 固定头部结构​ 16位端口号：报文的源端口和目的端口 (客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。知名服务使用的端口号都定义在&#x2F;etc&#x2F;services文件中) 32位序号（sequence number）：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号。A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。 32位确认号（acknowledgement number）：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。 4位头部长度（header length）：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以TCP头部最长是60字节。？？？ URG标志，表示紧急指针（urgent pointer）是否有效。 ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。 PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）。 RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。 SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段 FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。 16位窗口大小（window size）：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。 16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。 TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含20字节的固定部分）。 结构 kind(1字节)+length(1字节)+info(n字节) 选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info是选项的具体信息。常见的TCP选项有7种 没看完。。。 使用tcpdump观察TCP头部信息123456IP 127.0.0.1.41621＞127.0.0.1.23 :Flags[S],seq 3499745539,win 32792,options[mss 16396,sackOK,TS val 40781017 ecr 0,nop,wscale 6],length 00x0000:4510 003c a5da 4000 4006 96cf 7f00 00010x0010:7f00 0001 a295 0017 d099 e103 0000 00000x0020:a002 8018 fe30 0000 0204 400c 0402 080a0x0030:026e 44d9 0000 0000 0103 0306 tcpdump输出Flags[S]，表示该TCP报文段包含SYN标志，因此它是一个同步报文段。 seq是序号值。第一个tcp报文是初始的ISN值，且没有确认号 win是接收通告窗口的大小。因为这是一个同步报文段，所以win值反映的是总共的接收通告窗口大小 options是TCP选项。mss是发送端通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396（16436-40）字节。sackOK表示发送端支持并同意使用SACK选项。TS val是发送端的时间戳。ecr是时间戳回显应答。因为这是一次TCP通信的第一个TCP报文段，所以它针对对方的时间戳的应答为0（尚未收到对方的时间戳）。紧接着的nop是一个空操作选项。wscale指出发送端使用的窗口扩大因子为6。 们分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始 ###TCP连接的建立和关闭 使用tcpdump观察TCP连接的建立和关闭 从ernest-laptop上执行telnet命令登录Kongming20的80端口，然后抓取这一过程中客户端和服务器交换的TCP报文段。 123456789$sudo tcpdump-i eth0-nt &#x27;(src 192.168.1.109 and dst 192.168.1.108)or(src 192.168.1.108 and dst 192.168.1.109)&#x27;//新开一个终端$telnet 192.168.1.109 80Trying 192.168.1.109...Connected to 192.168.1.109.Escape character is&#x27;^]&#x27;. #输入ctrl+]并回车telnet＞quit #结束tcp连接Connection closed. 123456781.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[S],seq 535734930,win 5840,length 02.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[S.],seq 2159701207,ack 535734931,win 5792,length 03.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 1,win 92,length 04.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[F.],seq 1,ack 1,win 92,length 05.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[.],ack 2,win 91,length 06.IP 192.168.1.109.80＞192.168.1.108.60871:Flags[F.],seq 1,ack 2,win 91,length 07.IP 192.168.1.108.60871＞192.168.1.109.80:Flags[.],ack 2,win 92,length 0 length 0 没有应用层数据 ​ 第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。 第2个TCP报文段也是同步报文段，表示同意建立连接。同时它发送自己的ISN值为2159701207的序号，并对第1个同步报文段进行确认。确认值是535734931，即第1个同步报文段的序号值加1。同步报文段比较特殊，即使它并没有携带任何应用程序数据，它也要占用一个序号值。 第3个TCP报文段是对第2个同步报文段的确认。至此，TCP连接就建立起来了。 建立TCP连接的这3个步骤被称为TCP三次握手 从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是相对初始ISN值的偏移。当然，我们可以开启tcpdump的-S选项来选择打印序号的绝对值。 第4个TCP报文段包含FIN标志，因此它是一个结束报文段，即要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。 报文段5来确认该结束报文段。 紧接着发送自己的结束报文段6 TCP报文段7给予确认。 实际上，仅用于确认目的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信息。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确认特性。延迟确认将在后面讨论。 我自己尝试 先安装 tcpdump 和 telnet tcpdump -i ens160 ‘(src 192.168.6.208 and dst 192.168.6.131)or(src 192.168.6.131 and dst 192.168.6.208)’ 1234567[root@localhost ~]# telnet 192.168.6.131 80Trying 192.168.6.131...telnet: connect to address 192.168.6.131: Connection refused[root@localhost ~]# telnet 192.168.6.131 80Trying 192.168.6.131...telnet: connect to address 192.168.6.131: No route to host 123456789[root@localhost .ssh]# tcpdump -i ens160 &#x27;(src 192.168.6.208 and dst 192.168.6.131)or(src 192.168.6.131 and dst 192.168.6.208)&#x27;22:27:14.825789 IP localhost.localdomain.58904 &gt; 192.168.6.131.http: Flags [S], seq 865449386, win 64240, options [mss 1460,sackOK,TS val 1199749114 ecr 0,nop,wscale 7], length 022:27:14.826569 IP 192.168.6.131 &gt; localhost.localdomain: ICMP host 192.168.6.131 unreachable - admin prohibited filter, length 6822:27:20.093253 ARP, Request who-has localhost.localdomain tell 192.168.6.131, length 4622:27:20.093275 ARP, Reply localhost.localdomain is-at 00:0c:29:a0:76:f3 (oui Unknown), length 2822:27:20.196832 ARP, Request who-has 192.168.6.131 tell localhost.localdomain, length 2822:27:20.197899 ARP, Reply 192.168.6.131 is-at 00:0c:29:1f:61:5b (oui Unknown), length 46 半关闭状态通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接 服务器和客户端应用程序判断对方是否已经关闭连接的方法是：read系统调用返回0（收到结束报文段） 很少使用半关闭的程序 连接超时客户端发送出的同步报文段没有应答 对于提供可靠服务的TCP来说，它必然是先进行重连（可能执行多次），如果重连仍然无效，则通知应用程序连接超时。 $sudo iptables-F $sudo iptables-I INPUT-p tcp–syn-i eth0-j DROP iptable命令用于过滤数据包，这里我们利用它来丢弃所有接收到的连接请求（丢弃所有同步报文段，这样客户端就无法得到任何确认报文段）。 123456$sudo tcpdump-n-i eth0 port 23 #仅抓取telnet客户端和服务器交换的数据包$date;telnet 192.168.1.108;date #在telnet命令前后都执行date命令，以计算超时时间Mon Jun 11 21:23:35 CST 2012Trying 192.168.1.108...telnet:connect to address 192.168.1.108:Connection timed outMon Jun 11 21:24:38 CST 2012 建立TCP连接的超时时间是63s 1234567891011121.21:23:35.612136 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096，length 02.21:23:36.613146 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 03.21:23:38.617279 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 04.21:23:42.625140 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 05.21:23:50.641344 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 06.21:24:06.673331 IP 192.168.1.109.39385＞192.168.1.108.telnet:Flags[S],seq 1355982096,length 0 保留了tcpdump输出的时间戳 不使用-t 后面五个都是超时重连报文 第一次2s 每次增倍时间 TCP状态转移TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以通过netstat命令查看 粗虚线表示典型的服务器端连接的状态转移 粗实线表示典型的客户端连接的状态转移。 CLOSED是一个假想的起始点，并不是一个实际的状态。 TCP状态转移总图先从CLOSED开始沿着虚线走一遍就是服务器的状态转移过程 先主动调用listen进入被动连接状态 客户端通过connect系统调用主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接转移到SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败 如果connect连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用，则服务器将给客户端发送一个复位报文段，connect调用失败。 如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败。 connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至ESTABLISHED状态。 当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入TIME_WAIT状态。 客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态，前提是处于FIN_WAIT_1状态的服务器直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段）。 前面说过，处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状态。如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处。连接停留在FIN_WAIT_2状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接（和孤儿进程类似）。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_orphans和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间。 TIME_WAIT状态客户端连接在收到服务器的结束报文段（TCP报文段6）之后，并没有直接进入CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段长为2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL是TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2min 原因 可靠地终止TCP连接。 假设文段7丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。 保证让迟来的TCP报文段有足够的时间被识别并丢弃 在Linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。这个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段（迟到的报文段），这显然是不应该发生的。 另外，因为TCP报文段的最大生存时间是MSL，所以坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失（被中转路由器丢弃）。因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，这就是TIME_WAIT状态要持续2MSL时间的原因。 有时候我们希望避免TIME_WAIT状态，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序将无法启动（直到2MSL超时时间结束）。考虑一个例子：在测试机器ernest-laptop上以客户端方式运行nc（用于创建网络连接的工具，见第17章）命令，登录本机的Web服务，且明确指定客户端使用12345端口与服务器通信。然后从终端输入Ctrl+C终止客户端程序，接着又立即重启nc程序，以完全相同的方式再次连接本机的Web服务。具体操作如下： 12345678$nc-p 12345 192.168.1.108 80ctrl+C#中断客户端程序$nc-p 12345 192.168.1.108 80#重启客户端程序，重新建立连接nc:bind failed:Address already in use#输出显示连接失败，因为12345端口仍被占用$netstat-nat#用netstat命令查看连接状态Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 192.168.1.108:12345 192.168.1.108:80 TIME_WAIT 一般客户端使用系统自动分配的随机端口，我们强制使用12345号端口才会有这样的问题 但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的端口 一个服务器可以接收多少tcp连接？ 复位报文段TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接 访问不存在的端口会发送复位报文段 12345678$sudo tcpdump-nt-i eth0 port 54321#仅抓取发送至和来自54321端口的TCP报文段$telnet 192.168.1.108 54321Trying 192.168.1.108...telnet:connect to address 192.168.1.108:Connection refused1.IP 192.168.1.109.42001＞192.168.1.108.54321:Flags[S],seq 21621375,win 14600,length 02.IP 192.168.1.108.54321＞192.168.1.109.42001:Flags[R.],seq 0,ack 21621376,win 0,length 0 回复一个复位报文段R 接收通告窗口为0，所以收到复位的一方不能回应并且应该关闭或重新连接 当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段 异常终止连接TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。 应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。 处理半打开连接服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。 举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该端口上，接着拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。同时，运行tcpdump程序抓取整个过程中telnet客户端和nc服务器交换的TCP报文段。具体操作过程如下： 1234567891011121314$nc-l 12345#在Kongming20上运行服务器程序$sudo tcpdump-nt-i eth0 port 12345$telnet 192.168.1.109 12345#在ernest-laptop上运行客户端程序Trying 192.168.1.109...Connected to 192.168.1.109.Escape character is&#x27;^]&#x27;.#此时断开ernest-laptop的网线，并重启服务器a（回车）#向半打开连接输入字符aConnection closed by foreign host.1.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[S],seq 3093809365,length 02.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[S.],seq 1495337791,ack 3093809366,length 03.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[.],ack 1,length 04.IP 192.168.1.108.55100＞192.168.1.109.12345:Flags[P.],seq 1:4,ack 1,length 35.IP 192.168.1.109.12345＞192.168.1.108.55100:Flags[R],seq 1495337792,length 0 该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。 第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是：字母“a”、回车符“\\r”和换行符“\\n”。不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。 TCP交互数据流TCP报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节。 使用交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。 考虑如下情况：在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet客户端和telnet服务器交换的TCP报文段。具体操作过程如下： 123456789101112131415161718192021$tcpdump-nt-i lo port 23$telnet 127.0.0.1Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is&#x27;^]&#x27;.Ubuntu 9.10ernest-laptop login:ernest（回车） #输入用户名并回车Password:（回车） #输入密码并回车ernest@ernest-laptop:～$ls（回车）1.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1408334812:1408334813,ack 1415955507,win 613,length 12.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 1:2,ack 1,win 512,length 13.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 2,win 613,length 04.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 1:2,ack 2,win 613,length 15.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 2:3,ack 2,win 512,length 16.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 3,win 613,length 07.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[P.],seq 2:4,ack 3,win 613,length 28.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 3:176,ack 4,win 512,length 1739.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 176,win 630,length 010.IP 127.0.0.1.23＞127.0.0.1.58130:Flags[P.],seq 176:228,ack 4,win 512,length 5211.IP 127.0.0.1.58130＞127.0.0.1.23:Flags[.],ack 228,win 630,length 0 TCP报文段1由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。TCP报文段2是服务器对TCP报文段1的确认，同时回显字母“l”。TCP报文段3是客户端对TCP报文段2的确认。第4～6个TCP报文段是针对字母“s”的上述过程。TCP报文段7传送的2字节数据分别是：客户端键入的回车符和流结束符（EOF，本例中是0x00）。TCP报文段8携带服务器返回的客户查询的目录的内容（ls命令的输出），包括该目录下文件的文件名及其显示控制参数。TCP报文段9是客户端对TCP报文段8的确认。TCP报文段10携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量（第一级命令提示符）。TCP报文段11是客户端对TCP报文段10的确认。 在上述过程中，客户端针对服务器返回的数据所发送的确认报文段（TCP报文段6、9和11）都不携带任何应用程序数据（长度为0），而服务器每次发送的确认报文段（TCP报文段2、5、8和10）都包含它需要发送的应用程序数据。服务器的这种处理方式称为延迟确认，即它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。延迟确认可以减少发送TCP报文段的数量。而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。 前文曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多（一个按键输入就导致一个TCP报文段），这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用Nagle算法。Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越快。 TCP成块数据流下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序（升级的、安全版的ftp服务器程序），并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端和vsftpd服务器交换的TCP报文段。具体操作过程如下： 123456789101112131415161718192021222324252627282930$sudo tcpdump-nt-i eth0 port 20#vsftpd服务器程序使用端口号20$ftp 127.0.0.1Connected to 127.0.0.1.220(vsFTPd 2.3.0)Name(127.0.0.1:ernest):ernest（回车）#输入用户名并回车331 Please specify the password.Password:（回车） #输入密码并回车230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp＞get bigfile（回车） #获取大文件bigfile1.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205783041:205799425,ack 1,win 513,length 163842.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205799425:205815809,ack 1,win 513,length 163843.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205815809:205832193,ack 1,win 513,length 163844.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205832193:205848577,ack 1,win 513,length 163845.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205848577:205864961,ack 1,win 513,length 163846.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205864961:205881345,ack 1,win 513,length 163847.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205881345:205897729,ack 1,win 513,length 163848.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205897729:205914113,ack 1,win 513,length 163849.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205914113:205930497,ack 1,win 513,length 1638410.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205930497:205946881,ack 1,win 513,length 1638411.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205946881:205963265,ack 1,win 513,length 1638412.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 205963265:205979649,ack 1,win 513,length 1638413.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205979649:205996033,ack 1,win 513,length 1638414.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 205996033:206012417,ack 1,win 513,length 1638415.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[.],seq 206012417:206028801,ack 1,win 513,length 1638416.IP 127.0.0.1.20＞127.0.0.1.39651:Flags[P.],seq 206028801:206045185,ack 1,win 513,length 1638417.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 205815809,win 30084,length 018.IP 127.0.0.1.39651＞127.0.0.1.20:Flags[.],ack 206045185,win 27317,length 0 注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认（从序号值和确认值来判断）。由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。那么发送方在收到上一次确认后，能连续发送多少个TCP报文段呢？这是由接收通告窗口（还需要考虑拥塞窗口，见后文）的大小决定的。TCP报文段17说明客户端还能接收30 084×64字节（本例中窗口扩大因子为6），即1 925 376字节的数据。而在TCP报文段18中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3～16中的一部分。服务器收到TCP报文段18后，它至少（因为接收通告窗口可能扩大）还能连续发送的未被确认的报文段数量是1 748288&#x2F;16 384个，即106个（但一般不会连续发送这么多）。其中，16384是成块数据的长度（见TCP报文段1～16的length值），很显然它小于但接近MSS规定的16 396字节。 另外一个值得注意的地方是，服务器每发送4个TCP报文段就传送一个PSH标志（tcpdump输出标志P）给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间（接收通告窗口大小不为0）。 下面我们修改系统的TCP接收缓冲区和TCP发送缓冲区的大小，使之都为4096字节，然后重启vsftpd服务器，并再次执行上述操作。 123451.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[.],seq 5195777:5197313,ack 1,win 3072,length 15362.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[.],seq 5197313:5198849,ack 1,win 3072,length 15363.IP 127.0.0.1.45227＞127.0.0.1.20:Flags[.],ack 5198849,win 3072,length 04.IP 127.0.0.1.20＞127.0.0.1.45227:Flags[P.],seq 5198849:5200385,ack 1,win 3072,length 15365.IP 127.0.0.1.45227＞127.0.0.1.20:Flags[.],ack 5200385,win 3072,length 0 从同步报文段（未在代码中列出）得知在这次通信过程中，客户端和服务器的窗口扩大因子都为0，因而客户端和服务器每次通告的窗口大小都是3072字节（没超过4096字节，预料之中）。因为每个成块数据的长度为1536字节，所以服务器在收到上一个TCP报文段的确认之前最多还能再发送1个TCP报文段，这正是TCP报文段1～3描述的情形。 带外数据实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序。 TCP超时重传异常网络状况下（开始出现超时或丢包），TCP如何控制数据传输以保证其承诺的可靠服务。 TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。 我们通过实例来研究Linux下TCP的超时重传策略。在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据（此处是“1234”）给服务器，然后断开服务器的网线并再次从客户端发送一些数据给服务器（此处是“12”）。同时，用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作过程如下： 123456789$sudo tcpdump-n-i eth0 port 5001$iperf-s #在ernest-laptop上执行$telnet 192.168.1.108 5001 #在Kongming20上执行Trying 192.168.1.108...Connected to 192.168.1.108.Escape character is&#x27;^]&#x27;.1234#发送完之后断开服务器网线12Connection closed by foreign host iperf是一个测量网络状况的工具，-s选项表示将其作为服务器运行。iperf默认监听5001端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器。 代码就不展示了 TCP报文段1～3是三次握手建立连接的过程，TCP报文段4～5是客户端发送数据“1234”（应用程序数据长度为6，包括回车、换行两个字符，后同）及服务器确认的过程。TCP报文段6是客户端第一次发送数据“12”的过程。因为服务器的网线被断开，所以客户端无法收到TCP报文段6的确认报文段。此后，客户端对TCP报文段6执行了5次重传，它们是TCP报文段7～11，这可以从每个TCP报文段的序号得知。此后，数据包12～23都是ARP模块的输出内容，即Kongming20查询ernest-laptop的MAC地址。 我们保留了tcpdump输出的时间戳，以便推理TCP的超时重传策略。观察TCP报文段6～11被发送的时间间隔，它们分别为0.2 s、0.4s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍（因此，和TCP超时重连的策略相似）。在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。 Linux有两个重要的内核参数与TCP超时重传相关：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries1和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15（一般对应13～30 min）。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min（可以用date命令来测量）。虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传 拥塞控制TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制。 TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分：慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。拥塞控制算法在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。它们或者部分或者全部实现了上述四个部分。&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。 … #TCP&#x2F;IP通信案例：访问Internet上的Web服务器 Web客户端和服务器之间使用HTTP协议通信 实例总图在Kongming20上运行wget客户端程序，在ernest-laptop上运行squid代理服务器程序。客户端通过代理服务器的中转，获取Internet上的主机www.baidu.com的首页文档index.html wget客户端程序和代理服务器之间，以及代理服务器与Web服务器之间都是使用HTTP协议通信的。HTTP协议是一种应用层协议，它默认使用的传输层协议是TCP协议。 将ernest-laptop设置为Kongming20的HTTP代理服务器，在Kongming20上设置环境变量http_proxy： $export http_proxy&#x3D;”ernest-laptop:3128” 3128是squid服务器默认使用的端口号（可以通过lsof命令查看服务器程序监听的端口号）。设置好环境变量之后，Kongming20访问任何Internet上的Web服务器时，其HTTP请求都将首先发送至ernest-laptop的3128端口。 squid代理服务器接收到wget客户端的HTTP请求之后，将简单地修改这个请求，然后把它发送给最终的目标Web服务器。代理服务器访问的是Internet上的机器，可以预见它发送的IP数据报都将经过路由器的中转 部署代理服务器由于通信实例中使用了HTTP代理服务器（squid程序），所以先简单介绍一下HTTP代理服务器的工作原理，以及如何部署squid代理服务器 HTTP代理服务器的工作原理在HTTP通信链上，一个HTTP请求可能被多个代理服务器转发，后面的服务器称为前面服务器的上游服务器。代理服务器按照其使用方式和作用， 正向代理要求客户端自己设置代理服务器的地址。客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用正向代理服务器 反向代理则被设置在服务器端，因而客户端无须进行任何设置。反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。 透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况 代理服务器通常还提供缓存目标资源的功能（可选），这样用户下次访问同一资源时速度将很快。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而varnish仅能用作反向代理 部署squid代理服务器现在我们在ernest-laptop上部署squid代理服务器。 修改squid服务器的配置文件&#x2F;etc&#x2F;squid3&#x2F;squid.conf 12acl localnet src 192.168.1.0/24http_access allow localnet 这两行代码的含义是：允许网络192.168.1.0上的所有机器通过该代理服务器来访问Web服务器。 我们通过上面的两行代码简单地配置了squid的访问控制。但实际应用中，squid提供更多、更安全的配置，比如用户验证等。 重启squid服务器： $sudo service squid3 restart service是一个脚本程序（&#x2F;usr&#x2F;sbin&#x2F;service），它为&#x2F;etc&#x2F;init.d&#x2F;目录下的众多服务器程序（比如httpd、vsftpd、sshd和mysqld等）的启动（start）、停止（stop）和重启（restart）等动作提供了一个统一的管理。现在，Linux程序员已经越来越偏向于使用service脚本来管理服务器程序了 使用tcpdump抓取传输数据包在执行wget命令前，我们首先应删除ernest-laptop的ARP高速缓存中路由器对应的项，以便观察TCP&#x2F;IP通信过程中ARP协议何时起作用。然后，使用tcpdump命令抓取整个通信过程中传输的数据包。 1234567891011$sudo arp-d 192.168.1.1$sudo tcpdump-s 2000-i eth0-ntX&#x27;(src 192.168.1.108)or(dst 192.168.1.108)or(arp)&#x27;$wget--header=&quot;Connection:close&quot;http://www.baidu.com/index.html--2012-07-03 00:51:12--http://www.baidu.com/index.htmlResolving ernest-laptop...192.168.1.108Connecting to ernest-laptop|192.168.1.108|:3128...connected.Proxy request sent,awaiting response...200 OKLength:8024(7.8K)[text/html]Saving to:“index.html”100%[=======================＞]8,024--.-K/s in 0.001s2012-07-03 00:51:12(8.76 MB/s)-“index.html”saved[8024/8024] wget命令的输出显示，HTTP请求确实是先被送至代理服务器的3128端口，并且代理服务器正确地返回了文件index.html的内容。 43个数据包这里没有显示 代理服务器访问DNS服务器以查询域名www.baidu.com对应的IP地址，包括数据包8、9。 代理服务器查询路由器MAC地址的ARP请求和应答，包括数据包6、7。 wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之间的HTTP通信，包括数据包1～5、23～25、32～40、42和43。 代理服务器和Web服务器（119.75.218.77）之间的HTTP通信，包括数据包10～22、26～31和41。 访问DNS服务器数据包8、9表示代理服务器ernest-laptop向DNS服务器（219.239.26.42，首选DNS服务器的IP地址）查询域名www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别名（www.a.shifen.com）和两个IP地址（119.75.218.77和119.75.217.56）。 squid程序通过读取&#x2F;etc&#x2F;resolv.conf文件获得DNS服务器的IP地址，然后将控制权传递给内核中的UDP模块。 UDP模块将DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入UDP数据报头部，然后UDP模块调用IP服务。 IP模块则将UDP数据报封装成IP数据报，并把源端IP地址（192.168.1.108）和DNS服务器的IP地址加入IP数据报头部。接下来，IP模块查询路由表以决定如何发送该IP数据报。根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表中的默认路由项，因此该IP数据报先被发送至路由器（IP地址为192.168.1.1），然后通过路由器来转发。因为ernest-laptop的ARP缓存中没有与路由器对应的缓存项（我们手动将其删除了），所以ernest laptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6描述的内容。路由器则通过ARP应答告诉ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78，如数据包7所示。最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器。此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了路由器的IP地址和MAC地址的映射关系 需要指出的是，虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务器）的IP地址，而不是中转路由器的IP地址（192.168.1.1）。这说明，IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在转发过程中则是一直在变化的。 本地名称查询一般来说，通过域名来访问时，需要使用DNS服务来获取IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。Linux将目标主机名及其对应的IP地址存储在&#x2F;etc&#x2F;hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。Kongming20上&#x2F;etc&#x2F;hosts文件的内容如下（笔者手动修改过）： 123127.0.0.1 localhost192.168.1.109 Kongming20192.168.1.108 ernest-laptop 其中第一项指出本地回路地址127.0.0.1的名称是localhost，第二项和第三项则分别描述了Kongming20和ernest-laptop的IP地址及对应的主 机名。代码清单4-1中，wget命令输出“Resolving ernest laptop…192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的IP地址，原因如下：当wget访问某个Web服务器时，它先读取环境变量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读取&#x2F;etc&#x2F;hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。其结果正如wget的输出所示，解析成功 如果程序在&#x2F;etc&#x2F;hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。用户可以通过修改&#x2F;etc&#x2F;host.conf文件来自定义系统解析主机名的方法和顺序（一般是先访问本地文件&#x2F;etc&#x2F;hosts，再访问DNS服务）， Kongming20上的该文件内容如下： order hosts,bind multi on 其中第一行表示优先使用&#x2F;etc&#x2F;hosts文件来解析主机名（hosts），失败后再使用DNS服务（bind）。第二行表示如果&#x2F;etc&#x2F;hosts文件中一个主机名对应多个IP地址，那么解析的结果就包含多个IP地址。 HTTP通信 TCP连接从建立到关闭的过程中，客户端仅给服务器发送了一个HTTP请求（即TCP报文段4）,代理服务器返回了六个tcp报文，总长8522字节，客户端用了七个tcp报文确定应答 HTTP请求1234GET http://www.baidu.com/index.html HTTP/1.0User-Agent:Wget/1.12(linux-gnu)Host:www.baidu.comConnection:close GET请求方法，只读 的方式请求 HEAD、GET、OPTIONS和TRACE被视为安全的方法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源 GET、HEAD、OPTIONS、TRACE、PUT和DELETE等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请求和只发送一次该请求具有完全相同的效果。而POST方法则不同，连续多次发送同样一个请求可能进一步影响服务器上的资源 Linux上提供了几个命令：HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。它们适合用来快速测试Web服务器 “http://www.baidu.com/index.html”是目标资源的URL。其中“http”是所谓的**scheme**，表示获取目标资源需要使用的应用层协议。其他常见的scheme还有ftp、rtsp和file等。“www.baidu.com”指定资源所在的目标主机。“index.html”指定资源文件的名称，这里指的是服务器根目录（站点的根目录，而不是服务器的文件系统根目录“/”）中的索引文件。“HTTP/1. 0”表示客户端（wget程序）使用的HTTP的版本号是1.0。目前的主流HTTP版本是1.1。 HTTP请求内容中的第2～4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排列。 “User-Agent:Wget&#x2F;1. 12(linux-gnu)”表示客户端使用的程序是wget。 “Host:www. baidu.com”表示目标主机名是www.baidu.com。HTTP协议规定HTTP请求中必须包含的头部字段就是目标主机名。 “Connection:close”是我们执行wget命令时传入的，告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就（主动）将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。 长连接与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。HTTP请求和应答中的“Connection”头部字段就是专门用于告诉对方一个请求完成之后该如何处理连接的，比如立即关闭连接（该头部字段的值为“close”）或者保持一段时间以等待后续请求（该头部字段的值为“keep-alive”）。当用浏览器访问一个网页时，读者不妨使用netstat命令来查看浏览器和Web服务器之间的连接是否是长连接，以及该连接维持了多长时间。 在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部字段的结束。请求行和每个头部字段都必须以＜CR＞＜LF＞结束（回车符和换行符）；而空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白字符。在空行之后，HTTP请求可以包含可选的消息体。如果消息体非空，则HTTP请求的头部字段中必须包含描述该消息体长度的字段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以没有消息体 HTTP应答1234567HTTP/1.0 200 OKServer:BWS/1.0Content-Length:8024Content-Type:text/html;charset=gbkSetCookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=.baidu.comVia:1.0 localhost(squid/3.0 STABLE18) 第一行是状态行。“HTTP&#x2F;1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。 第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。 “Server:BWS&#x2F;1. 0”表示目标Web服务器程序的名字是BWS（Baidu Web Server） “Content-Length:8024”表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致 “Content-Type:text&#x2F;html;charset&#x3D;gbk”表示目标文档的MIME类型。其中“text”是主文档类型，“html”是子文档类型。“text&#x2F;html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码 “Set Cookie:BAIDUID&#x3D;A5B6C72D68CF639CE8896FD79A03FBD8:FG&#x3D;1;expires&#x3D;Wed,04-Jul-42 00:10:47 GMT;path&#x3D;&#x2F;;domain&#x3D;. baidu.com”表示服务器传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie生效的域名和路径。下面我们简单分析一下Cookie的作用。 HTTP协议是一种无状态的协议，即每个HTTP请求之间没有任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就导致HTTP请求必须传输更多的数据。在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序通常要承上启下。因此，我们要使用额外的手段来保持HTTP连接状态，常见的解决方法就是Cookie。Cookie是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息（通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同的客户了。基于浏览器的自动登录就是用Cookie实现的。 “Via:1. 0 localhost(squid&#x2F;3.0 STABLE18)”表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由功能。 在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部字段的结束。状态行和每个头部字段都必须以＜CR＞＜LF＞结束；而空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白字符。 空行之后是被请求文档index.html的内容，其长度是8024字节。","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"时间堆","slug":"source/Linux/Linix高性能服务器编程/时间堆","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/时间堆/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E6%97%B6%E9%97%B4%E5%A0%86/","excerpt":"","text":"用小根堆的时间堆 处理定时事件，定期监测一个客户连接的活动状态，一般的做法是将每个定时事件封装成定时器，并使用某种容器类数据结构将所有的定时器保存好，常用方法有排序链表、红黑树、时间堆和时间轮。 传统的定时方案是以固定频率调用起搏函数tick，进而执行定时器上的回调函数。而时间堆的做法则是将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，当超时时间到达时，处理超时事件，然后再次从剩余定时器中找出超时时间最小的一个，依次反复即可。 关键词：定时器，回调函数 简单解释：节点组成：fd 时间点 回调函数 ，用一个vector维护了一个小根堆，也就是最快到时间的排在第一个，是一个完全二叉树，并且用一个哈希表&lt;fd,index&gt;来记录对应文件描述符在vetor中的位置，每次插入一个节点或者修改时间或者删除节点都需要对堆进行维护，还提供一个tick检查是否超时的方法，不断取出第一个节点，如果超时则删除节点并调用回调函数 关于c++ 11 时间的调用： 都是可以使用typedef重命名简化代码 123456std::chrono::high_resolution_clock::time_point 用于存时间点std::chrono::high_resolution_clock::now() 获取当前时间//将计算出来的时间差用duration_cast模板转化为milliseconds 毫秒级别std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::time_point - std::chrono::high_resolution_clock::now()).count() 考虑封装一个固定一个时间频率取出的时间队列 代码实现heaptimer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &quot;heaptimer.h&quot;void HeapTimer::SwapNode_(size_t i, size_t j) &#123; assert(i &gt;= 0 &amp;&amp; i &lt;heap_.size()); assert(j &gt;= 0 &amp;&amp; j &lt;heap_.size()); swap(heap_[i], heap_[j]); ref_[heap_[i].id] = i; // 结点内部id所在索引位置也要变化 ref_[heap_[j].id] = j; &#125;void HeapTimer::siftup_(size_t i) &#123; assert(i &gt;= 0 &amp;&amp; i &lt; heap_.size()); size_t parent = (i-1) / 2; while(parent &gt;= 0) &#123; if(heap_[parent] &gt; heap_[i]) &#123;//保证第一个vetor的第一个元素是最先到时间的 SwapNode_(i, parent); i = parent; parent = (i-1)/2; &#125; else &#123; break; &#125; &#125;&#125;// false：不需要下滑 true：下滑成功bool HeapTimer::siftdown_(size_t i, size_t n) &#123; assert(i &gt;= 0 &amp;&amp; i &lt; heap_.size()); assert(n &gt;= 0 &amp;&amp; n &lt;= heap_.size()); // n:共几个结点 auto index = i; auto child = 2*index+1; while(child &lt; n) &#123; if(child+1 &lt; n &amp;&amp; heap_[child+1] &lt; heap_[child]) &#123; child++; &#125; if(heap_[child] &lt; heap_[index]) &#123; SwapNode_(index, child); index = child; child = 2*child+1; &#125; break; // 需要跳出循环 &#125; return index &gt; i;&#125;// 删除指定位置的结点void HeapTimer::del_(size_t index) &#123; assert(index &gt;= 0 &amp;&amp; index &lt; heap_.size()); // 将要删除的结点换到队尾，然后调整堆 size_t tmp = index; size_t n = heap_.size() - 1; assert(tmp &lt;= n); // 如果就在队尾，就不用移动了 if(index &lt; heap_.size()-1) &#123; SwapNode_(tmp, heap_.size()-1); if(!siftdown_(tmp, n)) &#123; siftup_(tmp); &#125; &#125; ref_.erase(heap_.back().id); heap_.pop_back();&#125;// 调整指定id的结点void HeapTimer::adjust(int id, int newExpires) &#123;//调整时间点 向下浮动 assert(!heap_.empty() &amp;&amp; ref_.count(id)); heap_[ref_[id]].expires = Clock::now() + MS(newExpires); siftdown_(ref_[id], heap_.size());&#125;void HeapTimer::add(int id, int timeOut, const TimeoutCallBack&amp; cb) &#123; assert(id &gt;= 0); //这里的id是fd // 如果有，则调整 if(ref_.count(id)) &#123;//判断id这个key出现的次数，unordered_map不允许重复，所以就是判断有没有 int tmp = ref_[id]; heap_[tmp].expires = Clock::now() + MS(timeOut); heap_[tmp].cb = cb; if(!siftdown_(tmp, heap_.size())) &#123; siftup_(tmp); &#125; &#125; else &#123; size_t n = heap_.size();//当前vetcor的大小 ref_[id] = n;//哈希表ref的作用就是记录系节点在vetcor中的索引 heap_.push_back(&#123;id, Clock::now() + MS(timeOut), cb&#125;); // 右值 设置时间点为下一个超时的时间点 siftup_(n);//上浮，与父节点比较，直至堆顶或者大于父节点 &#125;&#125;// 删除指定id，并触发回调函数void HeapTimer::doWork(int id) &#123; if(heap_.empty() || ref_.count(id) == 0) &#123; return; &#125; size_t i = ref_[id]; auto node = heap_[i]; node.cb(); // 触发回调函数 del_(i);&#125;void HeapTimer::tick() &#123; /* 清除超时结点 */ if(heap_.empty()) &#123; return; &#125; while(!heap_.empty()) &#123; TimerNode node = heap_.front();//返回第一个节点 if(std::chrono::duration_cast&lt;MS&gt;(node.expires - Clock::now()).count() &gt; 0) &#123; break; //检查时间间隔，没有过期则退出 &#125; node.cb();//到期则触发回调并删除第一个节点 pop(); &#125;&#125;void HeapTimer::pop() &#123; assert(!heap_.empty()); del_(0);&#125;void HeapTimer::clear() &#123; ref_.clear(); heap_.clear();&#125;int HeapTimer::GetNextTick() &#123; tick(); size_t res = -1; if(!heap_.empty()) &#123; res = std::chrono::duration_cast&lt;MS&gt;(heap_.front().expires - Clock::now()).count(); if(res &lt; 0) &#123; res = 0; &#125; &#125; return res;&#125; heaptimer.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#ifndef HEAP_TIMER_H#define HEAP_TIMER_H#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;time.h&gt;#include &lt;algorithm&gt;#include &lt;arpa/inet.h&gt; #include &lt;functional&gt; #include &lt;assert.h&gt; #include &lt;chrono&gt;#include &quot;../log/log.h&quot;typedef std::function&lt;void()&gt; TimeoutCallBack;//函数模板 没有参数和返回值typedef std::chrono::high_resolution_clock Clock;typedef std::chrono::milliseconds MS; //毫秒typedef Clock::time_point TimeStamp;//时间点类型struct TimerNode &#123; int id; TimeStamp expires; // 超时时间点 TimeoutCallBack cb; // 回调function&lt;void()&gt; bool operator&lt;(const TimerNode&amp; t) &#123; // 重载比较运算符 return expires &lt; t.expires; &#125; bool operator&gt;(const TimerNode&amp; t) &#123; // 重载比较运算符 return expires &gt; t.expires; &#125;&#125;;class HeapTimer &#123;public: HeapTimer() &#123; heap_.reserve(64); &#125; // 保留64个TimerNode的空间 ~HeapTimer() &#123; clear(); &#125; void adjust(int id, int newExpires); void add(int id, int timeOut, const TimeoutCallBack&amp; cb); void doWork(int id); void clear(); void tick(); void pop(); int GetNextTick();private: void del_(size_t i); void siftup_(size_t i); bool siftdown_(size_t i, size_t n); void SwapNode_(size_t i, size_t j); std::vector&lt;TimerNode&gt; heap_;//存放 id 时间点 // key:id value:vector的下标 std::unordered_map&lt;int, size_t&gt; ref_; // id对应的在heap_中的下标，方便用heap_的时候查找&#125;;#endif //HEAP_TIMER_H ###main.cpp 12345678910111213141516171819#include &lt;iostream&gt;#include &quot;heaptimer.h&quot;using namespace std;void hello()&#123; cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl;&#125;int main()&#123; HeapTimer ht; ht.add(1, 5000, hello);//可以使用bind绑定函数 ht.add(2, 1000, hello); sleep(5);//睡2秒只打印一个hello睡5秒打印两个 ht.tick(); //获取下一个到期时间间隔 ht.add(3, 1000, hello); cout&lt;&lt;ht.GetNextTick()&lt;&lt;endl; ht.doWork(3);//删除节点3并回调 return 0;&#125;","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"连接池","slug":"source/Linux/Linix高性能服务器编程/连接池","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-03T12:45:53.382Z","comments":true,"path":"2025/03/02/source/Linux/Linix高性能服务器编程/连接池/","permalink":"http://example.com/2025/03/02/source/Linux/Linix%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"安装mysql库文件 #include &lt;mysql&#x2F;mysql.h&gt; sudo yum install epel-release 安装epel软件库 sudo yum install mysql-devel g++ -o my_program my_program.cpp -lmysqlclient 日志测试程序 1234567891011121314151617181920212223242526272829303132#include &quot;log/log.h&quot;#include &lt;iostream&gt;#include &quot;log/blockqueue.h&quot;void producer(BlockQueue&lt;int&gt;&amp; queue, int id) &#123; for (int i = 0; i &lt; 10; ++i) &#123; int item = id * 100 + i; queue.push_back(item); std::cout &lt;&lt; &quot;Producer &quot; &lt;&lt; id &lt;&lt; &quot; produced &quot; &lt;&lt; item &lt;&lt; std::endl; //std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟耗时操作 &#125;&#125;// 消费者线程函数void consumer(BlockQueue&lt;int&gt;&amp; queue, int id) &#123; for (int i = 0; i &lt; 10; ++i) &#123; int item; if (queue.pop(item)) &#123; std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; id &lt;&lt; &quot; consumed &quot; &lt;&lt; item &lt;&lt; std::endl; //std::this_thread::sleep_for(std::chrono::milliseconds(150)); // 模拟耗时操作 &#125; else &#123; std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; id &lt;&lt; &quot; timed out&quot; &lt;&lt; std::endl; &#125; &#125;&#125;int main()&#123; Log::Instance()-&gt;init(0, &quot;./log&quot;, &quot;.log&quot;, 0); LOG_DEBUG(&quot;========== Server init error!==========&quot;); LOG_WARN(&quot;========== Server init error!==========&quot;); LOG_ERROR(&quot;========== Server init error!==========&quot;); LOG_INFO(&quot;========== Server init error!==========&quot;); return 0;&#125; 数据库123456789101112131415161718192021222324252627282930313233拉取MySQL镜像bashdocker pull mysql:latest运行MySQL容器并设置root密码bashdocker run --name mysql-container -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:latest这里my-secret-pw是你要设置的root密码，请替换为你自己想要设置的密码。登录MySQL后台使用以下命令登录MySQL容器：bashdocker exec -it mysql-container mysql -uroot -p输入你设置的root密码。创建数据库testsqlCREATE DATABASE test;使用数据库testUSE test;CREATE TABLE test ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL, age INT NOT NULL);INSERT INTO test (name, age) VALUES (&#x27;LiMing&#x27;, 30); 查看images [root@localhost test]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest be960704dfac 3 weeks ago 602MB、 确定端口可用情况 netstat -tuln | grep 3306 docker ps -a 确定container名字可用情况 docker rm 启动container 12345678910docker run -id \\-p 3306:3306 \\--name mysql-container \\--restart always \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/log:/var/log/mysql \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:latest \\--lower_case_table_names=1 docker exec -it mysql-container bash 进入mysql bash终端 mysql -uroot -p 输入密码123456后进入mysql 使用Navicat 成功远程连接 CREATE DATABASE test; USE test; CREATE TABLE test ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50) NOT NULL, age INT NOT NULL ); INSERT INTO test (name, age) VALUES (&#39;LiMing&#39;, 30); 12345* 错误 test: /root/my_log/code/main.cpp:66: void TestSqlConnPoll(): Assertion `conn&#39; failed. 已放弃 (核心已转储) why?不能使用”localhost” 要使用 “127.0.0.1” 还是有错误段错误 (核心已转储) 。。。原来是查询的命令错了","categories":[{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"docker","slug":"source/工具-环境/Docker","date":"2025-03-01T16:00:00.000Z","updated":"2025-03-11T14:51:50.712Z","comments":true,"path":"2025/03/02/source/工具-环境/Docker/","permalink":"http://example.com/2025/03/02/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/Docker/","excerpt":"","text":"docker为每一个应用提供完全隔离的环境-配置的环境也叫做container&#x2F;容器 image&#x2F;镜像：包含部署的程序以及关联的所有库 容器：通过镜像创建，就像一台台运行起来的虚拟机 安装Docker 卸载旧版 12345678yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 配置Docker的yum库 首先要安装一个yum工具 1yum install -y yum-utils 安装成功后，执行命令，配置Docker的yum源： 1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装Docker 1yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker -v 查看版本 docker images显示没有连接，docker也是一个服务进程(如mysql)需要启动 启动和校验12345678910# 启动Dockersystemctl start docker# 停止Dockersystemctl stop docker# 重启systemctl restart docker# 设置开机自启systemctl enable docker# 执行docker ps命令，如果不报错，说明安装启动成功docker ps ##配置镜像加速 镜像加速在24年中旬g了 以前的阿里镜像 1234567891011121314# 创建目录mkdir -p /etc/docker# 复制内容，注意把其中的镜像加速地址改成你自己的tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://1l76bl56.mirror.aliyuncs.com&quot;]&#125;EOF# 重新加载配置systemctl daemon-reload# 重启Dockersystemctl restart docker 部署mysql123456docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql 下载的是安装好的mysql-&#x3D;&#x3D;镜像&#x3D;&#x3D;(包含应用-环境-配置-函数库) docker在运行镜像时会创建一个隔离的环境-容器 可以换个名字换个端口3307:3306再次运行一个镜像 docker ps查看运行的镜像 镜像仓库:全球Docker Hub 华为 腾讯 ali 公司私服 命令解读 docker run -d ：创建并运行一个容器，-d 容器后台运行 –name mysql : 容器名字 -p 3306:3306 : 设置端口映射。 前面是宿主端口 后面是容器端口 容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。 -e TZ&#x3D;Asia&#x2F;Shanghai : 配置容器内进程运行时的一些参数-环境变量 格式：-e KEY&#x3D;VALUE，KEY和VALUE都由容器内进程决定 docker hub上查 案例中，TZ&#x3D;Asia&#x2F;Shanghai是设置时区；MYSQL_ROOT_PASSWORD&#x3D;123是设置MySQL默认密码 mysql: 设置镜像名称，Docker会根据这个名字搜索并下载镜像 格式：REPOSITORY:TAG，例如mysql:8.0，其中REPOSITORY为镜像名，TAG是版本号 在未指定TAG的情况下，默认是最新版本，也就是mysql:latest Docker基础Docker官方文档： https://docs.docker.com/ 常见命令首先我们来学习Docker中的常见命令，可以参考官方文档： https://docs.docker.com/engine/reference/commandline/cli/ 命令介绍其中，比较常见的命令有： 命令 说明 文档地址 docker pull 拉取镜像 docker pull docker push 推送镜像到DockerRegistry docker push docker images 查看本地镜像 docker images docker rmi 删除本地镜像 docker rmi docker run 创建并运行容器（不能重复创建） docker run docker stop 停止指定容器 docker stop docker start 启动指定容器 docker start docker restart 重新启动容器 docker restart docker rm 删除指定容器 docs.docker.com docker ps 查看容器 docker ps docker logs 查看容器运行日志 docker logs docker exec 进入容器 docker exec docker save 保存镜像到本地压缩文件 docker save docker load 加载本地压缩文件到镜像 docker load docker inspect 查看容器详细信息 docker inspect 补充： 默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启： 1234# Docker开机自启systemctl enable docker# Docker容器开机自启docker update --restart=always [容器名/容器id] 演示Nginx12345678910111213141516171819202122232425262728293031323334# 第1步，去DockerHub查看nginx镜像仓库及相关信息# 第2步，拉取Nginx镜像docker pull nginx# 第3步，查看镜像docker images# 结果如下：REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 605c77e624dd 16 months ago 141MBmysql latest 3218b38490ce 17 months ago 516MB# 第4步，创建并允许Nginx容器docker run -d --name nginx -p 80:80 nginx# 第5步，查看运行中容器docker ps# 也可以加格式化方式访问，格式会更加清爽docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第6步，访问网页，地址：http://虚拟机地址# 第7步，停止容器docker stop nginx# 第8步，查看所有容器(包括停掉的)docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第9步，再次启动nginx容器docker start nginx# 第10步，再次查看容器docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;# 第11步，查看容器详细信息docker inspect nginx# 第12步，进入容器,查看容器内目录docker exec -it nginx bash# 或者，可以进入MySQLdocker exec -it mysql mysql -uroot -p# 第13步，删除容器docker rm nginx# 发现无法删除，因为容器运行中，强制删除容器docker rm -f nginx 当想使用docker save不知道后面怎么写了,docker save --help查看帮助 docker save -o nginx.tar nginx:lastest就会在目录下生存一个nginx.tar的文件 可以拷贝到别的机器上使用 docker rmi nginx:lastest删除镜像 docker load -i naginx.tar使用刚才打包的文件 docker logs -f nginx持续查看日志-用于调试 ###命令别名 123456789101112131415161718# 修改/root/.bashrc文件vi /root/.bashrc或vi ~/.bashrc内容如下：# .bashrc# User specific aliases and functionsalias rm=&#x27;rm -i&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Image&#125;&#125;\\t&#123;&#123;.Ports&#125;&#125;\\t&#123;&#123;.Status&#125;&#125;\\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;alias dis=&#x27;docker images&#x27;# Source global definitionsif [ -f /etc/bashrc ]; then . /etc/bashrcfi 生效: 1source /root/.bashrc ##数据卷 案例一创建nginx容器，修改nginx容器内html目录下index.html文件,查看变化 将静态资源部署到nginx的html目录 找到index.html文件在哪里 看官网 docker exec -it nginx bash cd /usr/share/nginx/html vi index.html #没有命令vi 文件内修改资源很困难 **数据卷（volume）**是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。 一旦绑定,一着变则全变 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为&#x2F;数据卷名&#x2F;_data docker volume –help 命令 说明 文档地址 docker volume create(不用自己创建-v挂载的时候会自动创建) 创建数据卷 docker volume create docker volume ls 查看所有数据卷 docs.docker.com docker volume rm 删除指定数据卷 docs.docker.com docker volume inspect 查看某个数据卷的详情 docs.docker.com docker volume prune 清除数据卷 docker volume prune 12345678910111213141516171819202122232425262728293031323334353637383940# 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx #先把原来的删除了 docker rm -f nginx# 2.然后查看数据卷docker volume ls# 结果DRIVER VOLUME NAMElocal 29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459flocal html# 3.查看数据卷详情docker volume inspect html# 结果[ &#123; &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;, &quot;Name&quot;: &quot;html&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;]# 4.查看/var/lib/docker/volumes/html/_data目录ll /var/lib/docker/volumes/html/_data# 可以看到与nginx的html目录内容一样，结果如下：总用量 8-rw-r--r--. 1 root root 497 12月 28 2021 50x.html-rw-r--r--. 1 root root 615 12月 28 2021 index.html# 5.进入该目录，并随意修改index.html内容cd /var/lib/docker/volumes/html/_datavi index.html# 6.打开页面，查看效果# 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化docker exec -it nginx bash 改完访问ip可以看到改完的网页,也可以在这个目录下再上传更多的静态资源 通过&#x2F;访问 ###MySQL容器的数据挂载(匿名卷) 教学演示环节：演示一下MySQL的匿名数据卷 123# 1.查看MySQL容器详细信息docker inspect mysql# 关注其中.Config.Volumes部分和.Mounts部分 我们关注两部分内容，第一是.Config.Volumes部分： 123456789&#123; &quot;Config&quot;: &#123; // ... 略 &quot;Volumes&quot;: &#123; &quot;/var/lib/mysql&quot;: &#123;&#125; &#125; // ... 略 &#125;&#125; 可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是数据卷未定义。这就是匿名卷。 然后，我们再看结果中的.Mounts部分： 1234567891011&#123; &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;, &quot;Destination&quot;: &quot;/var/lib/mysql&quot;, &quot;Driver&quot;: &quot;local&quot;, &#125; ]&#125; 可以发现，其中有几个关键属性： Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。 Source：宿主机目录 Destination : 容器内的目录 上述配置是将容器内的/var/lib/mysql这个目录，与数据卷29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f挂载。于是在宿主机中就有了/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。 接下来，可以查看该目录下的MySQL的data文件： 1ls -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data 这个匿名卷挂的是数据库存储的信息(数据库-表等,便于迁移数据) 注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考DockerHub对应的页面 删除容器-卷还在-数据也还在-使用新的容器后想要迁移过去比较麻烦-一般自己做一个挂载-且不挂在valume下 挂载本地目录或文件可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似： 1234# 挂载本地目录-v 本地目录:容器内目录# 挂载本地文件-v 本地文件:容器内文件 注意：本地目录或文件必须以 / 或 ./开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。 例如： 12-v mysql:/var/lib/mysql # 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷-v ./mysql:/var/lib/mysql # 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录 教学演示，删除并重新创建mysql容器，并完成本地目录挂载：(查官方文档)(先创建好本地目录) 挂载/root/mysql/data到容器内的/var/lib/mysql目录 挂载/root/mysql/init到容器内的/docker-entrypoint-initdb.d目录（初始化的SQL脚本目录(初始化一些要用到数据库)） 挂载/root/mysql/conf到容器内的/etc/mysql/conf.d目录（这个是MySQL配置文件目录）(配置成utf-8) 在课前资料中已经准备好了mysql的init目录和conf目录： 以及对应的初始化SQL脚本和配置文件： 其中，hm.cnf主要是配置了MySQL的默认编码，改为utf8mb4；而hmall.sql则是后面我们要用到的黑马商城项目的初始化SQL脚本。 我们直接将整个mysql目录上传至虚拟机的/root目录下： 接下来，我们演示本地目录挂载： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# 1.删除原来的MySQL容器docker rm -f mysql# 2.进入root目录cd ~# 3.创建并运行新mysql容器，挂载本地目录docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ -v ./mysql/data:/var/lib/mysql \\ -v ./mysql/conf:/etc/mysql/conf.d \\ -v ./mysql/init:/docker-entrypoint-initdb.d \\ mysql# 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了ls -l mysql# 结果：总用量 4drwxr-xr-x. 2 root root 20 5月 19 15:11 confdrwxr-xr-x. 7 polkitd root 4096 5月 19 15:11 datadrwxr-xr-x. 2 root root 23 5月 19 15:11 init# 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化ls -l data# 5.查看MySQL容器内数据# 5.1.进入MySQLdocker exec -it mysql mysql -uroot -p123# 5.2.查看编码表show variables like &quot;%char%&quot;;# 5.3.结果，发现编码是utf8mb4没有问题+--------------------------+--------------------------------+| Variable_name | Value |+--------------------------+--------------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8mb3 || character_sets_dir | /usr/share/mysql-8.0/charsets/ |+--------------------------+--------------------------------+# 6.查看数据# 6.1.查看数据库show databases;# 结果，hmall是黑马商城数据库+--------------------+| Database |+--------------------+| hmall || information_schema || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec)# 6.2.切换到hmall数据库use hmall;# 6.3.查看表show tables;# 结果：+-----------------+| Tables_in_hmall |+-----------------+| address || cart || item || order || order_detail || order_logistics || pay_order || user |+-----------------+# 6.4.查看address表数据+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| id | user_id | province | city | town | mobile | street | contact | is_default | notes |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+| 59 | 1 | 北京 | 北京 | 朝阳区 | 13900112222 | 金燕龙办公楼 | 李佳诚 | 0 | NULL || 60 | 1 | 北京 | 北京 | 朝阳区 | 13700221122 | 修正大厦 | 李佳红 | 0 | NULL || 61 | 1 | 上海 | 上海 | 浦东新区 | 13301212233 | 航头镇航头路 | 李佳星 | 1 | NULL || 63 | 1 | 广东 | 佛山 | 永春 | 13301212233 | 永春武馆 | 李晓龙 | 0 | NULL |+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+4 rows in set (0.00 sec) ##镜像 前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？ 镜像结构镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。 依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。 举个例子，我们要从0部署一个Java应用，大概流程是这样： 准备一个linux服务（CentOS或者Ubuntu均可） 安装并配置JDK 上传Jar包 运行jar包 那因此，我们打包镜像也是分成这么几步： 准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可） 安装并配置JDK 拷贝jar包 配置启动脚本 上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以镜像就是一堆文件的集合。 但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为Layer（层）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。 例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示： Dockerfile由于制作镜像的过程中，需要逐层处理和打包，Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。 而这种记录镜像结构的文件就称为Dockerfile，其对应的语法可以参考官方文档： https://docs.docker.com/engine/reference/builder/ 其中的语法比较多，比较常用的有： 指令 说明 示例 FROM 指定基础镜像 FROM centos:6 ENV 设置环境变量，可在后面指令使用 ENV key value COPY 拷贝本地文件到镜像的指定目录 COPY ./xx.jar /tmp/app.jar RUN 执行Linux的shell命令，一般是安装过程的命令 RUN yum install gcc EXPOSE 指定容器运行时监听的端口，是给镜像使用者看的(告诉使用者用这个端口做映射) EXPOSE 8080 ENTRYPOINT 镜像中应用的启动命令，容器运行时调用 ENTRYPOINT java -jar xx.jar 例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下： 123456789101112131415161718192021# 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录、容器内时区ENV JAVA_DIR=/usr/localENV TZ=Asia/Shanghai# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 设定时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 安装JDKRUN cd $JAVA_DIR \\ &amp;&amp; tar -xf ./jdk8.tar.gz \\ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 指定项目监听的端口EXPOSE 8080# 入口，java项目的启动命令ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;] 同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。 所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了： 123456789# 基础镜像-需要先下载FROM openjdk:11.0-jre-buster# 设定时区(可有可无)ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 拷贝jar包COPY docker-demo.jar /app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;] 构建镜像当Dockerfile文件写好以后，就可以利用命令来构建镜像了。 在课前资料中，我们准备好了一个demo项目及对应的Dockerfile： 首先，我们将课前资料提供的docker-demo.jar包以及Dockerfile拷贝到虚拟机的/root/demo目录： 然后，执行命令，构建镜像： 1234# 进入镜像目录cd /root/demo# 开始构建docker build -t docker-demo:1.0 . 命令说明： docker build : 就是构建一个docker镜像 -t docker-demo:1.0 ：-t参数是指定镜像的名称（repository和tag） . : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是.代表当前目录，也可以直接指定Dockerfile目录： # 直接指定Dockerfile目录 docker build -t docker-demo:1.0 /root/demo 123456789101112131415结果：![img](https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY1NmI2ZDgxN2ZhNTg3ODk1MjIwYTZhOGUwMWZlZDRfZVRraWJRTWhJRmxpbmVxY3NTdklVa1MzcDRiU0RLNFVfVG9rZW46R0RqMmJzeDFzb0Q0eXV4N3hLWmNXcHoxbmhlXzE3MDQ1OTcxMTI6MTcwNDYwMDcxMl9WNA)查看镜像列表：```Bash# 查看镜像列表：docker images# 结果REPOSITORY TAG IMAGE ID CREATED SIZEdocker-demo 1.0 d6ab0b9e64b9 27 minutes ago 327MBnginx latest 605c77e624dd 16 months ago 141MBmysql latest 3218b38490ce 17 months ago 516MB 然后尝试运行该镜像： 12345678910111213# 1.创建并运行容器docker run -d --name dd -p 8090:8090 docker-demo:1.0# 2.查看容器dps# 结果CONTAINER ID IMAGE PORTS STATUS NAMES78a000447b49 docker-demo:1.0 0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp Up 2 seconds ddf63cfead8502 mysql 0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp Up 2 hours mysql# 3.访问curl localhost:8080/hello/count# 结果：&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt; 网络项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢？ 首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址： 123456# 1.用基本命令，寻找Networks.bridge.IPAddress属性docker inspect mysql# 也可以使用format过滤结果docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mysql# 得到IP地址如下：172.17.0.2 在同一个网段中 但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。 所以，我们必须借助于docker的网络功能来解决这个问题，官方文档： https://docs.docker.com/engine/reference/commandline/network/ 常见命令有： 命令 说明 文档地址 docker network create 创建一个网络 docker network create docker network ls 查看所有网络 docs.docker.com docker network rm 删除指定网络 docs.docker.com docker network prune 清除未使用的网络 docs.docker.com docker network connect 使指定容器连接加入某网络 docs.docker.com docker network disconnect 使指定容器连接离开某网络 docker network disconnect docker network inspect 查看网络详细信息 docker network inspect 创建好docker后会自动创建一个docker 0的虚拟的网卡172.17.0.1&#x2F;16 默认容器是以网桥连接到虚拟网络中.容器可以互连并且可以通过容器名互联 123456789101112131415161718192021222324252627282930313233# 1.首先通过命令创建一个网络docker network create hmall# 2.然后查看网络docker network ls# 结果：NETWORK ID NAME DRIVER SCOPE639bc44d0a87 bridge bridge local403f16ec62a2 hmall bridge local0dc0f72a0fbb host host localcd8d3e8df47b none null local# 其中，除了hmall以外，其它都是默认的网络# 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名# 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名docker network connect hmall mysql --alias db# 3.2.db容器，也就是我们的java项目docker network connect hmall dd# 4.进入dd容器，尝试利用别名访问db# 4.1.进入容器docker exec -it dd bash# 4.2.用db别名访问ping db# 结果PING db (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms# 4.3.用容器名访问ping mysql# 结果：PING mysql (172.18.0.2) 56(84) bytes of data.64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms OK，现在无需记住IP地址也可以实现容器互联了。 总结： 在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身 在同一个自定义网络中的容器，可以通过别名互相访问 ip addr 可以看到虚拟机的网卡默认只有l0 ens(虚拟机真实ip) docker0 多一个我们设置的新的网桥 项目部署在课前资料中已经提供了一个黑马商城项目给大家，如图： 项目说明： hmall：商城的后端代码 hmall-portal：商城用户端的前端代码 hmall-admin：商城管理端的前端代码 部署的容器及端口说明： 项目 容器名 端口 备注 hmall hmall 8080 黑马商城后端API入口 hmall-portal nginx 18080 黑马商城用户端入口 hmall-admin 18081 黑马商城管理端入口 mysql mysql 3306 数据库 mysql容器中已经准备好了商城的数据，所以就不再删除了。 部署Java项目hmall项目是一个maven聚合项目，使用IDEA打开hmall项目，查看项目结构如图： 我们要部署的就是其中的hm-service，其中的配置文件采用了多环境的方式： 其中的application-dev.yaml是部署到开发环境的配置，application-local.yaml是本地运行时的配置。 查看application.yaml，你会发现其中的JDBC地址并未写死，而是读取变量： 这两个变量在application-dev.yaml和application-local.yaml中并不相同： 在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问。 我们将项目打包： 结果： 将hm-service目录下的Dockerfile和hm-service/target目录下的hm-service.jar一起上传到虚拟机的root目录： 部署项目： 1234567891011121314# 1.构建项目镜像，不指定tag，则默认为latestdocker build -t hmall .# 2.查看镜像docker images# 结果REPOSITORY TAG IMAGE ID CREATED SIZEhmall latest 0bb07b2c34b9 43 seconds ago 362MBdocker-demo 1.0 49743484da68 24 hours ago 327MBnginx latest 605c77e624dd 16 months ago 141MBmysql latest 3218b38490ce 17 months ago 516MB# 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysqldocker run -d --name hmall --network hmall -p 8080:8080 hmall 测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机地址:8080&#x2F;search&#x2F;list 部署前端hmall-portal和hmall-admin是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录： 其中： html是静态资源目录，我们需要把hmall-portal以及hmall-admin都复制进去 nginx.conf是nginx的配置文件，主要是完成对html下的两个静态资源目录做代理 我们现在要做的就是把整个nginx目录上传到虚拟机的/root目录下： 然后创建nginx容器并完成两个挂载： 把/root/nginx/nginx.conf挂载到/etc/nginx/nginx.conf 把/root/nginx/html挂载到/usr/share/nginx/html 由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口： 18080：对应hmall-portal 18081：对应hmall-admin 命令如下： 12345678docker run -d \\ --name nginx \\ -p 18080:18080 \\ -p 18081:18081 \\ -v /root/nginx/html:/usr/share/nginx/html \\ -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\ --network hmall \\ nginx 测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机ip:18080 DockerCompose大家可以看到，我们部署一个简单的java项目，其中包含3个容器： MySQL Nginx Java项目 而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。 而Docker Compose就可以帮助我们实现多个相互关联的Docker容器的快速部署。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。 基本语法docker-compose.yml文件的基本语法可以参考官方文档： https://docs.docker.com/compose/compose-file/compose-file-v3/ docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与docker run参数非常相似。 举例来说，用docker run部署MySQL的命令如下： 12345678910docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ -v ./mysql/data:/var/lib/mysql \\ -v ./mysql/conf:/etc/mysql/conf.d \\ -v ./mysql/init:/docker-entrypoint-initdb.d \\ --network hmall mysql 如果用docker-compose.yml文件来定义，就是这样： 12345678910111213141516171819version: &quot;3.8&quot;services: mysql: image: mysql container_name: mysql ports: - &quot;3306:3306&quot; environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;./mysql/conf:/etc/mysql/conf.d&quot; - &quot;./mysql/data:/var/lib/mysql&quot; networks: - newnetworks: new: name: hmall 对比如下： docker run 参数 docker compose 指令 说明 –name container_name 容器名称 -p ports 端口映射 -e environment 环境变量 -v volumes 数据卷配置 –network networks 网络 明白了其中的对应关系，相信编写docker-compose文件应该难不倒大家。 黑马商城部署文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344version: &quot;3.8&quot;services: mysql: image: mysql container_name: mysql ports: - &quot;3306:3306&quot; environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123 volumes: - &quot;./mysql/conf:/etc/mysql/conf.d&quot; - &quot;./mysql/data:/var/lib/mysql&quot; - &quot;./mysql/init:/docker-entrypoint-initdb.d&quot; networks: - hm-net hmall: build: context: . dockerfile: Dockerfile container_name: hmall ports: - &quot;8080:8080&quot; networks: - hm-net depends_on: - mysql nginx: image: nginx container_name: nginx ports: - &quot;18080:18080&quot; - &quot;18081:18081&quot; volumes: - &quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot; - &quot;./nginx/html:/usr/share/nginx/html&quot; depends_on: - hmall networks: - hm-netnetworks: hm-net: name: hmall 基础命令编写好docker-compose.yml文件，就可以部署项目了。常见的命令： https://docs.docker.com/compose/reference/ 基本语法如下： 1docker compose [OPTIONS] [COMMAND] 其中，OPTIONS和COMMAND都是可选参数，比较常见的有： 类型 参数或指令 说明 Options -f 指定compose文件的路径和名称 -p 指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念 Commands up 创建并启动所有service容器 down 停止并移除所有容器、网络 ps 列出所有启动的容器 logs 查看指定容器的日志 stop 停止容器 start 启动容器 restart 重启容器 top 查看运行的进程 exec 在指定的运行中容器中执行命令 教学演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 1.进入root目录cd /root# 2.删除旧容器docker rm -f $(docker ps -qa)# 3.删除hmall镜像docker rmi hmall# 4.清空MySQL数据rm -rf mysql/data# 5.启动所有, -d 参数是后台启动docker compose up -d# 结果：[+] Building 15.5s (8/8) FINISHED =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 358B 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load metadata for docker.io/library/openjdk:11.0-jre-buster 15.4s =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3 0.0s =&gt; [internal] load build context 0.0s =&gt; =&gt; transferring context: 98B 0.0s =&gt; CACHED [2/3] RUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 0.0s =&gt; CACHED [3/3] COPY hm-service.jar /app.jar 0.0s =&gt; exporting to image 0.0s =&gt; =&gt; exporting layers 0.0s =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71 0.0s =&gt; =&gt; naming to docker.io/library/root-hmall 0.0s[+] Running 4/4 ✔ Network hmall Created 0.2s ✔ Container mysql Started 0.5s ✔ Container hmall Started 0.9s ✔ Container nginx Started 1.5s# 6.查看镜像docker compose images# 结果CONTAINER REPOSITORY TAG IMAGE ID SIZEhmall root-hmall latest 32eebee16acd 362MBmysql mysql latest 3218b38490ce 516MBnginx nginx latest 605c77e624dd 141MB# 7.查看容器docker compose ps# 结果NAME IMAGE COMMAND SERVICE CREATED STATUS PORTShmall root-hmall &quot;java -jar /app.jar&quot; hmall 54 seconds ago Up 52 seconds 0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcpmysql mysql &quot;docker-entrypoint.s…&quot; mysql 54 seconds ago Up 53 seconds 0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcpnginx nginx &quot;/docker-entrypoint.…&quot; nginx 54 seconds ago Up 52 seconds 80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp 打开浏览器，访问：http://yourIp:8080","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"力扣面试50题","slug":"source/刷题/leetcode","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/06/09/source/刷题/leetcode/","permalink":"http://example.com/2024/06/09/source/%E5%88%B7%E9%A2%98/leetcode/","excerpt":"","text":"数组&#x2F;字符串88 合并两个有序数组非递减顺序：从小到大排列 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] 我的：先nums2中插入到nums1中0的位置 然后使用选择排序 123456789101112131415161718class Solution &#123; //排序public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m;i&lt;m+n;i++)&#123; nums1[i]=nums2[i-m]; &#125; int i,j; for(i=1; i&lt;n+m; i++) &#123; //sort(nums1.begin(), nums1.end()); if(nums1[i]&lt;nums1[i-1]) &#123; int temp=nums1[i]; for(j=i-1; j&gt;=0 &amp;&amp; nums1[j]&gt;temp; j--) &#123; nums1[j+1]=nums1[j]; &#125; nums1[j+1]=temp; &#125; &#125; &#125;&#125;; 双指针 利用两个数组已经有序，创建一个新的数组，每次取两个数组中的最小放进去 1234567891011121314151617181920212223class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) &#123; if (p1 == m) &#123; cur = nums2[p2++]; &#125; else if (p2 == n) &#123; cur = nums1[p1++]; &#125; else if (nums1[p1] &lt; nums2[p2]) &#123; cur = nums1[p1++]; &#125; else &#123; cur = nums2[p2++]; &#125; sorted[p1 + p2 - 1] = cur; &#125; for (int i = 0; i != m + n; ++i) &#123; nums1[i] = sorted[i]; &#125; &#125;&#125;; 逆向双指针 0ms 避免使用临时变量创建一个新的数组，不用担心覆盖nums1的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//我的class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int l=m-1; int j=n-1; int i=m+n-1; while(j&gt;=0)&#123; if(l&gt;=0&amp;&amp;nums1[l]&gt;nums2[j])&#123; nums1[i]=nums1[l]; l--; &#125;else&#123; nums1[i]=nums2[j]; j--; &#125; i--; &#125; &#125;&#125;; class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) &#123; if (p1 == -1) &#123; cur = nums2[p2--]; &#125; else if (p2 == -1) &#123; cur = nums1[p1--]; &#125; else if (nums1[p1] &gt; nums2[p2]) &#123; cur = nums1[p1--]; &#125; else &#123; cur = nums2[p2--]; &#125; nums1[tail--] = cur; &#125; &#125;&#125;;class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int left = m - 1, right = n - 1, cur = m + n - 1; while (left &gt;= 0 &amp;&amp; right &gt;= 0) nums1[cur--] = nums1[left] &gt; nums2[right] ? nums1[left--] : nums2[right--]; //&gt;优先级大于= // nums1剩下的已经排序，可以跳过 while (right &gt;= 0) nums1[cur--] = nums2[right--]; &#125;&#125;; 27 移除元素返回剩下的元素个数 12输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3] 0ms 12345678910111213class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end();it++)&#123; if(*it==val)&#123; nums.erase(it); it--; &#125; &#125; return nums.size(); &#125;&#125;; 或 使用双指针 26 删除有序数组中的重复项给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 12345678910111213141516//484ms 迭代器class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end()-1;it++)&#123; for(vector&lt;int&gt;::iterator j=(it+1);j&lt;nums.end();j++)&#123; if(*j==*it)&#123; nums.erase(j); j--; &#125; &#125; &#125; return nums.size(); &#125;&#125;; 因为是有序的，所以只需要从头到尾连续的两个进行比较，至少剩一个 1234567891011121314//540msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end()-1;it++)&#123; vector&lt;int&gt;::iterator j=(it+1); if(*j==*it)&#123; nums.erase(j);it--; &#125; &#125; return nums.size(); &#125;&#125;; it–&#x3D;&#x3D;???&#x3D;&#x3D; 双指针 将有序的排在前面， p前q后 q外层遍历 q找到和q不一样的复制到p的下一位 12345678910111213141516171819//12msclass Solution&#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int p = 0; int q = 1; while(q &lt; nums.size())&#123; if(nums[p] != nums[q])&#123; if(q - p &gt; 1)&#123; nums[p + 1] = nums[q]; &#125; p++; &#125; q++; &#125; return p + 1; &#125;&#125;; 80 删除有序数组中的重复项Ⅱ1234567891011121314151617//8msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); vector&lt;int&gt;::iterator j; while(it&lt;nums.end()-2)&#123; j=it+1; if(*j==*it&amp;&amp;*(j+1)==*it)&#123; nums.erase(j); &#125;else&#123; it++; //不相等才it++ 防止大于三个相同的漏掉 &#125; &#125; return nums.size(); &#125;&#125;; 双指针 slow表示处理出的数组长度 fast表示已经检查过的长度 12345678910111213141516171819//0msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 2) &#123; return n; &#125; int slow = 2, fast = 2; //从2开始，前面2个都是不用动的 while (fast &lt; n) &#123; if (nums[slow - 2] != nums[fast]) &#123; //不相等可以保存 nums[slow] = nums[fast]; //保存 ++slow; //保存数目+1 &#125; ++fast; //检查数目+1 &#125; return slow; &#125;&#125;; 删除重复项的通解&#x3D;&#x3D;？？？&#x3D;&#x3D; 1234567891011121314//4msclass Solution &#123;public: int work(vector&lt;int&gt;&amp; nums, int k) &#123; int len = 0; for(auto num : nums) if(len &lt; k || nums[len-k] != num) nums[len++] = num; return len; &#125; int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; return work(nums, 2); &#125;&#125;; 169 多数元素给定大小为n的数组，返回多数元素（个数大于n&#x2F;2） 利用两个循环 时间复杂度O² 会超时 1234567891011121314151617class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int max=0; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i;j&lt;nums.size();j++)&#123; if(nums[j]==nums[i]) max++; if(max&gt;nums.size()/2)&#123; return nums[i]; &#125; &#125; max=0; &#125; return 0; &#125;&#125;; 哈希表 我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。&#x3D;&#x3D;？？？&#x3D;&#x3D; 12345678910111213141516//24ms n n class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; counts; //创建哈希表统计元素出现的次数 int majority = 0, cnt = 0; //当前的众数 和次数 for (int num: nums) &#123; ++counts[num]; //增加counts中nun对于的值 if (counts[num] &gt; cnt) &#123; //nun对于的值出现的次数&gt;当前众数 更新 majority = num; cnt = counts[num]; &#125; &#125; return majority; &#125;&#125;; 排序 从小到大排序 下标n&#x2F;2处一定为次数多的 12345678//20ms nlogn logn 自己编写堆排序O1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return nums[nums.size() / 2]; &#125;&#125;; 随机化 12345678910111213141516//8ms 期望n 1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; while (true) &#123; int candidate = nums[rand() % nums.size()]; int count = 0; for (int num : nums) if (num == candidate) ++count; if (count &gt; nums.size() / 2) return candidate; &#125; return -1; &#125;&#125;; 分治 思路 如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。 我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l &#x2F; 2 + r &#x2F; 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 l &#x2F; 2 + r &#x2F; 2 &lt;&#x3D; (l + r) &#x2F; 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。 这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。 算法 我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。 1234567891011121314151617181920212223242526// 40ms nlogn lognclass Solution &#123; int count_in_range(vector&lt;int&gt;&amp; nums, int target, int lo, int hi) &#123; int count = 0; for (int i = lo; i &lt;= hi; ++i) if (nums[i] == target) ++count; return count; &#125; int majority_element_rec(vector&lt;int&gt;&amp; nums, int lo, int hi) &#123; if (lo == hi) return nums[lo]; int mid = (lo + hi) / 2; int left_majority = majority_element_rec(nums, lo, mid); int right_majority = majority_element_rec(nums, mid + 1, hi); if (count_in_range(nums, left_majority, lo, hi) &gt; (hi - lo + 1) / 2) return left_majority; if (count_in_range(nums, right_majority, lo, hi) &gt; (hi - lo + 1) / 2) return right_majority; return -1; &#125;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majority_element_rec(nums, 0, nums.size() - 1); &#125;&#125;; boyer-moore 投票算法 我们维护一个候选众数 candidate 和它出现的次数 count。count 为 0； 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x： 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；如果 x 与 candidate 不等，那么计数器 count 的值减少 1。 在遍历完成后，candidate 即为整个数组的众数。 123456789101112//16 n 1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int x = 0, votes = 0; for (int num : nums)&#123; if (votes == 0) x = num; votes += num == x ? 1 : -1; //如果num=x +1 else -1 &#125; return x; &#125;&#125;; 189 轮转数组给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 使用另一个数组辅助 12345678910111213//28msclass Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int a=nums.size(); vector&lt;int&gt; nums2(a); for(int i=0;i&lt;a;i++)&#123; int j=(i+k)%a; nums2[j]=nums[i]; &#125; nums=nums2; &#125;&#125;; 环状替换 一个临时变量x x保存0+k位 0+k位&#x3D;0位 0位&#x3D;x x保存(0+2k)%n位 (0+2k)%n位&#x3D;0位 一直循环，回到0位，但不能保证全部都轮了，要有一个计数器计数没有完下一轮从1位开始 &#x3D;&#x3D;？？？&#x3D;&#x3D; 123456789101112131415161718//40msclass Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); k = k % n; int count = gcd(k, n); //最大公约数 for (int start = 0; start &lt; count; ++start) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % n; swap(nums[next], prev); current = next; &#125; while (start != current); &#125; &#125;&#125;; 数组翻转 我们可以先将所有元素翻转，这样尾部的 k%n个元素就被移至数组头部，然后我们再翻转 [0,k%n−1] 区间的元素和 [k%n,n−1] 区间的元素即能得到最后的答案。 123456789101112131415161718//28msclass Solution &#123;public: void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123; while (start &lt; end) &#123; swap(nums[start], nums[end]); start += 1; end -= 1; &#125; &#125; void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k %= nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1); &#125;&#125;; 121 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 要在一条线上找跨度最大的，直接用后面数字-前面的看谁最大n^2 直接超时 123456789101112131415161718class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int temp=0; int n=prices.size(); for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(prices[i]-prices[j]&lt;temp) temp=prices[i]-prices[j]; &#125; &#125; if(temp&lt;0)&#123; return -1*temp; &#125;else&#123; return 0; &#125; &#125;&#125;; n 动态规划 123456789101112131415161718192021//96msclass Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if (n &lt;= 1) return 0; int maxProfit = 0; int minPrice = prices[0]; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &lt; minPrice) minPrice = prices[i]; else if (prices[i] - minPrice &gt; maxProfit) maxProfit = prices[i] - minPrice; &#125; return maxProfit; &#125;&#125;; for(i:)中i是一个什么对象？ ###122 买股票的最佳时机Ⅱ 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 相当于就是求所有能的利润 1234567891011121314151617180msclass Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sum=0; int n=prices.size(); int a=prices[0]; for(int i=1;i&lt;n;i++)&#123; if(prices[i]&gt;a)&#123; sum+=prices[i]-a; a=prices[i]; &#125;else&#123; a=prices[i]; &#125; &#125; return sum; &#125;&#125;; ###55 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 123456789101112//60msclass Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int k = 0; //到达的最大下标 for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) return false; //到不到这个i k = max(k, i + nums[i]);//i + nums[i]在下标i基础上跳多少 &#125; return true; &#125;&#125;; ###45 跳跃游戏Ⅱ 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 下标0的位置，如果能跳到下标1，2，这是我们并不清楚我们应该跳到哪一个，而应该进行一次选择，如果下标1能跳3格，也就是能到达1+3&#x3D;4的位置，下标2只能跳一格，只能到达2+1&#x3D;3的位置，这是我们就应该选择首先跳到下标1，并且记录步数的变量+1 代码表示 12345678int j = start + nums[start];for (int i = start + 1; i &lt;= j &amp;&amp; i &lt;= end; i++) &#123; if ((nums[i] + i) &gt; Dmax) &#123; Dmax = nums[i] + i; //最远距离 start = i; //起跳点更新 &#125;&#125; count++; 算法写好了，那么我们的程序应该是：把算法放进while循环中，结束条件是其距离能到达最后一位 12345678910111213141516171819//12msint jump(vector&lt;int&gt;&amp; nums) &#123; int end = nums.size() - 1; if (end == 0) return 0; int count = 0; int Dmax = nums[0]; int start = 0; while (Dmax &lt; end) &#123; int j = start + nums[start]; for (int i = start + 1; i &lt;= j &amp;&amp; i &lt;= end; i++) &#123; if ((nums[i] + i) &gt; Dmax) &#123; Dmax = nums[i] + i; start = i; &#125; &#125; count++; &#125; return count+1;&#125; ###274 H 指数 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。 示例 1： 1234输入：citations = [3,0,6,1,5]输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 示例 2： 12输入：citations = [1,3,1]输出：1 从大到小遍历，H指数从大到小判断，内层遍历如果不满足指数的数目过多则H–重新判断 1234567891011121314151617//32msclass Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; for(int i=citations.size()-1;i&gt;=0;i--)&#123; int count=citations.size(); for(int j=0;j&lt;citations.size();j++)&#123; if(citations[j]&lt;i+1) count--; if(count&lt;=i) break; &#125; if(count&gt;=i+1)&#123; return i+1; &#125; &#125; return 0; &#125;&#125;; 官方：先排序 h和i向中间靠拢，一次循环意味着一篇文章h++次，最后至少h篇h次 123456789101112class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; sort(citations.begin(), citations.end()); int h = 0, i = citations.size() - 1; while (i &gt;= 0 &amp;&amp; citations[i] &gt; h) &#123; h++; i--; &#125; return h; &#125;&#125;; 二分&#x3D;&#x3D;？？？&#x3D;&#x3D; 首先，定义左右两个指针，分别指向数组的首尾，然后取中间值，并计算大于或等于中间值的元素个数。如果这个数大于或等于中间值，那么将左指针移动到中间值，反之，将右指针移动到中间值减1。这样，每次循环后，搜索区间就会减半，最终会找到H指数。 12345678910111213141516171819202122232425class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; int left=0,right=citations.size(); int mid=0,cnt=0; while(left&lt;right)&#123; // +1 防止死循环 mid=(left+right+1)&gt;&gt;1; cnt=0; for(int i=0;i&lt;citations.size();i++)&#123; if(citations[i]&gt;=mid)&#123; cnt++; &#125; &#125; if(cnt&gt;=mid)&#123; // 要找的答案在 [mid,right] 区间内 left=mid; &#125;else&#123; // 要找的答案在 [0,mid) 区间内 right=mid-1; &#125; &#125; return left; &#125;&#125;; ###238 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 **不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。 12345678910111213141516171819202122//超时class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; //二分 int left,right; vector&lt;int&gt; nums2(nums.size(),1);//全部赋为1，不用new空间 for(int mid=0;mid&lt;nums.size();mid++)&#123; left=0;right=nums.size()-1; while(left&lt;mid)&#123; nums2[mid]*=nums[left]; left++; &#125; while(right&gt;mid)&#123; nums2[mid]*=nums[right]; right--; &#125; &#125; return nums2;//要申请空间才能返回数组 &#125;&#125;;//改进:可以额外开辟一个数组,先记录左边每一位累乘的,再记录右边每一位累乘的s,这样就不会超时了 上三角下三角法 B[i]&#x3D;对应行乘积 返回B数组 先算下三角 ex:B[2]&#x3D;B[1]*A[1] for (int i &#x3D; 1; i &lt; len; i++) { ans[i] &#x3D; ans[i - 1] * nums[i - 1];} 再算上三角 ex: ans *&#x3D;(temp*nums) 12345678910111213141516171819//20msclass Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) return &#123;&#125;; vector&lt;int&gt; ans(len, 1); ans[0] = 1; int tmp = 1; for (int i = 1; i &lt; len; i++) &#123; ans[i] = ans[i - 1] * nums[i - 1]; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; tmp *= nums[i + 1]; ans[i] *= tmp; &#125; return ans; &#125;&#125;; 134 加油站在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 123456789101112131415161718192021222324252627//112msclass Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n=gas.size(); int m=cost.size(); vector&lt;int&gt;temp(n); auto it=temp.begin(); int min =0; int sum=0,index,l=0; for(int i=0,j=0;i&lt;n&amp;&amp;j&lt;m;i++,j++)&#123; (*it)=gas[i]-cost[j]; sum+=(*it); if(sum&lt;min)&#123; //min记录最小油量时刻（负油最多），它之后就是出发点 min=sum; index=i+1; &#125; ++it; &#125; if(sum&lt;0)&#123; return -1; &#125; if(min&gt;=0) return 0; //&gt;0是多解情况，从0开始走都可以 return index%n; &#125;&#125;; 12345678910111213141516171819202122//简化，但是耗时更多？class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n=gas.size(); int min =0; int sum=0,index; for(int i=0;i&lt;n;i++)&#123; sum+=gas[i]-cost[i]; if(sum&lt;min)&#123; // min=sum; index=i+1; &#125; &#125; if(sum&lt;0)&#123; return -1; &#125; if(min&gt;=0) return 0; return index%n; &#125;&#125;; 135 分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 123输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//840ms 每次两个遍历int candy(vector&lt;int&gt;&amp; ratings) &#123; int all = 0; auto it = ratings.begin(); int temp1 = 0,temp2=0; for (; it != ratings.end(); ++it) &#123; int b = 0,c=0; if (it + 1 != ratings.end() &amp;&amp; *(it) &gt; *(it + 1)) &#123;//注意，此时我们不知道后一位是否比后两位大 int count = 2; auto j = it+1; while (j+1!=ratings.end()&amp;&amp; (*j) &gt; *(j + 1)) &#123; j++; count++; &#125; temp1 = count; b = 1; &#125; if (it != ratings.begin() &amp;&amp; *(it) &gt; *(it - 1)) &#123; int count = 2; auto j = it-1; while (j != ratings.begin() &amp;&amp; (*j) &gt; *(j - 1)) &#123; j--; count++; &#125; temp2 = count; c = 1; &#125; if (b == 0&amp;&amp;c==0) &#123; all += 1; &#125; else if (b == 1&amp;&amp;c==1) &#123; if (temp1 &gt;= temp2) &#123; all += temp1; &#125; else &#123; all += temp2; &#125; &#125; else if(b==0)&#123; all += temp2; &#125; else &#123; all += temp1; &#125; &#125; return all;&#125; 1234567891011121314151617181920212223242526//优化版本16msclass Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); vector&lt;int&gt; candies(n, 1); // 初始化每个孩子至少有一个糖果 // 从左到右遍历，保证右边评分更高的孩子获得更多糖果 for (int i = 1; i &lt; n; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candies[i] = candies[i - 1] + 1; &#125; &#125; // 从右到左遍历，保证左边评分更高的孩子获得更多糖果，同时考虑两边都评分更高的情况 for (int i = n - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1]) &#123; candies[i] = max(candies[i], candies[i + 1] + 1); &#125; &#125; // 计算总糖果数量 int total = 0; for (int i = 0; i &lt; n; ++i) &#123; total += candies[i]; &#125; return total; &#125; &#125;; 12345678910111213141516171819202122232425//12ms ,不好想class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); int ret = 1; int inc = 1, dec = 0, pre = 1; for (int i = 1; i &lt; n; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; dec = 0;//出现大于，-序列归0 pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;//相等=1，前一个+1 ret += pre;//总糖 inc = pre;//递增序列 &#125; else &#123; dec++;//递减序列 if (dec == inc) &#123;//增序列=减序列时是特殊点 dec++; &#125; ret += dec; pre = 1; &#125; &#125; return ret; &#125;&#125;; 双指针核心思想：创建两个指针，一个指向头，一个指尾，根据条件遍历 15 三数之和给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 难点：去除重复 -1 0 1 和 0 1 -1 属于重复的 所以先排序再去除重复遍历 1234567891011121314151617181920212223242526272829303132333435363738//108msclass Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3) return ans; sort(nums.begin(), nums.end()); if(nums[0]&gt;0) return ans; int i = 0; while(i&lt;nums.size())&#123; int left = i+1, right = nums.size()-1; while(left&lt; right)&#123; int y = nums[i]; int x = nums[left]; int z = nums[right]; if(x + y &gt;0-z)//z偏大 right--; else if(x + y &lt;0-z) left++; else&#123; ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;); // 相同的left和right不应该再次出现，因此跳过 while(left&lt;right&amp;&amp;nums[left]==nums[left+1]) left++; while(left&lt;right&amp;&amp;nums[right] == nums[right-1]) right--; left++; right--; &#125; &#125; // 避免nums[i]作为第一个数重复出现 while(i+1&lt;nums.size()&amp;&amp;nums[i] == nums[i+1]) i++; i++; &#125; return ans; &#125;&#125;; ##滑动窗口 双指针的基础上，像一个窗口一样滑动遍历 209 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 从子数组长度遍历，从1开始，子数组长度越长时间越长 还有一种：遍历每一个元素，每个元素在其基础上从1开始 1234567891011121314151617181920212223//超时int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int count = 1; while (count &lt;= n) &#123; for (int i = 0; i &lt; n; i++) &#123; int temp = 0; int j = i; while (j&lt;n) &#123; if (j - i &lt;= count - 1) &#123; temp += nums[j]; &#125; else &#123; break; &#125; j++; &#125; if (temp &gt;= target) return count; &#125; count++; &#125; return 0;&#125; 滑动窗口法：定义两个指针，和一个临时变量用来保存最小的子数组长度 开始l和r两个指针指向开头，区间内和小于指定值则r右移，区间和大于指定值则保存长度且l左移，寻找后面是否有更短的数组 12345678910111213141516171819202122class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; int ans = INT_MAX; int start = 0, end = 0; int sum = 0; while (end &lt; n) &#123; sum += nums[end]; while (sum &gt;= s) &#123; ans = min(ans, end - start + 1); sum -= nums[start]; start++; &#125; end++; &#125; return ans == INT_MAX ? 0 : ans; &#125;&#125;; 123456789101112131415161718192021222324//12msclass Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int minLen = numeric_limits&lt;int&gt;::max();//更快！！！很多 int curSum = 0; int start = 0; for (int end = 0; end &lt; nums.size(); end++) &#123; //add current number curSum += nums[end]; // check if the current sum &gt;= s while (curSum &gt;= s) &#123; minLen = min(minLen, end - start + 1); curSum = curSum - nums[start]; start = start + 1; &#125; &#125; return minLen == numeric_limits&lt;int&gt;::max() ? 0 : minLen; &#125;&#125;; 矩阵###36 有效的数独 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 1234567891011121314151617181920212223242526272829303132333435363738394041424344//20msclass Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(isdigit(board[i][j]))&#123; for(int k=0;k&lt;9;k++)&#123; if(k!=j&amp;&amp;board[i][k]==board[i][j])&#123; return false; &#125; &#125; for(int k=0;k&lt;9;k++)&#123; if(k!=i&amp;&amp;board[k][j]==board[i][j])&#123; return false; &#125; &#125; int temp1=0; if(i&gt;5)&#123; temp1=6; &#125;else if(i&gt;2)&#123; temp1=3; &#125;else&#123; temp1=0; &#125; int temp2=0; if(j&gt;5)&#123; temp2=6; &#125;else if(j&gt;2)&#123; temp2=3; &#125;else&#123; temp2=0; &#125; for(int k=temp1;k&lt;temp1+3;k++)&#123; for(int l=temp2;l&lt;temp2+3;l++)&#123; if(k!=i&amp;&amp;l!=j&amp;&amp;board[k][l]==board[i][j]) return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 因为都是数字，用数组代替哈希表记录每个数字出现的次数，可以建立三个数组也可以用一个数组 12345678910111213141516171819//0msclass Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; // 二维数组 v，共有 27 行，每行有 128 个元素，初始值都为 0 int v[27][128] = &#123;0&#125;;//为啥128？？？？？？？ //前面9行用于存每一行出现的数字次数，中间9行存每一列，最后9行存小九宫格 for(int i = 0; i &lt; 9; ++i) &#123; for(int j = 0; j &lt; 9; ++j) &#123; if(isdigit(board[i][j]) &amp;&amp; (v[i][board[i][j]]++ || v[9+j][board[i][j]]++ || v[18+(i/3)+(j/3)*3][board[i][j]]++)) &#123; // 若出现重复数字-加到2退出，返回 false 除法是舍尾的，每行一个小九宫，竖着依次 return false; &#125; &#125; &#125; return true; &#125;&#125;; 哈希表使用unordered_map 205同构字符串1234567891011121314151617class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char, char&gt; s2t; unordered_map&lt;char, char&gt; t2s; int len = s.length(); for (int i = 0; i &lt; len; ++i) &#123; char x = s[i], y = t[i]; if ((s2t.count(x) &amp;&amp; s2t[x] != y) || (t2s.count(y) &amp;&amp; t2s[y] != x)) &#123; return false; &#125; s2t[x] = y; t2s[y] = x; &#125; return true; &#125;&#125;; 383 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 只需要统计每一个字符出现的次数，ransomNote里面的都要&lt;&#x3D;magazine 12345678910111213141516171819class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.size() &gt; magazine.size()) &#123; return false; &#125; vector&lt;int&gt; cnt(26); //用int cnt[26]=&#123;0&#125;;更快 for (auto &amp; c : magazine) &#123; //知道类型的情况下，char比auto快 cnt[c - &#x27;a&#x27;]++; //a 放到0的位置依次 &#125; for (auto &amp; c : ransomNote) &#123; cnt[c - &#x27;a&#x27;]--; if (cnt[c - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; ###128 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 排序-&gt;遍历,下一个是前一位+1继续,遍历的下一位是不是前一位+1 O(n) 哈希表 O(1) 栈stk 回溯-一种递归思路类似深度优先 17 电话号码的字母组合myidea：用二维数组存储映射关系，下标为数字 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; combinations;//存储所有字母组合 if (digits.empty()) &#123; return combinations; &#125; unordered_map&lt;char, string&gt; phoneMap&#123;//哈希表存储映射关系 &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125; &#125;; string combination;//临时字母组合 backtrack(combinations, phoneMap, digits, 0, combination); return combinations; &#125; void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) &#123; if (index == digits.length()) &#123; combinations.push_back(combination); &#125; else &#123; char digit = digits[index];//获取当前字数字 const string&amp; letters = phoneMap.at(digit);//当前数字对应的字母 for (const char&amp; letter: letters) &#123; combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination);//递归 combination.pop_back(); &#125; &#125; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123; string MAPPING[10] = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;public: vector&lt;string&gt; letterCombinations(string digits) &#123; int n = digits.length();//数字长度 if (n == 0) return &#123;&#125;; vector&lt;string&gt; ans; string path(n, 0); // 临时存储和字母组合 function&lt;void(int)&gt; dfs = [&amp;](int i) &#123; if (i == n) &#123; ans.emplace_back(path);//一般用于不创建临时对象，此处用push_back效果一样 return;//出口 &#125; for (char c : MAPPING[digits[i] - &#x27;0&#x27;]) &#123;//char-&gt;int,遍历该数字对应的每个字符 path[i] = c; // 直接覆盖 dfs(i + 1);//递归 &#125; &#125;; dfs(0);//调用函数，传入i=0 return ans; &#125;&#125;; function&lt;void(int)&gt; dfs = [&amp;](int i)：定义了一个名为 dfs 的函数对象，其参数类型为 int，返回类型为 void。它使用了 Lambda 表达式 &amp; 捕获了当前作用域内的所有变量，这样可以访问外部的变量。 总体来说，这段代码的作用是对输入的数字字符串 digits 进行深度优先搜索，生成所有可能的字母组合，并将结果存储在 ans 中。 77 组合比上一题多一步，就是解决重复的组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if(n==0) return&#123;&#125;; vector&lt;int&gt; nums(n); for(int i=0;i&lt;n;i++)&#123; nums[i]=i+1; &#125; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path(k); function&lt;void(int, int)&gt; dfs = [&amp;](int start, int i) &#123; if(i==k)&#123; ans.push_back(path); return ; &#125; for(int j = start; j &lt; nums.size(); j++)&#123; path[i] = nums[j]; dfs(j + 1, i + 1); &#125; &#125;; dfs(0, 0); return ans; &#125;&#125;; 46 全排列传统回溯会有重复情况,用一个数组来标记是否已经被标记，递归完后要回溯标记为false 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) return &#123;&#125;; vector&lt;int&gt; temp(n); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; used(n, false); // 记录数字是否被使用过 function&lt;void(int)&gt; dfs = [&amp;](int i) &#123; if (i == n) &#123; ans.push_back(temp); return; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (!used[j]) &#123; temp[i] = nums[j]; used[j] = true; dfs(i + 1); used[j] = false; // 回溯，恢复状态 &#125; &#125; &#125;; dfs(0); return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"14届蓝桥杯c/c++b组","slug":"source/刷题/蓝桥杯刷题","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/06/09/source/刷题/蓝桥杯刷题/","permalink":"http://example.com/2024/06/09/source/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98/","excerpt":"","text":"星迪的气场计算循环读入字符串，单字符串排列，遍历字符串，字符计算 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compareChars(const char&amp; a, const char&amp; b) &#123; return a &lt; b;&#125;int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; vector&lt;string&gt; a; for (int i = 0; i &lt; n; i++) &#123; string name; cin &gt;&gt; name; a.push_back(name); //字符串从小到大排序。遍历 sort(name.begin(), name.end(), compareChars); int count = 1; int all = 0; for (string::const_iterator it = name.begin(); it != name.end(); ++it) &#123; all += (*it - 96) * count; count++; &#125; cout &lt;&lt; all &lt;&lt; endl; &#125; return 0;&#125; 数字转换整数转字符串 string str&#x3D;to_string(n); 字符串长度：str.length(); 字符串转整数：int n&#x3D;stoi(str); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isIncreasing(int n) &#123; string str_n = to_string(n); // 将整数转换为字符串 // 比较字符串中每个字符代表的数值 for (size_t i = 0; i &lt; str_n.length() - 1; ++i) &#123; if (str_n[i] &gt;= str_n[i + 1]) &#123; return false; // 如果当前字符不小于下一个字符，则不是递增的 &#125; &#125; return true; // 所有字符都是递增的 &#125;bool exchange(int n) &#123; string str = to_string(n); int j = str.length(); if (j == 1) &#123; cout &lt;&lt;n&lt;&lt;endl; &#125;else if (j == 2) &#123; if (str[0] &lt; str[1]) &#123; cout &lt;&lt; n &lt;&lt; endl; return true; &#125; else &#123; int temp = str[0]; str[0] = str[1]; str[1] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125;else &#123; //从左到右遍历两遍，每次比较三个，最小的在第三位交换两次结束，最小的在第二位交换一次，再次遍历 //遇到232结构先不慌，继续找321结构，没有就回滚 for (int i = 0; i &lt; j-2; i++) &#123; if (str[i + 2] &lt; str[i] &amp;&amp; str[i + 2] &lt; str[i + 1]) &#123; int temp1 = str[i]; str[i] = str[i + 2]; str[i + 2] = str[i + 1]; str[i + 1] = temp1; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; else if (str[i + 1] &lt; str[i] &amp;&amp; str[i + 1] &lt; str[i + 2]) &#123; int temp = str[i]; if (str[i] &lt;= str[i + 2]) &#123; str[i] = str[i + 1]; str[i + 1] = temp; &#125; else &#123; str[i] = str[i + 1]; str[i + 1] = str[i + 2]; str[i + 2] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125; &#125; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125;&#125;int main()&#123; int number; cin &gt;&gt; number; if (isIncreasing(number)) &#123; //不交换 cout &lt;&lt; number&lt;&lt; endl; &#125; else &#123; exchange(number); &#125; return 0;&#125; 01串的熵计算对数： #include log2(a) 比较浮点数： fabs(res - 11625907.5798) &lt; 0.0001 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n = 23333333; for (int i = 1; i &lt; n; ++i) &#123; double a = i * 1.0 / n; // 0出现的占比 double b = (n - i) * 1.0 / n; // 1出现的占比 double res = 0; res -= a * log2(a) * i + b * log2(b) * (n - i); if (fabs(res - 11625907.5798) &lt; 0.0001) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 冶炼金属二维数组： vector&lt;vector&gt; num(n, vector(2)); 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;algorithm&gt;using namespace std;int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; num(n, vector&lt;int&gt;(2)); int a[2] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; int j; cin &gt;&gt; j; int k; cin &gt;&gt; k; num[i][0] = j; num[i][1] = k; int temp = j / k; if (temp &lt; a[1]) &#123; a[1] = temp; &#125; if (i == 0) &#123; a[1] = temp; &#125; &#125; int k = a[1]; int flag = 0; while (k != 0) &#123; k--; for (int i = 0; i &lt; n; i++) &#123; if (num[i][0] / k != num[i][0] / a[1]) &#123; a[0] = k + 1; flag = 1; break; &#125; &#125; if (flag == 1) &#123; break; &#125; &#125; cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; endl; return 0;&#125; 飞机降落一种很好的循环结构 int T;cin &gt;&gt; T; while (T--)&#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 创建飞机结构体变量struct plane&#123; int t, d, l;&#125;;bool vis[15]; // true表示飞机降落，false表示飞机未降落bool flag; // 标记是否全部安全降落vector&lt;plane&gt; p(15);// 深搜void dfs(int m, int cnt, int last) // last表示此前所有飞机降落所需的单位时间&#123; if (cnt == m) &#123; flag = true; return; &#125; for (int i = 0; i &lt; m; i++) &#123; if (!vis[i] &amp;&amp; p[i].t + p[i].d &gt;= last) // 只有来的时刻+盘旋时间 &gt; last 的飞机才可以安全降落 &#123; vis[i] = true; dfs(m, cnt + 1, max(last, p[i].t) + p[i].l); vis[i] = false; &#125; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l; flag = false; dfs(N, 0, 0); if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; 接龙问题读字符串：遇空格就会停 字符串转数字：int x &#x3D; s[0] - ‘0’, y &#x3D; s[s.size() - 1] - ‘0’; 动态规划DP：重叠子问题，最优子结构问题(递归) 目的：找最长的接龙数列 关系：从后往前看，第i个数的最长子序列数为以第i个数的首位为尾数的那个数的最长序列+1 用一个数组来dp[i]表示以i为尾数字的最长序列 x表示首位，y表示尾数 dp[y]&#x3D;max(dp[x]+1,dp[y]); n记录最大的子序列n&#x3D;max(dp[y],n); 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int dp[10];int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; string s; int m = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s; int x = s[0] - &#x27;0&#x27;, y = s[s.size() - 1] - &#x27;0&#x27;; dp[y] = max(dp[x] + 1, dp[y]); m = max(m, dp[y]); &#125; cout &lt;&lt; n - m &lt;&lt; endl; return 0;&#125; 岛屿个数vector&lt;vector&gt; data(m + 2, vector(n + 2, ‘0’)); 二维全部赋0 深度优先DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int deltaOfSea[8][2] = &#123;&#123;-1, -1&#125;,&#123;-1, 0&#125;,&#123;-1, 1&#125;,&#123;0, 1&#125;,&#123;1, 1&#125;,&#123;1, 0&#125;,&#123;1, -1&#125;,&#123;0, -1&#125;&#125;;//一格的八个方向int deltaOfIsland[4][2] = &#123;&#123;-1, 0&#125;,&#123;1, 0&#125;,&#123;0, -1&#125;,&#123;0, 1&#125;&#125;;//四个方向int ans = 0;void DFS_Island(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; for(int i = 0; i &lt; 4; ++i)&#123;//岛只看四个方向 int newR = r + deltaOfIsland[i][0]; int newC = c + deltaOfIsland[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123; if(data[newR][newC] == &#x27;1&#x27;) DFS_Island(data, newR, newC, m, n); &#125; &#125;&#125;void DFS_Sea(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; //r c记录当前访问的位置 N记作已经访问 for(int i = 0; i &lt; 8; ++i)&#123;//遍历当前位置的8个方向 int newR = r + deltaOfSea[i][0]; int newC = c + deltaOfSea[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123;//当前相邻单元格有效 if(data[newR][newC] == &#x27;1&#x27;)&#123; DFS_Island(data, newR, newC, m, n);//找岛屿 ++ans; &#125; else if(data[newR][newC] == &#x27;0&#x27;)&#123; DFS_Sea(data, newR, newC, m, n); &#125; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; vector&lt; vector&lt;vector&lt;char&gt;&gt; &gt; datas;//用三维存储每一个二维 for(int i = 0; i &lt; t; ++i)&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; data(m + 2, vector&lt;char&gt;(n + 2, &#x27;0&#x27;)); //扩展一圈0，防止遍历不完，可以 for(int r = 1; r &lt; m + 1; ++r)&#123; for(int c = 1; c &lt; n + 1; ++c)&#123; cin &gt;&gt; data[r][c]; &#125; &#125; datas.push_back(data); &#125; for(int i = 0; i &lt; t; ++i)&#123; vector&lt;vector&lt;char&gt;&gt; data = datas[i]; int m = data.size(); int n = data[0].size(); DFS_Sea(data, 0, 0, m, n); cout &lt;&lt; ans &lt;&lt; endl; ans = 0; &#125; return 0;&#125; 字串简写正常暴力只能解决70% 思路：正向统计a数目，遇到b则将之前统计的长度加到ans上 123456789101112131415#include &lt;bits/stdc++.h&gt; using namespace std;int K;long long ans=0,c1_sum=0;string S;char c1,c2;int main()&#123; cin&gt;&gt;K&gt;&gt;S&gt;&gt;c1&gt;&gt;c2; for(int i=K-1,j=0;i&lt;S.length();i++,j++)&#123; if(S[j]==c1) c1_sum++; if(S[i]==c2) ans+=c1_sum; &#125; cout&lt;&lt;ans; return 0;&#125; 整数删除#include 找最值，排序 12345678910111213141516171819202122232425262728293031323334353637//30%#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n,k; cin &gt;&gt; n&gt;&gt;k; vector&lt;int&gt; a; for (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; a.push_back(temp); &#125; for (int i = 0; i &lt; k; i++) &#123; auto minelement = min_element(a.begin(), a.end()); int min = *minelement; for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it) &#123; if (*it == min) &#123; vector&lt;int&gt;::iterator prev = it; vector&lt;int&gt;::iterator next = it; if (it != a.begin()) &#123; --prev; *prev += min; &#125; ++next; if (next != a.end()) &#123; *next += min; &#125; a.erase(it); break; &#125; &#125; &#125; for (int i:a) &#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; int n, k; std::cin &gt;&gt; n &gt;&gt; k; std::vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; k; ++i) &#123; auto minIt = std::min_element(a.begin(), a.end());// int minIndex = std::distance(a.begin(), minIt);//这两处每次需要遍历找很浪费 int min = *minIt; if (minIndex &gt; 0) &#123; a[minIndex - 1] += min; &#125; if (minIndex &lt; n - 1) &#123; a[minIndex + 1] += min; &#125; a.erase(a.begin() + minIndex);//费时间 &#125; for (int i : a) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 使用优先队列（最小堆）维护元素和索引，log时间内找最小值 更新后的元素和索引放入堆中，最小值被标记为INT_MAX 声明优先队列 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 队列中的元素类型为pair，选择vector容器，比较器greater，函数对象，按&gt;运算符，顶部(最小)有最大的权重，没有比较器默认顶部最小权重 插入数据 pq.push(&#123; a[i], i &#125;); 取数据 auto [min, minIndex] = pq.top(); 移除顶部元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;climits&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; vector&lt;int&gt; c(n); vector&lt;int&gt; d(n); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; pq.push(&#123; a[i], i &#125;); c[i] = i - 1; d[i] = i + 1; &#125; //创建两个数组实时更新每个数左右最近的下标，更新堆的时候就能快速定位到了 //一个数组用来记录当前数据修改的次数，出栈一次则修改次数-1 while (k-- &gt; 0 &amp;&amp; !pq.empty()) &#123; auto [min, minIndex] = pq.top(); cout &lt;&lt; min &lt;&lt; &#x27; &#x27; &lt;&lt; minIndex &lt;&lt; endl; pq.pop(); if (nums[minIndex]==0) &#123; //删除 int temp1 = c[minIndex]; int temp2 = d[minIndex]; if (temp1 != -1) &#123; a[temp1] += min; d[temp1] = temp2; pq.push(&#123; a[temp1], temp1 &#125;);//更新 nums[temp1]++;//修改次数+1 &#125; if (temp2 != n) &#123; a[temp2] += min; c[temp2] = temp1; pq.push(&#123; a[temp2], temp2 &#125;); nums[temp2]++; &#125; // 标记最小元素为已处理 a[minIndex] = INT_MAX; &#125; else if (nums[minIndex] != 0) &#123; //修改次数-1 k++; nums[minIndex]--; &#125; &#125; // 输出未被标记为已处理的元素 for (int i = 0; i &lt; n; ++i) &#123; if (a[i] != INT_MAX) &#123; cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 景区导游LCA：最近公共祖先 暴力：一层一层跳，lca：倍增 DFS：深度优先搜索root-&gt;a BFS:广度优先 a-b的距离&#x3D;root-&gt;a+root-&gt;b-2*root-&gt;lca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int N = 1e5 + 100;//10^5+100int n, k;int deep[N]; // 深度int dp[N][21]; // dp[i][j]表示从i结点开始跳2^j步可到达的结点vector&lt;int&gt; edge[N]; // 边vector&lt;int&gt; weight[N]; // 权值ll path[N]; // 原始的游览路线ll dist[N]; // dist[i]存储i到根结点的距离void dfs(int u, int father) // LCA的前置算法(模板) 层数 父亲节点&#123; deep[u] = deep[father] + 1; dp[u][0] = father; for (int i = 1; i &lt;= 20; i++) &#123; dp[u][i] = dp[dp[u][i - 1]][i - 1]; &#125; for (size_t i = 0; i &lt; edge[u].size(); i++) &#123; int v = edge[u][i], w = weight[u][i]; if (v == father) continue; dist[v] = dist[u] + w; dfs(v, u); //下一层递归 &#125;&#125;int LCA(int x, int y) // 求x和y的最近公共祖先(模板)&#123; if (deep[x] &lt; deep[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) &#123; if (deep[dp[x][i]] &gt;= deep[y]) &#123; x = dp[x][i]; &#125; &#125; if (x == y) return x; for (int i = 20; i &gt;= 0; i--) &#123; if (dp[x][i] != dp[y][i]) &#123; x = dp[x][i]; y = dp[y][i]; &#125; &#125; return dp[x][0];&#125;ll get_dist(int x, int y) // 求x和y的距离&#123; if (x == 0 || y == 0) return 0; return dist[x] + dist[y] - 2 * dist[LCA(x, y)];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt; n; i++) // 插入n-1条无向边 &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[u].push_back(v); edge[v].push_back(u); weight[u].push_back(w); weight[v].push_back(w); &#125; dfs(1, 0); // 跑一遍dfs为LCA做准备 ll sum = 0; // sum存储原始游览路线的总路径长度 for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; path[i]; if (i &gt; 1) // 从第二个景点开始计算 &#123; sum += get_dist(path[i], path[i - 1]); // 依次累加 &#125; &#125; for (int i = 1; i &lt;= k; i++) // 除去第i个景点 &#123; ll dist1 = get_dist(path[i], path[i - 1]); ll dist2 = get_dist(path[i], path[i + 1]); ll dist3 = get_dist(path[i - 1], path[i + 1]); cout &lt;&lt; sum - dist1 - dist2 + dist3 &lt;&lt; &quot; &quot;; // 套公式计算即可 &#125; cout &lt;&lt; endl; return 0;&#125; 基础算法：枚举 贪心 模拟二分 排序：桶排序 归并排序 快速排序 搜索：DFS BFS 剪枝 动态规划：一维dp 背包dp 树形dp 状压dp 数位dp","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"HTML+CSS","slug":"source/前端/Web HTML5 CSS3","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.388Z","comments":true,"path":"2024/06/09/source/前端/Web HTML5 CSS3/","permalink":"http://example.com/2024/06/09/source/%E5%89%8D%E7%AB%AF/Web%20HTML5%20CSS3/","excerpt":"","text":"vscode 安装插件 open in browser #HTML ##标签 标签 123&lt;strong&gt;内容&lt;/strong&gt;&lt;br&gt; &lt;!-- 换行 --&gt; 注释：ctrl+/&lt;hr&gt; &lt;!-- 水平线 --&gt; 右键open in browser或者alt+b ###html骨架 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体 &lt;/body&gt;&lt;/html&gt; 在vscode中 !+enter&#x2F;tab自动生成骨架 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标签的关系：父子集，平行 ###标题 h1~h6 双标签 h1只用一次 ###段落 p 双 段落之间有空隙 ###文本格式化 ###图像标签 图片的大小一般用css控制 路径 相对：从当前文件夹出发 . .. 绝对：win：从盘 ios：从根出发 C:&#x2F; 可以用在线网站的图片网址 ###超链接 12&lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;text&lt;/a&gt; 新窗口打开 ###音频标签 后三个属性都可以简写 引号里面的内容和名字一样 ###视频标签 ###列表-排列整齐 无序ul嵌套li 有序ol嵌套li 定义列表dl嵌套dt标题 dd ###表格 包裹住tr即可，但是视觉上没变化 合并单元格 ###表单-收集用户信息 input 占位文本-提示 placeholder&#x3D;”” 其他属性 file multitiple可以多选上传 checkbox checked 下拉菜单 ###文本域 多行输入 textarea 双 ###label标签 双 绑定文字和表单控件的关系，增大表单控件的点击范围 按钮button ###无语义布局标签 div 独占一行 大盒子(可以换行展示内容) span 不换行 小盒子(不换行展示) 字符实体 多个键盘空格网页上只有一个 CSS层叠样式表 引入方式内部 css写在style标签里面 外部 单独放 .css html使用link标签引入 行内 配合Javascript使用 123&lt;div style=&quot;color: blueviolet;font-size: 30px;&quot;&gt; test2 &lt;/div&gt;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"微信公众号开发","slug":"source/前端/微信公众号开发","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.388Z","comments":true,"path":"2024/06/09/source/前端/微信公众号开发/","permalink":"http://example.com/2024/06/09/source/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/","excerpt":"","text":"一开始比较好奇如何实现公众号上点击按钮返回查询当地的天气这个功能，加上想要知道如何调用api接口进行开发，还有对网页的一些疑问？ 我注册了一个公众号，网址应该是这个：https://mp.weixin.qq.com 设置与开发-公众号设置-功能设置中有一个JS接口安全域名设置 只要我绑定这个应该就可以进行开发了 但是我没有域名？ 域名通过ICP备案？ 现在我留有两个问题 我搜到的资料： 点击发送天气预报的js代码：https://cloud.tencent.com/developer/article/1676360 阿里云ICP备案网址(免费)：https://beian.aliyun.com/?spm=5176.27043851.J_5642934430.8.27b175baCO8rQF 遇事不决还是看看官方文档 设置与开发-开发者工具-开发者文档 https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Getting_Started_Guide.html 基本配置 购买云服务器 √ 搭建服务 python官网下载压缩包https://www.python.org/downloads/source/ 选择第二个xz版本，下载后传到&#x2F;home&#x2F;myhome 下载python python –version没有,但是whereis python显示python3.6说明我已经有了，我需要使用python3指令 python3 –version √ pip3 install web-py √ yum install libxml2 libxslt √ 这个原本就有了的 pip3 install lxml √ vim main.py # -*- coding: utf-8 -*- # filename: main.py import web urls = ( &#39;/wx&#39;, &#39;Handle&#39;, ) class Handle(object): def GET(self): return &quot;hello, this is handle view&quot; if __name__ == &#39;__main__&#39;: app = web.application(urls, globals()) app.run() 12345678910111213141516171819202122232425262728* python3 main.py 80* 访问http://localhost/wx会出现hello, this is handle view3. 开发者基本配置* 修改配置* URL：http://47.115.215.143/wx* Token：123456xxx* 随机生成EncodingAESKey:livQRyv3bSWTW8qW3llMVPNsnhi50maBaPinbfOnJcu* 改动main.py* ~~~py # -*- coding: utf-8 -*- # filename: main.py import web from handle import Handle urls = ( &#x27;/wx&#x27;, &#x27;Handle&#x27;, ) if __name__ == &#x27;__main__&#x27;: app = web.application(urls, globals()) app.run() vim handle.py 这里微信平台提供的是错的，也是有点无语了 # -*- coding: utf-8 -*- # filename: handle.py import hashlib import web class Handle(object): def GET(self): try: data = web.input() if len(data) == 0: return &quot;hello, this is handle view&quot; signature = data.signature timestamp = data.timestamp nonce = data.nonce echostr = data.echostr token = &quot;123456xxx&quot; #请按照公众平台官网\\基本配置中信息填写 list = [token, timestamp, nonce] list.sort() tmp_str = &#39;&#39;.join(list) hashcode = hashlib.sha1(tmp_str.encode(&#39;utf-8&#39;)).hexdigest() #sha1 = hashlib.sha1() #map(sha1.update, list) #hashcode = sha1.hexdigest() print (&quot;handle/GET func: hashcode, signature: &quot;, hashcode, signature) if hashcode == signature: return int(echostr) else: return &quot;&quot; except Exception as Argument: return Argument 123456789101112131415161718192021222324252627282930* python3 main.py 80* 提交* 启动[微信公众号 | 如何设置JS-API对接微信高级能力 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/149965575)关注自动回复消息：[koa2实现微信公众号关注自动回复消息-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1672853)[微信公众号网页授权域名和JS接口安全域名配置攻略_域名不匹配当前服务号的js安全域名-CSDN博客](https://blog.csdn.net/hadues/article/details/106639473)[微信公众号网页开发——授权登录，js安全域名，jssdk使用 - web_study - 博客园 (cnblogs.com)](https://www.cnblogs.com/web-wjg/p/11346656.html)# 实现你问我答粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）~~~xml&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1460537339&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;&lt;/Content&gt; &lt;MsgId&gt;6272960105994287618&lt;/MsgId&gt;&lt;/xml&gt; 公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下： 1234567&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1460541339&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;&lt;/xml&gt; 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串，如果能不需要回复 如果开发者不进行回复，微信后台没办法确认开发者已收到消息 三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。 vim handle.py 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-# # filename: handle.pyimport hashlibimport replyimport receiveimport webclass Handle(object): def POST(self): try: webData = web.data() print &quot;Handle Post webdata is &quot;, webData #后台打日志 recMsg = receive.parse_xml(webData) if isinstance(recMsg, receive.Msg) and recMsg.MsgType == &#x27;text&#x27;: toUser = recMsg.FromUserName fromUser = recMsg.ToUserName content = &quot;test&quot; replyMsg = reply.TextMsg(toUser, fromUser, content) return replyMsg.send() else: print &quot;暂且不处理&quot; return &quot;success&quot; except Exception, Argment: return Argment vim receive.py 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-## filename: receive.pyimport xml.etree.ElementTree as ETdef parse_xml(web_data): if len(web_data) == 0: return None xmlData = ET.fromstring(web_data) msg_type = xmlData.find(&#x27;MsgType&#x27;).text if msg_type == &#x27;text&#x27;: return TextMsg(xmlData) elif msg_type == &#x27;image&#x27;: return ImageMsg(xmlData)class Msg(object): def __init__(self, xmlData): self.ToUserName = xmlData.find(&#x27;ToUserName&#x27;).text self.FromUserName = xmlData.find(&#x27;FromUserName&#x27;).text self.CreateTime = xmlData.find(&#x27;CreateTime&#x27;).text self.MsgType = xmlData.find(&#x27;MsgType&#x27;).text self.MsgId = xmlData.find(&#x27;MsgId&#x27;).textclass TextMsg(Msg): def __init__(self, xmlData): Msg.__init__(self, xmlData) self.Content = xmlData.find(&#x27;Content&#x27;).text.encode(&quot;utf-8&quot;)class ImageMsg(Msg): def __init__(self, xmlData): Msg.__init__(self, xmlData) self.PicUrl = xmlData.find(&#x27;PicUrl&#x27;).text self.MediaId = xmlData.find(&#x27;MediaId&#x27;).text vim reply.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-## filename: reply.pyimport timeclass Msg(object): def __init__(self): pass def send(self): return &quot;success&quot;class TextMsg(Msg): def __init__(self, toUserName, fromUserName, content): self.__dict = dict() self.__dict[&#x27;ToUserName&#x27;] = toUserName self.__dict[&#x27;FromUserName&#x27;] = fromUserName self.__dict[&#x27;CreateTime&#x27;] = int(time.time()) self.__dict[&#x27;Content&#x27;] = content def send(self): XmlForm = &quot;&quot;&quot; &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[&#123;ToUserName&#125;]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[&#123;FromUserName&#125;]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;&#123;CreateTime&#125;&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[&#123;Content&#125;]]&gt;&lt;/Content&gt; &lt;/xml&gt; &quot;&quot;&quot; return XmlForm.format(**self.__dict)class ImageMsg(Msg): def __init__(self, toUserName, fromUserName, mediaId): self.__dict = dict() self.__dict[&#x27;ToUserName&#x27;] = toUserName self.__dict[&#x27;FromUserName&#x27;] = fromUserName self.__dict[&#x27;CreateTime&#x27;] = int(time.time()) self.__dict[&#x27;MediaId&#x27;] = mediaId def send(self): XmlForm = &quot;&quot;&quot; &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[&#123;ToUserName&#125;]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[&#123;FromUserName&#125;]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;&#123;CreateTime&#125;&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt; &lt;Image&gt; &lt;MediaId&gt;&lt;![CDATA[&#123;MediaId&#125;]]&gt;&lt;/MediaId&gt; &lt;/Image&gt; &lt;/xml&gt; &quot;&quot;&quot; return XmlForm.format(**self.__dict) 设置JS接口安全域名","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"公众号开发","slug":"公众号开发","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"}]},{"title":"windows虚拟机","slug":"source/工具-环境/VMware win11","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/06/09/source/工具-环境/VMware win11/","permalink":"http://example.com/2024/06/09/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/VMware%20win11/","excerpt":"","text":"开始-搜索“启用或关闭windows功能”-勾选“windows虚拟机监控程序平台”和“虚拟机平台” 下载win11 ISODownload Windows 11 (microsoft.com)版本任意 下载wmware此处不展示新建虚拟机-兼容性workstation 16.x -典型-稍后安装操作系统-windows-版本 win11 x64-虚拟机名称&#x2F;位置-固件类型UEFI-只有支持tmp..加密-设置8位以上密码-记住密码-最大磁盘大小64gb-将虚拟机拆分成多个文件-自定义硬件-关闭-完成 我设置的密码：！niubiplus007 设置-选项-访问控制-加密 ​ -高级-固件类型-UEFI -硬件-添加-可信平台模块 -CD&#x2F;DVD-使用ISO映像文件-设备状态-已连接启动时连接 -内存-4GB(4096MB) 我没有产品密钥-win11专业版-自定义安装-不分区 登录账号直接输入错误的账号和密码，用名字登录 下方黄色提示栏或者右键安装vmware tools-win+r-D:\\setup.exe-典型安装 可以直接使用复制粘贴包括文件，拉伸比例 网络配置-一起配好了的这里是192.168.6.129 g++ server.cpp -lpthread -lws2_32 https://blog.csdn.net/qq_42417071/article/details/137438374","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"win+vmware","slug":"win-vmware","permalink":"http://example.com/tags/win-vmware/"}]},{"title":"c++面试","slug":"source/面试/C++面试准备","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-11T14:51:50.761Z","comments":true,"path":"2024/06/09/source/面试/C++面试准备/","permalink":"http://example.com/2024/06/09/source/%E9%9D%A2%E8%AF%95/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","excerpt":"","text":"STL顺序容器 std::vector： 动态数组，可以随机访问元素，支持高效的尾部插入和删除操作。 连续内存 std::deque： 双端队列，支持高效的头部和尾部插入和删除操作。 数组块+映射表 deque没有capacity(),返回当前可容纳元素数目 std::list： 双向链表，支持高效的插入和删除操作，但不支持随机访问。 std::forward_list： 单向链表，仅支持单向遍历，节省空间。 关联容器 std::map： 有序关联容器，存储键值对，键是唯一的，按照键的顺序排序(底层红黑树，默认升序)。 std::multimap： 有序关联容器，允许键重复，按照键的顺序排序。 std::set： 有序集合，存储唯一的元素，按照元素的顺序排序。 std::multiset： 有序集合，允许元素重复，按照元素的顺序排序。 无序容器 std::unordered_map： 无序关联容器，存储键值对，键是唯一的，基于哈希表实现。 std::unordered_multimap： 无序关联容器，允许键重复，基于哈希表实现。 std::unordered_set： 无序集合，存储唯一的元素，基于哈希表实现。 std::unordered_multiset： 无序集合，允许元素重复，基于哈希表实现。 容器适配器 std::stack： 栈适配器，通常基于 std::deque 实现，也可以基于 std::vector 或 std::list 实现。 std::queue： 队列适配器，通常基于 std::deque 实现。 std::priority_queue： 优先队列适配器，通常基于 std::vector 实现，用于维护一个堆结构。 特殊容器 std::array： 定长数组，大小在编译时确定。 std::bitset： 定长二进制数组，用于高效存储和操作二进制位。 选择合适的容器选择合适的容器取决于具体需求： 需要随机访问：std::vector 或 std::deque 需要高效的头尾部插入&#x2F;删除：std::deque 需要高效的任意位置插入&#x2F;删除：std::list 或 std::forward_list 需要键值对存储且按键排序：std::map 需要键值对存储且按哈希表存储：std::unordered_map 需要存储唯一元素且按顺序排序：std::set 需要存储唯一元素且按哈希表存储：std::unordered_set 需要LIFO结构：std::stack 需要FIFO结构：std::queue 需要优先级队列：std::priority_queue 其他容器与数据结构vector中push_back和emplace_back的区别？push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。但是，如果是传递对象，那么二者都是一样的 map和set的区别和底层实现，map取值的find、[]、at方法的区别map和set都是关联式容器，底层实现是红黑树，增删查改的时间复杂度都为O(logn)。map存储键值对，set只存键 取值方法区别 find：找键返回迭代器，若无，返回end()，安全[]：找键返回值，若不存在，会自动插入at：找键返回值，若不存在，会抛出std::out_of_range异常，安全。 ###什么是布隆过滤器？*** 他是一个数据结构（很长的二进制向量） ，可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点。他只能告诉我们一个元素绝对不在集合内或可能在集合内。布隆过滤器很难实现删除操作。 布隆过滤器主要是为了防止redis缓存击穿问题（前端要查询一个数据，但是redis没有这个数据，就会去数据库查询，数据库可能承受不了这么大的流量就挂掉了）。有了布隆过滤器，就能判断哪些数据不在数据库中，防止缓存击穿。 ###红黑树讲一下，怎么翻转？红黑树的特性： 节点是红色或黑色的根节点都是黑色的所有叶子节点（null、空节点）都是黑色的如果一个节点是红色，那么他的两个子结点必然是黑色从任意节点到叶子节点的黑色节点数相同翻转 左旋：以某个节点(A)为轴，将其右节点（B）上移至A的位置，将A作为B的左子结点。原B的左子节点变为A的右子结点右旋：以某个节点(A)为轴，将其左节点（B）上移至A的位置，将A作为B的右子节点。原B的右子节点变为A的左子节点 ###unordered_map中哈希冲突的解决方法 链地址法：键值添加到相应索引处的链表（unordered_map实现的方法） 优点：对哈希函数要求低，删除操作简单 缺点：元素过多会导致查询效率降低；由于链表使得数据访问不连续，对CPU缓存不友好 优化方法 使用平衡树代替链表自适应库容&#x2F;缩容：随着元素增加，哈希表动态调整其大小，比如rehash 开放地址法：试图找到冲突索引后的数组位置的一个空位 优点：无需额外的空间存储链表，空间利用率高；可以有效利用CPU缓存缺点：对哈希函数要求较高；删除操作相对复杂unordered_map使用的哈希函数是使用的std::hash作为哈希函数。 再哈希 新特性c++11####C++11的单例模式 线程安全：C++11的单例模式提供了线程安全的初始化和使用手段，确保在多线程环境下单例的正确性。主要是因为C++11引入了新的内存模型和原子操作。 c++11的特性使懒汉模式不用加锁 ####智能指针的运用场景？*** 资源共享：当多个对象需要共享相同的资源时，可以采用shared_ptr，例如观察者模式 管理独占资源：可以采用unique_ptr 实现RAII：使得程序员不用担心内存泄漏的问题 解决循环引用问题，：使用weak_ptr，引用不计数；主要是为了防止重复释放资源，weak_ptr不能直接访问指向的对象，std::shared_ptr a_shared &#x3D; b-&gt;a_ptr.lock();转换成shared_ptr后访问。 ####智能指针的循环引用问题？ 两个智能指针指向互相指向对方，导致双方不能正常析构，引起内存泄漏。可以使用weak_ptr，他不会增加引用计数。 shapre_ptr的创建、复制、销毁是线程安全的。但是，当存在共享对象的时候，还是需要加锁；总之，shared_ptr的部分操作是线程安全的。shapred_ptr的引用计数是通过原子操作来保证线程安全的。 c++20协程 比线程更小的 多进程，多线程####我在调用fork之前打开了一个文件，那我子进程和父进程对这个文件描述符进行写入是追加还是重写？ 二者共享相同的文件偏移量，所以不会相互覆盖，而是追加到彼此写入的内容中。但是为了避免意外，还是加锁更加安全。 ####讲讲协程，协程一定无锁吗？ 协程是更轻量级的线程，主要是他可以在用户态调度，这样说明协程的创建、销毁、调度可以由程序员自己控制，而非操作系统。 协程不能保证代码完全无锁。协程降低了多线程编程中一些潜在的并发隐患，但访问共享资源时，仍然需要加锁。 ###进程间通信IPC 管道pipe，半双工(单方向)，只能用于父子等具有亲缘关系的进程间使用 消息队列：全双工 msgget msgsnd msgrcv 共享内存：shmget shmat shmdt 信号量：信号量主要用于进程间的同步和互斥，它是一个计数器，用于控制对共享资源的访问 semget semop semctl 套接字 ###线程通信 共享变量：全局变量或类的成员变量，结合锁或信号量 消息队列 条件变量：满足条件通知 信号量：计数器，为0等待 线程安全：原子操作atomic，thread_local 如果有一个变量已经定义，然后再申请多进程和多线程，他们也会有这个变量吗进程：会有自己的内存空间，进行数据复制互不影响 线程：共享全局变量，局部变量有各自副本(线程指定函数运行) 进程调度算法先来先服务，最短作业优先，优先级调度算法，时间片轮转，多级反馈队列算法：设置多个不同优先级的就绪队列，每个队列采用不同的调度算法。新进程会首先进入最高优先级队列，按照时间片轮转算法执行。如果在一个时间片内没有执行完，会被降到下一级队列。各级队列之间采用优先级调度算法。 面向对象####重载、重写（覆盖）、隐藏 ？ 重载是函数名相同，但是参数或返回值不同，可以有不同地实现。 重写是多态的内容，是父类写了虚函数，子类有自己的实现。 隐藏是在子类中定义了父类完全相同的变量或函数，导致父类的同名元素被隐藏。 ####虚函数的底层实现，多继承（一个派生类继承多个基类）的虚指针的虚表的形式 虚函数的底层依赖虚指针(vptr)和虚函数表(vtable)。多继承是一个派生类继承多个基类，多继承中的虚指针和虚函数为如下： 虚指针（4&#x2F;8字节）：每个含有虚函数的类都会有一个虚指针，指向虚函数表虚函数表：虚函数表是一个函数指针数组，存放着虚函数的地址。每个继承自基类的派生类都有自己的虚函数表，虚函数表中的函数指针顺序与基类的函数声明顺序一致。（有多少个虚函数，就有多少个函数指针）虚析构函数：在删除指针的时候，会先调用派生类的析构函数，再调用基类的析构函数。如果基类的析构函数不是虚的，那么删除基类指针时只会调用基类的析构函数，从而导致资源未正确释放以及内存泄漏的问题。 如果一个类什么都没有，则sizeof()是1，如果有一个或多个虚函数，则sizeof()是8，因为虚指针8个字节。虚函数指针通常位于对象的开始位置。 另外，虚函数表存储在常量区的数据段（只读数据段）。它是一个静态数据结构，在编译式就确定了，后面不会修改。 ####除了多态和继承还有什么面向对象方法*** 封装：将对象属性和行为放到一个对象中，并限制对这些属性的访问，隐藏细节 抽象：通过创建外界接口，隐藏底层细节 组合：一个类包含另一个类，二者是同生死的关系 聚合：弱组合，可以单独存在（结构体） 动态绑定程序运行时才确定要调用的函数版本 每个包含虚函数的对象都会有一个指向虚函数表的指针 基类指针指向派生类对象，使用指针调用虚函数，会根据实际的派生类对象调用虚函数 ####抽象类与纯虚函数，作用，有函数体是否编译 抽象类不能被实例化，只能被继承。纯虚函数是没有函数体的虚函数，目的就是让派生类重写。当一个类有纯虚函数的时候，就是抽象类。 纯虚函数：virtual float getArea() = 0; ####override和final的作用 override用于指定派生类中一个函数是用来重写的，以确保子类函数和父类函数名才相同，表明了函数重写的意图 final作用于类的时候，表明该类不能被其他类继承，这样可以防止类的继承层次过深。同时，有final的函数，不能在派生类中重写。 细讲static，包括static成员变量与函数static成员变量被类的所有对象共享。 static成员函数是属于类的，在没有创建类的实例时也可直接只用。它们不能访问类的非静态成员，因为非静态成员需要类的实例。 需要注意的是，static成员变量和函数的作用域仅限于定义它们的类。要在类外部访问，需要加:: ####给定类，判断大小，包括空类，加入static，加入虚函数，考虑到内存对齐空类的大小为1static成员变量不影响类的大小，因为它们是类的所有实例共享的。静态成员变量在子类的实例之外单独分配内存虚函数：有虚函数的类会比没有虚函数的类多一个8字节的虚函数表指针内存对齐：根据不同平台和编译器，编译器可能会在类成员之间添加填充字节，以确保数据对齐。 如何让类只能在堆上创建，不能在栈上创建？12345678910111213141516class HeapOnly &#123;private: HeapOnly() &#123;&#125; // 私有构造函数 ~HeapOnly() &#123;&#125; // 私有析构函数public: // 使用静态成员函数在堆上创建对象的实例 static HeapOnly* Create() &#123; return new HeapOnly(); &#125; // 添加成员函数以释放对象占用的内存 void Destroy() &#123; delete this; &#125;&#125;; 其他 RPC：是一种允许程序调用另一个地址空间（通常在另一台共享网络的计算机上）的程序的技术，就像调用本地子程序一样 数据序列化：数据序列化是将数据结构或对象状态转换成可以存储或传输的格式的过程。通过序列化，复杂的数据结构可以被转换为字节流，从而便于存储到文件、数据库，或者通过网络传输。如json xml 反序列化则是将字节流恢复成原始数据结构或对象状态的过程。 网络传输用的大端-高字节存低地址 ###引用和指针 123456int x=10;int *p=&amp;x;int &amp;y=x;int z=*p;使用需要解引用int z=y; y是x的别名 ###静态变量在哪里初始化 程序开始时初始化，内存分配在编译期间完成，占用内存大小固定。 在内存的静态&#x2F;全局区，这部分用于存储全局变量和静态变量。 编译过程，那静态变量是在哪个阶段初始化的?预处理：宏替换、头文件包含等编译：转为汇编汇编：转为机器语言链接：将多个文件和需要的库文件链接成一个可执行程序全局静态变量的初始化值存储在可执行文件中，而函数内的局部静态变量在函数第一次调用时进行初始化。 为什么需要链接这个过程？ 整合源文件编译后的二进制文件成可执行文件，链接所需的动态库，方便动态库的替换。 左值和右值？左值 可以取地址 具有持久性 右值 将亡值 不能取地址 表示临时结果，字面值或不能被赋值的对象 ###左值引用和右值引用的意义？ 左值引用： 作为函数的参数传递避免拷贝 可以根据参数是左值引用还是常量左值引用进行函数重载 操作符重载 实现链式调用 Vector&amp; operator+&#x3D;(const Vector&amp; other) 右值引用：右值引用声明符 &amp;&amp; 移动语义：移动构造函数和移动赋值运算符配合std::move使用 MyString(MyString&amp;&amp; other) noexcept : data(other.data), length(other.length) MyString&amp; operator&#x3D;(MyString&amp;&amp; other) noexcept 完美转发：std::forward()：在函数模板中保持参数的类型和值类别（左值或右值）不变 声明出来的左值引用、右值引用都是左值###涉及atoi函数要考虑哪些问题？这是将字符串转换为整数（const char* -&gt; int），需要考虑： 空字符串处理空格处理数值范围符号，可能数字前面有正负号，以确定返回的整数应该是正数还是负数 找第一个非空字符，识别加减号或数字，返回int11a返回11 无影响a11返回0 new和malloc的区别？***new是C++的一个操作符，malloc是库函数new会调用构造函数，malloc只是分配内存关于返回值，new会返回对应类型的指针，malloc返回void* （void*需要显示转换才能解引用，可以用于通用函数参数）在回收内存的时候，new采用delete或delete[]，malloc采用free使用new的时候先调用malloc，再调用构造；delete时，先调用析构，再调用free define和const的区别？#define常常用于宏定义，在预编译阶段，但是没有类型检查导致难以发现的错误，并且没有作用域，能使用#undef取消定义 cosnt是常量，在编译阶段。有作用域和类型检查，便于调试。 ###内存泄漏的查找方法检查代码，查看是否有分配内存但是没有释放的情况内存分析工具，比如C++的Valgrind，Go内置的pprof功能使用RAII，比如C++的只能指针一般堆内存泄露就是申请了内存资源没有释放，栈内存泄漏比较少见，一般发生在栈溢出的情况，是由于递归过深导致的，或者用了过大的局部变量，需要检查代码。 Linux进程间通信 管道(pipe)、流管道(s_pipe)、有名管道(FIFO) 信号(signal) 消息队列 共享内存 信号量 套接字(socket) ###指针和引用的区别，引用初始化后是可变的吗 指针是一个变量的地址，引用是一个变量的别名，引用必须初始化，因为在之后无法改变引用所指的对象。 引用在本质上 是一个常量指针，即所指的对象不能发生改变，但可以改变指向对象的值。 ###sizeof引用和sizeof指针的区别，指针和引用占用内存空间吗？理解引用是啥意思吗 sizeof指针返回的是指针的大小，4个字节，sizeof引用返回的是指向对象的大小，比如一个float就是8字节。 ###内存什么时候回收？显式delete才会回收吗？什么时候对象生命周期到达？栈里面的对象会自动回收吗？常量会自动回收吗？C++是这样的，显示delete回收。对于栈中的对象，无需显示删除，当函数返回时，会自动回收。 全局常量在整个程序运行周期都在，局部常量与作用域有关。也不需要显示回收。 memcpy函数实现，memmove呢1234567891011121314151617181920212223242526272829//memcpyvoid *my_memcpy(void *dest, const void *src, size_t n) &#123; char *d = (char *)dest; const char *s = (const char *)src; for (size_t i = 0; i &lt; n; i++) &#123; d[i] = s[i]; &#125; return dest;&#125;//memmove能处理内存重叠void *my_memmove(void *dest, const void *src, size_t n) &#123; char *d = (char *)dest; const char *s = (const char *)src; if (d &lt; s) &#123; // 从前往后复制 for (size_t i = 0; i &lt; n; i++) &#123; d[i] = s[i]; &#125; &#125; else &#123; // 从后往前复制，处理内存重叠情况 for (size_t i = n; i &gt; 0; i--) &#123; d[i - 1] = s[i - 1]; &#125; &#125; return dest;&#125; 如果将一个模板类的.h文件和.cpp文件分开，别的文件调用该包，会出现什么错误？为什么普通的类就可以分开呢？模板类是在编译的时候生成的，如果将定义放在.cpp文件中会导致编译器在处理其他源文件的时候找不到完整的模板定义。对于模板类，编译器在编译时并不知道可能的所有类型参数，因此需要在使用模板时生成具体实例。所以，我们只有保留模板类的声明，并在同一个文件中添加实现。 模板类是在编译期间确定的，不是动态绑定的。 为什么普通的类就可以分开呢？ 生成程序的时候有编译到链接的机制，链接阶段会把这些文件连接起来，而模板类在编译时并不知道可能的所有类型参数，因此需要在使用模板时生成具体实例。在链接阶段，编译器会检查所有具体类型的模板实例是否生成了相应的代码，如果找不到实例，就会报链接错误。总结：链接的时候不知道具体类型，无法整合 .hpp文件声明和定义在一个文件 如：内联函数，模板类模板函数，小型库","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Qt面试","slug":"source/面试/Qt面试准备","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/06/09/source/面试/Qt面试准备/","permalink":"http://example.com/2024/06/09/source/%E9%9D%A2%E8%AF%95/Qt%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","excerpt":"","text":"核心机制元对象系统 (信号与槽 运行时类型信息 动态属性) ​ 直接或间接继承QObject可以使用 ​ 声明Q_OBJECT宏 ​ 元对象编译器moc 将代码转化给c++编译器 属性系统 信号与槽 Qt创建多线程的方式 QThread 最方便 可开启事件循环 可信号 123QThread *t=new QThread;server * worker=new server;worker-&gt;moveToThread(t); 新建一个类继承自Qthread 这样可以通过构造函数传递参数 12server *serverthread=new server(seed,myserver-&gt;nextPendingConnection());serverthread-&gt;start(); QtConcurrent::run() 在单独的线程中异步处理事务 更简洁方便 12345678QT += core gui concurrent QFuture&lt;void&gt; future = QtConcurrent::run([this]() &#123; //或调用一个函数 // Simulate a long-running task QThread::sleep(5); // Sleep for 5 seconds // Update the label text (this part runs in the main thread) QMetaObject::invokeMethod(this, &quot;updateLabel&quot;, Qt::QueuedConnection); &#125;); QThreadPool 和 QRunnable 适合多个对象和复杂情况 12345678910111213MyTask *task = new MyTask(label);QThreadPool::globalInstance()-&gt;start(task);class MyTask : public QRunnable &#123;public: MyTask(QLabel *label) : m_label(label) &#123;&#125; void run() override &#123; // Simulate a long-running task QThread::sleep(5); // Sleep for 5 seconds QMetaObject::invokeMethod(m_label, &quot;setText&quot;, Qt::QueuedConnection,Q_ARG(QString, &quot;Task Completed!&quot;)); &#125;private: QLabel *m_label;&#125;; 信号与槽类似观察者模式 对象间传递消息：回调函数 MFC就是使用这个 使用函数指针 不保证类型安全 12345678910void printWelcome(int len)&#123;printf(&quot;欢迎欢迎 -- %d/n&quot;, len);&#125;void printGoodbye(int len)&#123;printf(&quot;送客送客 -- %d/n&quot;, len);&#125;void callback(int times, void(*print)(int))&#123; int i; for (i = 0; i &lt; times; ++i) &#123; print(i); &#125; printf(&quot;/n我不知道你是迎客还是送客!/n/n&quot;);&#125; void main(void)&#123; callback(2, printWelcome); callback(2, printGoodbye);&#125; 对象树：自动有效管理继承自QObject的Qt对象 父对象被析构时子对象也析构 避免内存泄漏 1234567891011121314151617signalsemitslots 可以不用声明这个关键字，但是一般需要设置connect的第五个参数可以不用阻塞等待槽函数完成执行//两个原型：connect(pushButton, SIGNAL(clicked()), dialog, SLOT(close()));connect(pushButton, &amp;QPushButton::clicked, dialog, &amp;QDialog::close);//信号发送者指针，信号函数字符串/信号函数地址，槽//lambda表达式connect(anysocket, &amp;QTcpSocket::disconnected, this, [=]() &#123; &#125;);//同一个类中的匿名函数connect(this, &amp;A::sig_hello, []&#123; qDebug() &lt;&lt; &quot;hello world!&quot;;&#125;); 可通过ui界面绑定信号与槽 https://blog.csdn.net/ddllrrbb/article/details/88374350 QSignalMapper 绑定对象数据一并传递 第五个参数： 事件过滤器重写eventFilter方法 不会处理这个信号 给QApplication安装，实现全局 12345678910111213bool eventFilter(QObject *watched, QEvent *event) override &#123; if (event-&gt;type() == QEvent::MouseButtonPress) &#123; qDebug() &lt;&lt; &quot;Button clicked&quot;; // 处理事件，返回 true 表示事件已经被处理，不需要继续传播 return true; &#125; // 其他事件，继续传播 return QObject::eventFilter(watched, event); &#125;MyEventFilter *eventFilter = new MyEventFilter();// 在按钮上安装事件过滤器button-&gt;installEventFilter(eventFilter); 保证线程安全 互斥量（QMutex）QMutex m_Mutex; m_Mutex.lock(); m_Mutex.unlock(); 互斥锁（QMutexLocker）QMutexLocker mutexLocker(&amp;m_Mutex);从声明处开始（在构造函数中加锁），出了作用域自动解锁（在析构函数中解锁）。 等待条件（QWaitCondition）QWaitCondtion m_WaitCondition; m_WaitConditon.wait(&amp;m_muxtex, time);m_WaitCondition.wakeAll(); QReadWriteLock类》一个线程试图对一个加了读锁的互斥量进行上读锁，允许；》一个线程试图对一个加了读锁的互斥量进行上写锁，阻塞；》一个线程试图对一个加了写锁的互斥量进行上读锁，阻塞；、》一个线程试图对一个加了写锁的互斥量进行上写锁，阻塞。读写锁比较适用的情况是：需要多次对共享的数据进行读操作的阅读线程。QReadWriterLock 与QMutex相似，除了它对 “read”,”write”访问进行区别对待。它使得多个读者可以共时访问数据。使用QReadWriteLock而不是QMutex，可以使得多线程程序更具有并发性。 信号量QSemaphore但是还有些互斥量（资源）的数量并不止一个，比如一个电脑安装了2个打印机，我已经申请了一个，但是我不能霸占这两个，你来访问的时候如果发现还有空闲的仍然可以申请到的。于是这个互斥量可以分为两部分，已使用和未使用。 QReadLocker便利类和QWriteLocker便利类对QReadWriteLock进行加解锁 其他QT中的智能指针封装为QPointer类 文件流 文件流(QTextStream):操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。数据流(QDataStream):通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。 文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。 post请求 Qt如何发送一个HTTP post请求并接收消息？在pro文件添加network模块（使用qmake时）使用网络连接请求类(QNetworkRequest)，添加URL网址，并设置HTTP的头部行使用网络访问管理器类(QNetworkAccessManager)发送post请求，同时需要添加HTTP附属体内容，返回得到网络回复类(QNetworkReply)对象当网络回复对象收到返回的消息时会触发相应的信号，可以通过连接槽函数，在槽函数中获取返回的数据","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"校招一览","slug":"source/面试/校园招聘","date":"2024-06-08T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/06/09/source/面试/校园招聘/","permalink":"http://example.com/2024/06/09/source/%E9%9D%A2%E8%AF%95/%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98/","excerpt":"","text":"#腾讯 腾讯：Tencent 腾讯 只能投一个岗位 岗位投递 | 腾讯校招 (qq.com) 工作地：成都 实习生岗位投递 | 腾讯校招 (qq.com) 软件开发-后台开发方向 登录方式：微信 简历页：我的简历 | 腾讯校招 (qq.com) 应聘进度：应聘进度 | 腾讯校招 (qq.com) #小米 小米：校园招聘 (xiaomi.com) 实习生招聘：小米实习生招聘 (mioffice.cn) 在成都没有相关招聘 #阿里 阿里系列：阿里巴巴集团招聘官网 (alibaba.com) ​ 总公司阿里巴巴：阿里巴巴控股集团招聘官网 (alibaba.com) IT服务工程师：IT服务工程师 (alibaba.com) ​ 阿里云：阿里云校园招聘 (aliyun.com) 项目制实习生不用看 可以投两个岗位 研发工程师C&#x2F;C++ 毕业时间不满足无法投递 ​ 淘宝：淘天集团招聘官网 (taotian.com) 实习生：淘天集团校园招聘 (taotian.com) 没成都 ​ 饿了么：饿了么招聘官网 (ele.me) 没成都 ​ 高德：高德地图招聘官网 (amap.com) 没成都 ​ 阿里国际：阿里国际数字商业集团招聘官网 (alibaba.com) 没成都 ​ 菜鸟：【菜鸟招聘官网】菜鸟招聘_菜鸟校招_cainiao recruitment 没成都 ​ 阿里文娱：大文娱集团招聘官网 (alibaba-dme.com) 没成都 还有其他类别都没成都估计，看总网。 达摩院 银泰商业 ​ 网易网易校园招聘 (163.com) 实习生：职位 | 网易社会招聘 (163.com) HR 音乐人运营 IT运维 百度百度招聘 (baidu.com) 实习生-成都：百度校园招聘 (baidu.com) 可后续关注 智能客服研发组_JAVA工程实习生(J71934) 简历：百度校园招聘 (baidu.com) 字节字节跳动 (bytedance.com) 成都-实习-研发https://jobs.bytedance.com/campus/position?keywords=&amp;category=&amp;location=CT_22&amp;project=&amp;type=3&amp;job_hot_flag=&amp;current=1&amp;limit=10&amp;functionCategory=&amp;tag= 后端开发实习生-抖音 登录：191 应聘记录：https://jobs.bytedance.com/campus/position/application 滴滴滴滴招聘 (didiglobal.com) 成都-实习生滴滴 -实习生招聘 (mokahr.com) 后续关注 京东京东招聘-首页 (jd.com) 京东校招 (jd.com) 京东app扫码 投递进度：京东校招 (jd.com) 美团校园招聘 | 美团招聘 (meituan.com) 实习-成都职位列表 | 美团招聘 (meituan.com) 微信扫码+191 进度：个人中心 | 美团招聘 (meituan.com) oppoOPPO招聘 - 加入我们 join us 成都-OPPO招聘 - 加入我们 join us 知乎知乎校园招聘 - 智者四海（北京）技术有限公司 (mokahr.com)","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"oatpp-nginx","slug":"source/Linux/oatpp+nginx","date":"2024-03-26T16:00:00.000Z","updated":"2025-03-03T12:45:53.386Z","comments":true,"path":"2024/03/27/source/Linux/oatpp+nginx/","permalink":"http://example.com/2024/03/27/source/Linux/oatpp+nginx/","excerpt":"","text":"安装oatpp我先在oatpp的github的官方网站上找到windows的下载方式 官方网站：https://github.com/oatpp/oatpp 下载方式：https://oatpp.io/docs/installation/windows/ 而后我尝试进行下载，第一次我忽略了下方的cmake参数，下面我整理了完整指令，在想要安装oatpp的地方cmd输入指令 123456git clone https://github.com/oatpp/oatpp.gitcd oatppMD buildcd buildcmake -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=OFF ..#更多参数可选项根据需求，我觉得这两个是必须的cmake --build . --target INSTALL 此处建议直接跳转到链接方法 既然库安好了，我开始想通过VS新建CMake项目链接库进行，但是我一直尝试都没有成功，文档放在这个最后(直接忽略) 目录结构为外层lib-oatpp test[代码存放] CMakelists.txt lib-oatpp中还有cmakelists test中有src-include-cmakelists 而后我又想直接把oatpp的源码放进项目中但是一直提示无法打开文件&#x2F;或找不到文件 历尽千辛万苦我终于知道如何链接了 ##链接方法 找到之前下载的oatpp&#x2F;src的位置”D:\\oatpp\\src”填入 右键项目-属性-c&#x2F;c++-附加包含目录 找到D:\\oatpp\\build\\src\\Debug 填入下图，里面有四个库文件 填入四个库 oatpp-test.lib oatpp.lib wsock32.lib ws2_32.lib 然后完事 ##CMakelistst(忽略) 以后也许我会再次尝试 顶层cmake文件，执行全局配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cmake_minimum_required (VERSION 3.8)project (&quot;cmake-oatpp-nginx&quot;)set (CMAKE_CXX_STANDARD 17)set (CMAKE_CXX_STANDARD_REQUIRED ON) #严格遵循c++标准# 添加宏定义if (ZO_BT STREQUAL &quot;r&quot;) add_definitions(-DOATPP_DISABLE_ENV_OBJECT_COUNTERS) message (STATUS &quot;Build type release&quot;)endif()if (UNIX) add_definitions(-D_CRT_SECURE_NO_WARNINGS -D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS) add_definitions(-DCPP_JWT_USE_VENDORED_NLOHMANN_JSON) add_definitions(-DLINUX) add_definitions(-DCHECK_TOKEN) add_definitions(-DSTOP_PWD=&quot;01star&quot;) add_definitions(-DOATPP_SWAGGER_SERVICE_NAME=&quot;$&#123;PROJECT_NAME&#125; for linux&quot;) add_definitions(-DOATPP_SWAGGER_RES_PATH=&quot;res&quot;) add_definitions(-DBSONCXX_STATIC -DMONGOCXX_STATIC -DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF)else() add_definitions(-DOATPP_SWAGGER_SERVICE_NAME=&quot;$&#123;PROJECT_NAME&#125; for windows&quot;) add_definitions(-DOATPP_SWAGGER_RES_PATH=&quot;res&quot;)endif()# 在camke .. 的时候会输出提示目录路径message (STATUS &quot;Prefix dir is $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;) #安装message (STATUS &quot;Binary dir is $&#123;PROJECT_BINARY_DIR&#125;&quot;) #二进制message (STATUS &quot;Source dir is $&#123;PROJECT_SOURCE_DIR&#125;&quot;) #源代码message (STATUS &quot;Build type is $&#123;CMAKE_BUILD_TYPE&#125;&quot;) #构建类型message (STATUS &quot;Platform for x64 = $&#123;CMAKE_CL_64&#125;&quot;) #平台# 定义一个预编译标头宏MACRO(ADD_MSVC_PRECOMPILED_HEADER PrecompiledHeader PrecompiledSource SourcesVar) IF(MSVC) GET_FILENAME_COMPONENT(PrecompiledBasename $&#123;PrecompiledHeader&#125; NAME_WE) SET(PrecompiledBinary &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/$&#123;PrecompiledBasename&#125;.pch&quot;) SET(Sources $&#123;$&#123;SourcesVar&#125;&#125;) SET_SOURCE_FILES_PROPERTIES($&#123;PrecompiledSource&#125; PROPERTIES COMPILE_FLAGS &quot;/Yc\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /Fp\\&quot;$&#123;PrecompiledBinary&#125;\\&quot;&quot; OBJECT_OUTPUTS &quot;$&#123;PrecompiledBinary&#125;&quot;) SET_SOURCE_FILES_PROPERTIES($&#123;Sources&#125; PROPERTIES COMPILE_FLAGS &quot;/Yu\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /FI\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /Fp\\&quot;$&#123;PrecompiledBinary&#125;\\&quot;&quot; OBJECT_DEPENDS &quot;$&#123;PrecompiledBinary&#125;&quot;) LIST(APPEND $&#123;SourcesVar&#125; $&#123;PrecompiledSource&#125;) ENDIF(MSVC)ENDMACRO(ADD_MSVC_PRECOMPILED_HEADER)add_subdirectory (&quot;lib-oatpp&quot;)add_subdirectory (&quot;test&quot;) test目录下cmakelists 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465cmake_minimum_required (VERSION 3.8)set (appName test)include_directories (&quot;./&quot;)include_directories (&quot;../lib-oatpp/include&quot;)# 链接库路径，程序运行的时候也在这里找link_directories ($&#123;PROJECT_BINARY_DIR&#125;/lib-oatpp)#链接库的搜索路径if(UNIX) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64)# 如果是Windows环境elseif(WIN32) if (CMAKE_CL_64) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64/openssl) if(ZO_BT STREQUAL &quot;r&quot;) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64) else() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64/debug) endif() else() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib/openssl) if(ZO_BT STREQUAL &quot;r&quot;) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib) else() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib/debug) endif() endif()endif()# 获取要编译的源代码file (GLOB_RECURSE SC_FILES ./*.cpp) #通配符-当前目录以及子目录下所有的.cpp文件list (REMOVE_ITEM SC_FILES &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/./stdafx.cpp&quot;) #从列表SC_FILES中移除指定文件-预编译头文件# 设置预编译标头if(WIN32) ADD_MSVC_PRECOMPILED_HEADER(&quot;stdafx.h&quot; &quot;stdafx.cpp&quot; SC_FILES)endif()# 编译可执行文件add_executable ($&#123;appName&#125; $&#123;SC_FILES&#125;)# 链接库target_link_libraries ($&#123;appName&#125; &quot;lib-oatpp&quot;)# Window平台复制dll文件到可执行文件目录if(WIN32) file (GLOB_RECURSE dycopy $&#123;ZO_DY_DIR&#125;/*.dll) file (COPY $&#123;dycopy&#125; DESTINATION &quot;$&#123;PROJECT_BINARY_DIR&#125;/$&#123;appName&#125;&quot;)endif()# Window平台复制项目配置到可执行文件目录if(WIN32) file (GLOB conf &quot;conf/*&quot;) file (COPY $&#123;conf&#125; DESTINATION $&#123;PROJECT_BINARY_DIR&#125;/$&#123;appName&#125;/conf)endif()# 安装文件# public目录if(IS_ARCH_DEMO) install (DIRECTORY &quot;public&quot; DESTINATION $&#123;appName&#125;)endif()# 可执行文件install (TARGETS $&#123;appName&#125; RUNTIME DESTINATION $&#123;appName&#125;)# Window平台复制项目配置到可执行文件目录if(WIN32) install (DIRECTORY &quot;conf&quot; DESTINATION $&#123;appName&#125;)endif() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// main.cpp#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/web/server/HttpRouter.hpp&quot;#include &quot;oatpp/web/server/HttpRequestHandler.hpp&quot;#include &quot;oatpp/web/protocol/http/outgoing/ResponseFactory.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;class MyController : public oatpp::web::server::HttpRequestHandler &#123;public: /** * Handle incoming HTTP request */ std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; /*request*/) override &#123; // Return &quot;Hello, World!&quot; response return oatpp::web::protocol::http::outgoing::ResponseFactory::createResponse(Status::CODE_200, &quot;Hello, World!&quot;); &#125;&#125;;/** * Example ConnectionProvider component that listens on port 8080 */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, serverConnectionProvider)([] &#123; return oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;0.0.0.0&quot;, 8080, oatpp::network::Address::IP_4 &#125;);&#125;());/** * Example Router component */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, httpRouter)([] &#123; auto router = oatpp::web::server::HttpRouter::createShared(); router-&gt;route(&quot;GET&quot;, &quot;/api/hello&quot;, std::make_shared&lt;MyController&gt;()); return router;&#125;());/** * Example ConnectionHandler component that combines ConnectionProvider and Router */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, serverConnectionHandler)([] &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider); // get ConnectionProvider component OATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router); // get Router component auto connectionHandler = oatpp::web::server::HttpConnectionHandler::createShared(router); connectionHandler-&gt;setConnectionProvider(connectionProvider); return connectionHandler;&#125;());int main() &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider); OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, connectionHandler); oatpp::network::Server server(connectionProvider, connectionHandler); // Print info about server port OATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).toString()-&gt;c_str()); // Run server server.run(); return 0;&#125; 在这个示例中，我们创建了一个名为 MyController 的类，用于处理 HTTP 请求，并返回 “Hello, World!” 消息。然后，我们定义了一个 HTTP 路由，将 /api/hello 路径映射到 MyController 类。最后，我们创建了一个 HTTP 服务器，监听在 8080 端口上，并将路由和连接提供器与之关联。 编译并运行这个程序，它将启动一个 HTTP 服务器，监听在 8080 端口上。接下来，你需要配置 Nginx，将 /api/hello 请求代理到这个端口上。在 Nginx 的配置文件中，你可以添加类似以下的配置： 12345678nginxCopy codeserver &#123; listen 80; server_name your_server_domain.com; location /api/hello &#123; proxy_pass http://127.0.0.1:8080; &#125;&#125; 保存并重新加载 Nginx 配置，然后访问 http://your_server_domain.com/api/hello，你应该能够看到 “Hello, World!” 的响应。 Step by Step1234567891011121314151617181920212223242526272829303132333435#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;void run() &#123; /* Create Router for HTTP requests routing */ auto router = oatpp::web::server::HttpRouter::createShared();//Http请求的路由，url映射到端点处理程序，现在没有声明端点，返回404 /* Create HTTP connection handler with router *///http连接处理，每一个连接一个线程 auto connectionHandler = oatpp::web::server::HttpConnectionHandler::createShared(router); /* Create TCP connection provider *///tcp连接，绑定一个端口 auto connectionProvider = oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;localhost&quot;, 8000, oatpp::network::Address::IP_4 &#125;); /* Create server which takes provided TCP connections and passes them to HTTP connection handler */ oatpp::network::Server server(connectionProvider, connectionHandler);//server运行一个循环，获取tcp连接，传到连接处理 /* Print info about server port */ OATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).getData()); /* Run server */ server.run();&#125;int main() &#123; /* Init oatpp Environment */ oatpp::base::Environment::init(); /* Run App */ run(); /* Destroy oatpp Environment */ oatpp::base::Environment::destroy(); return 0;&#125; ###添加请求处理程序 当url &#x2F;hello请求做出处理 访问http:&#x2F;localhost:8000&#x2F;hello 返回hello world消息 12345678910class Handler : public oatpp::web::server::HttpRequestHandler &#123;public: std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; request) override &#123; return ResponseFactory::createResponse(Status::CODE_200, &quot;Hello World!&quot;); &#125;&#125;;void run()&#123; router-&gt;route(&quot;GET&quot;, &quot;/hello&quot;, std::make_shared&lt;Handler&gt;());&#125; 使用JSON对象进行响应为了序列化&#x2F;反序列化对象，oatpp 使用特殊的[数据传输对象(DTO)和ObjectMappers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;/* Begin DTO code-generation */#include OATPP_CODEGEN_BEGIN(DTO)/** * Message Data-Transfer-Object */class MessageDto : public oatpp::DTO &#123; DTO_INIT(MessageDto, DTO /* Extends */) DTO_FIELD(Int32, statusCode); // Status code field DTO_FIELD(String, message); // Message field&#125;;/* End DTO code-generation */#include OATPP_CODEGEN_END(DTO)class Handler : public oatpp::web::server::HttpRequestHandler &#123;private: std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt; m_objectMapper;public: /** * Constructor with object mapper. * @param objectMapper - object mapper used to serialize objects. */ Handler(const std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;&amp; objectMapper) : m_objectMapper(objectMapper) &#123;&#125; /** * Handle incoming request and return outgoing response. */ std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; request) override &#123; auto message = MessageDto::createShared(); message-&gt;statusCode = 1024; message-&gt;message = &quot;Hello DTO!&quot;; return ResponseFactory::createResponse(Status::CODE_200, message, m_objectMapper); &#125;&#125;;void run() &#123; /* Create json object mapper */ auto objectMapper = oatpp::parser::json::mapping::ObjectMapper::createShared(); /* Create Router for HTTP requests routing */ auto router = oatpp::web::server::HttpRouter::createShared(); /* Route GET - &quot;/hello&quot; requests to Handler */ router-&gt;route(&quot;GET&quot;, &quot;/hello&quot;, std::make_shared&lt;Handler&gt;(objectMapper /* json object mapper */ )); &#125; oatpp的结构DTO 数据传输对象 定义了数据的格式 controller 使用api controller 端点处理程序(处理路由请求) 使用dto中的类封装消息 AppComponent.hpp 定义必须的组件(HTTP连接，请求路由，TCP连接，ObjectMapper) App.cpp main 路由器(请求) 获取上述组件中的路由-获取controller中的处理程序-建立路由到处理程序的映射 ​ 获取HTTP连接-获取TCP连接-建立服务-从TCP连接提供者发送消息到http连接处理 代码DTOs.hpp 123456789101112131415161718192021222324252627282930313233#ifndef DTOs_hpp#define DTOs_hpp#include &quot;oatpp/core/data/mapping/type/Object.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;/* Begin DTO code-generation */#include OATPP_CODEGEN_BEGIN(DTO)/** * Message Data-Transfer-Object */class MessageDto : public oatpp::DTO &#123; DTO_INIT(MessageDto, DTO /* Extends */) DTO_FIELD(Int32, statusCode); // Status code field DTO_FIELD(String, message); // Message field&#125;;/* TODO - Add more DTOs here *//* End DTO code-generation */#include OATPP_CODEGEN_END(DTO)#endif /* DTOs_hpp */ MyController.hpp 123456789101112131415161718192021222324252627282930313233343536373839#ifndef MyController_hpp#define MyController_hpp#include &quot;dto/DTOs.hpp&quot;#include &quot;oatpp/web/server/api/ApiController.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;#include OATPP_CODEGEN_BEGIN(ApiController) ///&lt; Begin Codegen/** * Sample Api Controller. */class MyController : public oatpp::web::server::api::ApiController &#123;public: /** * Constructor with object mapper. * @param objectMapper - default object mapper used to serialize/deserialize DTOs. */ MyController(OATPP_COMPONENT(std::shared_ptr&lt;ObjectMapper&gt;, objectMapper)) : oatpp::web::server::api::ApiController(objectMapper) &#123;&#125;public: ENDPOINT(&quot;GET&quot;, &quot;/hello&quot;, root) &#123; auto dto = MessageDto::createShared(); dto-&gt;statusCode = 200; dto-&gt;message = &quot;Hello World!&quot;; return createDtoResponse(Status::CODE_200, dto); &#125; // TODO Insert Your endpoints here !!!&#125;;#include OATPP_CODEGEN_END(ApiController) ///&lt; End Codegen#endif /* MyController_hpp */ AppComponent.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef AppComponent_hpp#define AppComponent_hpp#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;/** * Class which creates and holds Application components and registers components in oatpp::base::Environment * Order of components initialization is from top to bottom */class AppComponent &#123;public: /** * Create ConnectionProvider component which listens on the port */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, serverConnectionProvider)([] &#123; return oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;localhost&quot;, 8000, oatpp::network::Address::IP_4 &#125;); &#125;()); /** * Create Router component */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, httpRouter)([] &#123; return oatpp::web::server::HttpRouter::createShared(); &#125;()); /** * Create ConnectionHandler component which uses Router component to route requests */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, serverConnectionHandler)([] &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router); // get Router component return oatpp::web::server::HttpConnectionHandler::createShared(router); &#125;()); /** * Create ObjectMapper component to serialize/deserialize DTOs in Contoller&#x27;s API */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;, apiObjectMapper)([] &#123; return oatpp::parser::json::mapping::ObjectMapper::createShared(); &#125;());&#125;;#endif /* AppComponent_hpp */ App.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;controller/MyController.hpp&quot;#include &quot;AppComponent.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;void run() &#123; /* Register Components in scope of run() method */ AppComponent components; /* Get router component */ OATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router); /* Create MyController and add all of its endpoints to router */ auto myController = std::make_shared&lt;MyController&gt;(); router-&gt;addController(myController); /* Get connection handler component */ OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, connectionHandler); /* Get connection provider component */ OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider); /* Create server which takes provided TCP connections and passes them to HTTP connection handler */ oatpp::network::Server server(connectionProvider, connectionHandler); /* Priny info about server port */ OATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).getData()); /* Run server */ server.run();&#125;int main(int argc, const char* argv[]) &#123; /* Init oatpp Environment */ oatpp::base::Environment::init(); /* Run App */ run(); /* Destroy oatpp Environment */ oatpp::base::Environment::destroy(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#ifndef MyController_hpp#define MyController_hpp#include &quot;dto/DTOs.hpp&quot;#include &quot;oatpp/web/server/api/ApiController.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;#include OATPP_CODEGEN_BEGIN(ApiController) ///&lt; Begin Codegen/** * Sample Api Controller. */class MyController : public oatpp::web::server::api::ApiController &#123;public: /** * Constructor with object mapper. * @param objectMapper - default object mapper used to serialize/deserialize DTOs. */ MyController(OATPP_COMPONENT(std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;, objectMapper)) : oatpp::web::server::api::ApiController(objectMapper) &#123;&#125;public: ENDPOINT(&quot;GET&quot;, &quot;/hello&quot;, roothello) &#123; auto dto = MessageDto::createShared(); dto-&gt;statusCode = 200; dto-&gt;message = &quot;Hello World!&quot;; return createDtoResponse(Status::CODE_200, dto); &#125; // TODO Insert Your endpoints here !!! ENDPOINT(&quot;GET&quot;, &quot;/&quot;, root) &#123; auto response = createResponse(Status::CODE_200, &quot;&lt;html&gt;&lt;body&gt;&lt;form action=\\&quot;/submit\\&quot; method=\\&quot;post\\&quot;&gt;&lt;input type=\\&quot;text\\&quot; name=\\&quot;input\\&quot; placeholder=\\&quot;Enter something\\&quot;&gt;&lt;button type=\\&quot;submit\\&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&quot;); response-&gt;putHeader(oatpp::web::protocol::http::Header::CONTENT_TYPE, &quot;text/html&quot;); return response; &#125; ENDPOINT(&quot;POST&quot;, &quot;/submit&quot;, submit, BODY_STRING(String, body)) &#123; OATPP_LOGI(&quot;MyController&quot;, &quot;Received input: %s&quot;, body-&gt;c_str()); auto response = createResponse(Status::CODE_200, &quot;Received input: &quot; + *body); response-&gt;putHeader(oatpp::web::protocol::http::Header::CONTENT_TYPE, &quot;text/plain&quot;); return response; &#125;&#125;;#include OATPP_CODEGEN_END(ApiController) ///&lt; End Codegen#endif /* MyController_hpp */","categories":[{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"HTTP 请求处理、路由、JSON 序列化","slug":"HTTP-请求处理、路由、JSON-序列化","permalink":"http://example.com/tags/HTTP-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E7%94%B1%E3%80%81JSON-%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Web开发框架","slug":"Web开发框架","permalink":"http://example.com/tags/Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"git","slug":"source/工具-环境/git","date":"2024-03-24T16:00:00.000Z","updated":"2025-03-11T14:51:50.712Z","comments":true,"path":"2024/03/25/source/工具-环境/git/","permalink":"http://example.com/2024/03/25/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/git/","excerpt":"","text":"集中版本控制 SVN 所有的版本数据都保存在服务器上，相当于在线修改 分布式版本控制 Git 下载windows https://git-scm.com/ 无脑下一步yum install git SSH生成SSH keyssh-keygen -t ed25519 -C “Gitee SSH Key” #三次回车，注释可改或者不要注释查看生成的公钥和私钥ls ~&#x2F;.ssh&#x2F; # id_ed25519 id_ed25519.pub读取公钥文件cat ~&#x2F;.ssh&#x2F;id_ed25519.pub复制公钥到所需账户中 Git使用新建仓库并关联远程仓库git init #在需要管理的项目的根目录git add .git commit -m ‘xxxx’git remote add origin xxx(仓库网址) # 关联远端仓库git push -u origin main # 第一次推送关联分支 或者git push -f origin master # 强制覆盖远端参股 父仓库版本更高切换到子仓库git fetch origin xxx # 拉取最新的父仓库git merge origin&#x2F;xxxx # 父仓库向子仓库合并git status # 查看是否有冲突，有冲突在项目中解决(带有&gt;&gt;&gt;)git add .git commit 其他指令git pull –prune # 从远程拉取并且删除本地多余的文件 git pull –prune git status git branch git checkout xxxx #切换分支 git commit -F …&#x2F;log.txt git config –global http.sslVerify false # 当拉取仓库遇到ssl问题","categories":[{"name":"工具-环境","slug":"工具-环境","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"vscode","slug":"source/工具-环境/vscode","date":"2024-03-24T16:00:00.000Z","updated":"2025-03-03T12:45:53.375Z","comments":true,"path":"2024/03/25/source/工具-环境/vscode/","permalink":"http://example.com/2024/03/25/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/vscode/","excerpt":"","text":"ssh远程连接错误报错： 无法建立连接，下载vscode服务器失败-请在远程安装curl 解决办法： 删除远程服务器家目录下的.vscode-server文件夹，linux的家目录路径是：&#x2F;home&#x2F;yourusername ctrl+shift+p 输入kill 输入密码后删除服务器中的服务文件 再次连接会重新下载解决问题 配置c语言环境下载下载MinGW https://sourceforge.net/projects/mingw-w64/ 安装到你找得到英文路径下 打开这个文件夹找到bin文件夹的位置 “D:\\MinGW\\bin” 配置环境变量 右键此电脑-属性-高级系统设置-环境变量-上方Path-编辑-新建-放入地址(不要””) 下载vscode VScode插件C&#x2F;C++ Chinese(可选)两个插件 工作区配置####建立工作区 先在喜欢的地方建一个文件夹，这个文件夹用来存放你的代码和工作区的地方 打开文件夹，在空白处右键通过vscode打开 文件-将工作区另存为-选择这个文件夹 配置.vscode文件可以不用下载老版本的c&#x2F;c++插件，只需要手动建立一下的一个文件夹和两个文件 手动输入文件名和后缀 下面我附上配置内容 我已经加上了注释，可以根据自己喜好配置 1234567891011121314151617181920212223242526272829303132333435//launch.json&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;gcc.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\a.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;D:\\\\MinGW\\\\bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //在外部控制台中打开-输出内容将不会出现在下方 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\MinGW\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot; &#125; ]&#125; 123456789101112131415161718192021222324252627282930//tasks.json&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;, &quot;command&quot;: &quot;D:\\\\MinGW\\\\bin\\\\gcc.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\a.exe&quot;, &quot;-fexec-charset=GBK&quot; //解决中文乱码 ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\MinGW\\\\bin&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;调试器生成的任务。&quot; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125; ####建立a.exe 在每一个有代码的同级目录下都要新建一个a.exe 每次运行代码都会覆盖写入可执行文件，避免出现一堆exe文件，我已经在上方两个文件中改动优化了 例如上方的目录结构，其中可以内涵很多文件夹，只需要每个文件夹都有一个a.exe 运行代码在代码的头文件中加上 #include&lt;stdlib.h&gt; main函数体末尾加上 system(“pause”); 运行-GDB-gcc 为了方便打开，我们找到vscode的安装目录，右键图标-发送到桌面 右键桌面的这个vscode图标-属性-在目标后面加上文件夹的位置 就可以双击打开了 或者直接双击我们之前保存的工作区也同样的效果","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"Nginx","slug":"source/工具-环境/Nginx","date":"2024-03-24T16:00:00.000Z","updated":"2025-03-11T14:51:50.712Z","comments":true,"path":"2024/03/25/source/工具-环境/Nginx/","permalink":"http://example.com/2024/03/25/source/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/Nginx/","excerpt":"","text":"安装Nginx12345678安装 yum install nginx启动 nginx关闭 nginx -s stop测试访问ip的80号端口 常用指令 123456789nginx # 启动Nginxnginx -c filename # 指定配置⽂件nginx -V # 查看Nginx的版本和编译参数等信息安装目录：--prefix=/usr/share/nginx 配置文件位置：--conf-path=/etc/nginx/nginx.confnginx -t # 检查配置⽂件是否正确，定位配置⽂件的位置nginx -s quit # 优雅停⽌Nginxnginx -s stop # 快速停⽌Nginxnginx -s reload # 重新加载配置⽂件nginx -s reopen # 重新打开⽇志⽂件 默认网页位置安装位置&#x2F;usr&#x2F;share&#x2F;nginx 中html文件夹里的index.html 配置文件worker进程的数量可以根据配置文件修改worker_processes 1 文件中修改数量nginx -t 检查配置文件是否正确修改之后需要重新加载 nginx -s reloadps -ef |grep nginx 可以看进程的数量 设置成和服务器内核数量相同比较合适设置成auto自动设置events 服务器与客户端之间的配置 worker_connections 1024代表同时接受多少个网络连接 IO模型等http 虚拟主机，反向代理，负载均衡都在这里配置其中server块是虚拟主机 最后一行include servers&#x2F; 把servers目录下所有文件都包含进来* 这样就可以把每个虚拟主机的配置放到一个单独的文件里面这一部分可以看pdf 反向代理和负载均衡反向代理代理的是服务端，正向代理：vpn代理客户端去访问服务端 反向：将请求转发到其他服务器 main.go 使用Golang生成一段web服务代码，在8000端口监听 go run main.go 在浏览器中访问这个ip的8000号端口就可以看到 再复制两份，监听8001 8002 ctrl+shift+’启动新终端 启动这两个，分别访问就可以看到 code &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 在server块上方添加反向代理配置 12345upstream backend&#123; server 47.115.215.143:8000; server 47.115.215.143:8001; server 47.115.215.143:8002;&#125; 在server中添加location配置 123location&#123; proxy_pass http://backend; #与上方反向代理一致&#125; nginx -s reload访问47.115.215.143&#x2F;app 默认轮询访问，可以设置权重也就是访问到的概率，修改配置 123456upstream backend&#123; ip_hash; #根据客户端的ip地址进行哈希，同一个客户端的请求会分配到同一个服务器 server 47.115.215.143:8000 weight=3; server 47.115.215.143:8001; server 47.115.215.143:8002;&#125; HTTPShttp 80 https 443 需要使用ssl证书(免费申请)-得到密钥文件+证书文件也可以申请自签生成两个文件.key .pemserver中添加以下内容nginx -s reloadhttps://47.115.215.143这种没有ca机构验证会有安全提示自动跳到https 虚拟主机一个server就是一个虚拟主机，可以在servers文件夹里新建一个文件，把配置文件复制进去也没有问题会自动根据访问的域名匹配server项部署一个Vue(渐进式JavaScript前端框架)…此处省略配置过程在servers目录下新建vue.confroot跟打包好的vue目录","categories":[{"name":"工具-环境","slug":"工具-环境","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}]},{"title":"蓝桥杯往届考试题","slug":"source/C++/蓝桥杯刷题","date":"2024-03-01T16:00:00.000Z","updated":"2025-03-11T14:51:50.710Z","comments":true,"path":"2024/03/02/source/C++/蓝桥杯刷题/","permalink":"http://example.com/2024/03/02/source/C++/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98/","excerpt":"","text":"星迪的气场计算循环读入字符串，单字符串排列，遍历字符串，字符计算 for (string::const_iterator it &#x3D; name.begin(); it !&#x3D; name.end(); ++it) bool compareChars(const char&amp; a, const char&amp; b) {return a &lt; b;} sort(name.begin(), name.end(), compareChars);从小到大排序 &#x2F;&#x2F; 先提供自定义比较函数bool caseSensitiveCompare(const string&amp; a, const string&amp; b) {return a &lt; b;} sort(strings.begin(), strings.end(), caseSensitiveCompare); for (const auto&amp; str : strings) {cout &lt;&lt; str;} &#x2F;&#x2F;忽略大小写bool caseInsensitiveCompare(const std::string&amp; a, const string&amp; b) { string lowerA &#x3D; a, lowerB &#x3D; b; transform(lowerA.begin(), lowerA.end(), lowerA.begin(), ::tolower); transform(lowerB.begin(), lowerB.end(), lowerB.begin(), ::tolower); return lowerA &lt; lowerB;} 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compareChars(const char&amp; a, const char&amp; b) &#123;return a &lt; b;&#125;int main()&#123; // 请在此输入您的代码 int n;cin &gt;&gt; n; vector&lt;string&gt; a; for (int i = 0; i &lt; n; i++) &#123; string name;cin &gt;&gt; name; a.push_back(name); //字符串从小到大排序。遍历 sort(name.begin(), name.end(), compareChars); int count = 1;int all = 0; for (string::const_iterator it = name.begin(); it != name.end(); ++it) &#123; all += (*it - 96) * count; count++; &#125; cout &lt;&lt; all &lt;&lt; endl; &#125; return 0;&#125; 数字转换整数转字符串 string str&#x3D;to_string(n); 字符串长度：str.length(); 字符串转整数：int n&#x3D;stoi(str); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isIncreasing(int n) &#123; string str_n = to_string(n); // 将整数转换为字符串 // 比较字符串中每个字符代表的数值 for (size_t i = 0; i &lt; str_n.length() - 1; ++i) &#123; if (str_n[i] &gt;= str_n[i + 1]) &#123; return false; // 如果当前字符不小于下一个字符，则不是递增的 &#125; &#125; return true; // 所有字符都是递增的 &#125;bool exchange(int n) &#123; string str = to_string(n); int j = str.length(); if (j == 1) &#123; cout &lt;&lt;n&lt;&lt;endl; &#125;else if (j == 2) &#123; if (str[0] &lt; str[1]) &#123; cout &lt;&lt; n &lt;&lt; endl; return true; &#125; else &#123; int temp = str[0]; str[0] = str[1]; str[1] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125;else &#123; //从左到右遍历两遍，每次比较三个，最小的在第三位交换两次结束，最小的在第二位交换一次，再次遍历 //遇到232结构先不慌，继续找321结构，没有就回滚 for (int i = 0; i &lt; j-2; i++) &#123; if (str[i + 2] &lt; str[i] &amp;&amp; str[i + 2] &lt; str[i + 1]) &#123; int temp1 = str[i]; str[i] = str[i + 2]; str[i + 2] = str[i + 1]; str[i + 1] = temp1; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; else if (str[i + 1] &lt; str[i] &amp;&amp; str[i + 1] &lt; str[i + 2]) &#123; int temp = str[i]; if (str[i] &lt;= str[i + 2]) &#123; str[i] = str[i + 1]; str[i + 1] = temp; &#125; else &#123; str[i] = str[i + 1]; str[i + 1] = str[i + 2]; str[i + 2] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125; &#125; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125;&#125;int main()&#123; int number; cin &gt;&gt; number; if (isIncreasing(number)) &#123; //不交换 cout &lt;&lt; number&lt;&lt; endl; &#125; else &#123; exchange(number); &#125; return 0;&#125; 01串的熵计算对数： #include log2(a) 比较浮点数： fabs(res - 11625907.5798) &lt; 0.0001 判断浮点数相同用差&lt;0.01 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n = 23333333; for (int i = 1; i &lt; n; ++i) &#123; double a = i * 1.0 / n; // 0出现的占比 double b = (n - i) * 1.0 / n; // 1出现的占比 double res = 0; res -= a * log2(a) * i + b * log2(b) * (n - i); if (fabs(res - 11625907.5798) &lt; 0.0001) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 冶炼金属二维数组： vector&lt;vector&gt; num(n, vector(2)); 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;algorithm&gt;using namespace std;int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; num(n, vector&lt;int&gt;(2)); int a[2] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; int j; cin &gt;&gt; j; int k; cin &gt;&gt; k; num[i][0] = j; num[i][1] = k; int temp = j / k; if (temp &lt; a[1]) &#123; a[1] = temp; &#125; if (i == 0) &#123; a[1] = temp; &#125; &#125; int k = a[1]; int flag = 0; while (k != 0) &#123; k--; for (int i = 0; i &lt; n; i++) &#123; if (num[i][0] / k != num[i][0] / a[1]) &#123; a[0] = k + 1; flag = 1; break; &#125; &#125; if (flag == 1) &#123; break; &#125; &#125; cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; endl; return 0;&#125; 飞机降落一种很好的循环结构 int T;cin &gt;&gt; T; while (T--)&#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 创建飞机结构体变量struct plane&#123; int t, d, l;&#125;;bool vis[15]; // true表示飞机降落，false表示飞机未降落bool flag; // 标记是否全部安全降落vector&lt;plane&gt; p(15);// 深搜void dfs(int m, int cnt, int last) // last表示此前所有飞机降落所需的单位时间&#123; if (cnt == m) &#123; flag = true; return; &#125; for (int i = 0; i &lt; m; i++) &#123; if (!vis[i] &amp;&amp; p[i].t + p[i].d &gt;= last) // 只有来的时刻+盘旋时间 &gt; last 的飞机才可以安全降落 &#123; vis[i] = true; dfs(m, cnt + 1, max(last, p[i].t) + p[i].l); vis[i] = false; &#125; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l; flag = false; dfs(N, 0, 0); if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; 接龙问题读字符串：遇空格就会停 字符串转数字：int x &#x3D; s[0] - ‘0’, y &#x3D; s[s.size() - 1] - ‘0’; 动态规划DP：重叠子问题，最优子结构问题(递归) 目的：找最长的接龙数列 关系：从后往前看，第i个数的最长子序列数为以第i个数的首位为尾数的那个数的最长序列+1 用一个数组来dp[i]表示以i为尾数字的最长序列 x表示首位，y表示尾数 dp[y]&#x3D;max(dp[x]+1,dp[y]); n记录最大的子序列n&#x3D;max(dp[y],n); 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int dp[10];int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; string s; int m = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s; int x = s[0] - &#x27;0&#x27;, y = s[s.size() - 1] - &#x27;0&#x27;; dp[y] = max(dp[x] + 1, dp[y]); m = max(m, dp[y]); &#125; cout &lt;&lt; n - m &lt;&lt; endl; return 0;&#125; 岛屿个数vector&lt;vector&gt; data(m + 2, vector(n + 2, ‘0’)); 二维全部赋0 深度优先DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int deltaOfSea[8][2] = &#123;&#123;-1, -1&#125;,&#123;-1, 0&#125;,&#123;-1, 1&#125;,&#123;0, 1&#125;,&#123;1, 1&#125;,&#123;1, 0&#125;,&#123;1, -1&#125;,&#123;0, -1&#125;&#125;;//一格的八个方向int deltaOfIsland[4][2] = &#123;&#123;-1, 0&#125;,&#123;1, 0&#125;,&#123;0, -1&#125;,&#123;0, 1&#125;&#125;;//四个方向int ans = 0;void DFS_Island(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; for(int i = 0; i &lt; 4; ++i)&#123;//岛只看四个方向 int newR = r + deltaOfIsland[i][0]; int newC = c + deltaOfIsland[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123; if(data[newR][newC] == &#x27;1&#x27;) DFS_Island(data, newR, newC, m, n); &#125; &#125;&#125;void DFS_Sea(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; //r c记录当前访问的位置 N记作已经访问 for(int i = 0; i &lt; 8; ++i)&#123;//遍历当前位置的8个方向 int newR = r + deltaOfSea[i][0]; int newC = c + deltaOfSea[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123;//当前相邻单元格有效 if(data[newR][newC] == &#x27;1&#x27;)&#123; DFS_Island(data, newR, newC, m, n);//找岛屿 ++ans; &#125; else if(data[newR][newC] == &#x27;0&#x27;)&#123; DFS_Sea(data, newR, newC, m, n); &#125; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; vector&lt; vector&lt;vector&lt;char&gt;&gt; &gt; datas;//用三维存储每一个二维 for(int i = 0; i &lt; t; ++i)&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; data(m + 2, vector&lt;char&gt;(n + 2, &#x27;0&#x27;)); //扩展一圈0，防止遍历不完，可以 for(int r = 1; r &lt; m + 1; ++r)&#123; for(int c = 1; c &lt; n + 1; ++c)&#123; cin &gt;&gt; data[r][c]; &#125; &#125; datas.push_back(data); &#125; for(int i = 0; i &lt; t; ++i)&#123; vector&lt;vector&lt;char&gt;&gt; data = datas[i]; int m = data.size(); int n = data[0].size(); DFS_Sea(data, 0, 0, m, n); cout &lt;&lt; ans &lt;&lt; endl; ans = 0; &#125; return 0;&#125; 字串简写正常暴力只能解决70% 思路：正向统计a数目，遇到b则将之前统计的长度加到ans上 123456789101112131415#include &lt;bits/stdc++.h&gt; using namespace std;int K;long long ans=0,c1_sum=0;string S;char c1,c2;int main()&#123; cin&gt;&gt;K&gt;&gt;S&gt;&gt;c1&gt;&gt;c2; for(int i=K-1,j=0;i&lt;S.length();i++,j++)&#123; if(S[j]==c1) c1_sum++; if(S[i]==c2) ans+=c1_sum; &#125; cout&lt;&lt;ans; return 0;&#125; 整数删除#include 找最值，排序 12345678910111213141516171819202122232425262728293031323334353637//30%#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n,k; cin &gt;&gt; n&gt;&gt;k; vector&lt;int&gt; a; for (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; a.push_back(temp); &#125; for (int i = 0; i &lt; k; i++) &#123; auto minelement = min_element(a.begin(), a.end()); int min = *minelement; for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it) &#123; if (*it == min) &#123; vector&lt;int&gt;::iterator prev = it; vector&lt;int&gt;::iterator next = it; if (it != a.begin()) &#123; --prev; *prev += min; &#125; ++next; if (next != a.end()) &#123; *next += min; &#125; a.erase(it); break; &#125; &#125; &#125; for (int i:a) &#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; int n, k; std::cin &gt;&gt; n &gt;&gt; k; std::vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; k; ++i) &#123; auto minIt = std::min_element(a.begin(), a.end());// int minIndex = std::distance(a.begin(), minIt);//这两处每次需要遍历找很浪费 int min = *minIt; if (minIndex &gt; 0) &#123; a[minIndex - 1] += min; &#125; if (minIndex &lt; n - 1) &#123; a[minIndex + 1] += min; &#125; a.erase(a.begin() + minIndex);//费时间 &#125; for (int i : a) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 使用优先队列（最小堆）维护元素和索引，log时间内找最小值 更新后的元素和索引放入堆中，最小值被标记为INT_MAX 声明优先队列 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 队列中的元素类型为pair，选择vector容器，比较器greater，函数对象，按&gt;运算符，顶部(最小)有最大的权重，没有比较器默认顶部最小权重 插入数据 pq.push(&#123; a[i], i &#125;); 取数据 auto [min, minIndex] = pq.top(); 移除顶部元素 pq.pop(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;climits&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; vector&lt;int&gt; c(n); vector&lt;int&gt; d(n); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; pq.push(&#123; a[i], i &#125;); c[i] = i - 1; d[i] = i + 1; &#125; //创建两个数组实时更新每个数左右最近的下标，更新堆的时候就能快速定位到了 //一个数组用来记录当前数据修改的次数，出栈一次则修改次数-1 while (k-- &gt; 0 &amp;&amp; !pq.empty()) &#123; auto [min, minIndex] = pq.top(); cout &lt;&lt; min &lt;&lt; &#x27; &#x27; &lt;&lt; minIndex &lt;&lt; endl; pq.pop(); if (nums[minIndex]==0) &#123; //删除 int temp1 = c[minIndex]; int temp2 = d[minIndex]; if (temp1 != -1) &#123; a[temp1] += min; d[temp1] = temp2; pq.push(&#123; a[temp1], temp1 &#125;);//更新 nums[temp1]++;//修改次数+1 &#125; if (temp2 != n) &#123; a[temp2] += min; c[temp2] = temp1; pq.push(&#123; a[temp2], temp2 &#125;); nums[temp2]++; &#125; // 标记最小元素为已处理 a[minIndex] = INT_MAX; &#125; else if (nums[minIndex] != 0) &#123; //修改次数-1 k++; nums[minIndex]--; &#125; &#125; // 输出未被标记为已处理的元素 for (int i = 0; i &lt; n; ++i) &#123; if (a[i] != INT_MAX) &#123; cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 景区导游LCA：最近公共祖先 暴力：一层一层跳，lca：倍增 DFS：深度优先搜索root-&gt;a BFS:广度优先 a-b的距离&#x3D;root-&gt;a+root-&gt;b-2*root-&gt;lca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int N = 1e5 + 100;//10^5+100int n, k;int deep[N]; // 深度int dp[N][21]; // dp[i][j]表示从i结点开始跳2^j步可到达的结点vector&lt;int&gt; edge[N]; // 边vector&lt;int&gt; weight[N]; // 权值ll path[N]; // 原始的游览路线ll dist[N]; // dist[i]存储i到根结点的距离void dfs(int u, int father) // LCA的前置算法(模板) 层数 父亲节点&#123; deep[u] = deep[father] + 1; dp[u][0] = father; for (int i = 1; i &lt;= 20; i++) &#123; dp[u][i] = dp[dp[u][i - 1]][i - 1]; &#125; for (size_t i = 0; i &lt; edge[u].size(); i++) &#123; int v = edge[u][i], w = weight[u][i]; if (v == father) continue; dist[v] = dist[u] + w; dfs(v, u); //下一层递归 &#125;&#125;int LCA(int x, int y) // 求x和y的最近公共祖先(模板)&#123; if (deep[x] &lt; deep[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) &#123; if (deep[dp[x][i]] &gt;= deep[y]) &#123; x = dp[x][i]; &#125; &#125; if (x == y) return x; for (int i = 20; i &gt;= 0; i--) &#123; if (dp[x][i] != dp[y][i]) &#123; x = dp[x][i]; y = dp[y][i]; &#125; &#125; return dp[x][0];&#125;ll get_dist(int x, int y) // 求x和y的距离&#123; if (x == 0 || y == 0) return 0; return dist[x] + dist[y] - 2 * dist[LCA(x, y)];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt; n; i++) // 插入n-1条无向边 &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[u].push_back(v); edge[v].push_back(u); weight[u].push_back(w); weight[v].push_back(w); &#125; dfs(1, 0); // 跑一遍dfs为LCA做准备 ll sum = 0; // sum存储原始游览路线的总路径长度 for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; path[i]; if (i &gt; 1) // 从第二个景点开始计算 &#123; sum += get_dist(path[i], path[i - 1]); // 依次累加 &#125; &#125; for (int i = 1; i &lt;= k; i++) // 除去第i个景点 &#123; ll dist1 = get_dist(path[i], path[i - 1]); ll dist2 = get_dist(path[i], path[i + 1]); ll dist3 = get_dist(path[i - 1], path[i + 1]); cout &lt;&lt; sum - dist1 - dist2 + dist3 &lt;&lt; &quot; &quot;; // 套公式计算即可 &#125; cout &lt;&lt; endl; return 0;&#125; 基础算法：枚举 贪心 模拟二分 排序：桶排序 归并排序 快速排序 搜索：DFS BFS 剪枝 动态规划：一维dp 背包dp 树形dp 状压dp 数位dp","categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]}],"categories":[{"name":"c++","slug":"c","permalink":"http://example.com/categories/c/"},{"name":"工具-环境","slug":"工具-环境","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83/"},{"name":"杂说","slug":"杂说","permalink":"http://example.com/categories/%E6%9D%82%E8%AF%B4/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"四大件","slug":"四大件","permalink":"http://example.com/categories/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"库","slug":"库","permalink":"http://example.com/categories/%E5%BA%93/"},{"name":"Linux高性能服务器编程","slug":"Linux高性能服务器编程","permalink":"http://example.com/categories/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://example.com/tags/Node-js/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"},{"name":"文心一言","slug":"文心一言","permalink":"http://example.com/tags/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"公众号开发","slug":"公众号开发","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"},{"name":"win+vmware","slug":"win-vmware","permalink":"http://example.com/tags/win-vmware/"},{"name":"HTTP 请求处理、路由、JSON 序列化","slug":"HTTP-请求处理、路由、JSON-序列化","permalink":"http://example.com/tags/HTTP-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E3%80%81%E8%B7%AF%E7%94%B1%E3%80%81JSON-%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Web开发框架","slug":"Web开发框架","permalink":"http://example.com/tags/Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"c","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}]}